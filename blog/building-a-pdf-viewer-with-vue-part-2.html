<!doctype html>
<html>
  <head>
    <title>Displaying PDFs lazily with Vue - rossta.net</title>
<meta name="description" content="This tutorial demonstrates how to use Vue to defer fetching and rendering of PDF page data until elements are scrolled into the client browser." />
<meta name="keywords" content="Vue" />
<meta name="site" content="rossta.net" />
<meta property="og:site_name" content="rossta.net" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:creator" content="Ross Kaffenberger" />
<meta name="twitter:description" content="This tutorial demonstrates how to use Vue to defer fetching and rendering of PDF page data until elements are scrolled into the client browser." />
<meta name="twitter:image:src" content="https://rossta.net/assets/images/" />
<meta name="twitter:title" content="Displaying PDFs lazily with Vue" />
<meta property="og:description" content="This tutorial demonstrates how to use Vue to defer fetching and rendering of PDF page data until elements are scrolled into the client browser." />
<meta property="og:image" content="https://rossta.net/assets/images/" />
<meta property="og:title" content="Displaying PDFs lazily with Vue" />
    <meta charset="utf-8" />
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="mobile-web-app-capable" content="yes">

    <link rel="pingback" href="https://webmention.io/rossta.net/xmlrpc" />
    <link rel="webmention" href="https://webmention.io/rossta.net/webmention" />

    <link href='/assets/css/app.chunk.f8e2a249f86d767750f7.css' rel='stylesheet'></link>
  </head>
  <body id="application" class="typekit">
    <nav id="welcome-nav" class="top-bar" data-topbar>
  <ul class="title-area">
    <li class="name">
      <h1><a class="logo" href="/"><span>rossta.net</span></a></h1>
    </li>
    <li class="toggle-topbar menu-icon"><a href="#">Menu</a></li>
  </ul>

</nav>

    <div class="row">
      <section id="main" role="main" class="large-12 small-12 columns">
          <section id="blog" class="margin-bottom double">
    <article class="post margin-bottom double">
      <header class="page-header with-summary">
  <h1>
    Displaying PDFs lazily with Vue
  </h1>
    <h3>
      Building a PDF Viewer with Vue - Part 2
    </h3>
</header>


      <p>As we demonstrated in the <a href="/blog/building-a-pdf-viewer-with-vue-part-1.html">previous post</a>, we can render pages of a PDF to <code>&lt;canvas&gt;</code> elements using PDF.js and Vue. We were able to use a simple Vue component hierarchy to separate the responsibilities of data fetching and page rendering. We used the PDF.js library to fetch the page data and hand off the work of drawing the data onto <code>&lt;canvas&gt;</code> elements.</p>

<p>In this post, we&#39;ll add a new requirement: we should only render pages when they are visible, i.e., as they are scrolled into the viewport. Previously, we were rendering all pages eagerly, regardless of whether they were appearing in the client browser. For a large PDF, this could mean valuable resources are used to render many pages offscreen and may never be viewed. Let&#39;s see how we can fix that using Vue.</p>

<p>The latest source code for this project is on Github at <a href="https://github.com/rossta/vue-pdfjs-demo">rossta/vue-pdfjs-demo</a>. To see the version of the project described in this post, <a href="https://github.com/rossta/vue-pdfjs-demo/tree/tutorial/part-2-scrolling">checkout the <code>part-2-scrolling</code> branch</a>. Here&#39;s the <a href="https://rossta.net/vue-pdfjs-demo/">project demo</a>:</p>

<p><a href="https://rossta.net/vue-pdfjs-demo/"><img src="/assets/images/screenshots/screenshot-pdf-viewer.png" alt="Demo" /></a></p>

      <h3 id="adding-scroll-behavior" class="title">
        <a name="adding-scroll-behavior" class="anchor" href="#adding-scroll-behavior">       <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16">
       <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
       </svg>
</a>
        Adding scroll behavior
      </h3>
    
<p>To review, once a <code>&lt;PDFPage&gt;</code> component mounts, it calls the <code>page.render</code> method to draw the PDF data to the <code>&lt;canvas&gt;</code> element. To defer page rendering, this method should only be called once the <code>&lt;canvas&gt;</code> element has become visible in the scroll window of the document. We&#39;ll detect visibility of the page by inferring from the scroll boundaries or the parent component, <code>&lt;PDFDocument&gt;</code> along with the position and dimensions of the child <code>&lt;PDFPage&gt;</code> components.</p>

<p>First, a CSS change to make our document scrollable within a relatively positioned parent element.</p>

<pre><code class="css">.pdf-document {
  position: absolute;
  overflow: auto;
  width: 100%;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
}
</code></pre>

<p>The <code>&lt;PDFDocument&gt;</code> will track its visible boundaries using the <code>scrollTop</code> and <code>clientHeight</code> properties of its element. We&#39;ll record these boundaries when the component mounts.</p>

<pre><code class="javascript">// src/components/PDFDocument.vue

data() {
  return {
    scrollTop: 0,
    clientHeight: 0,
    // ...
  };
},

methods: {
  updateScrollBounds() {
    const {scrollTop, clientHeight} = this.$el;
    this.scrollTop = scrollTop;
    this.clientHeight = clientHeight;
  },
  // ...
},

mounted() {
  this.updateScrollBounds();
},
// ...
</code></pre>

<p>The <code>scrollTop</code> according to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop">MDN</a>:</p>

<blockquote>
<p>An element&#39;s <code>scrollTop</code> value is a measurement of the distance from the element&#39;s top to its topmost <em>visible</em> content.</p>
</blockquote>

<p>The <code>clientHeight</code> according to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight">MDN</a>:</p>

<blockquote>
<p>The <code>clientHeight</code> read-only property is zero for elements with no CSS or inline layout boxes, otherwise it&#39;s the inner height of an element in pixels, including padding but not the horizontal scrollbar height, border, or margin.</p>
</blockquote>

<p>Used together, we can determine what portion of the document is visible to the user.</p>

      <h3 id="detecting-page-visibility" class="title">
        <a name="detecting-page-visibility" class="anchor" href="#detecting-page-visibility">       <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16">
       <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
       </svg>
</a>
        Detecting page visibility
      </h3>
    
<p>The <code>&lt;PDFPage&gt;</code> component will track the boundaries of its underlying canvas element, whose dimensions we demonstrated how to calculate in the previous post. As with the document component, we&#39;ll trigger the update of this data property when the page component mounts:</p>

<pre><code class="javascript">// src/components/PDFPage.vue

data() {
  return {
    elementTop: 0,
    elementHeight: 0,
    // ...
  };
},

methods: {
  updateElementBounds() {
    const {offsetTop, offsetHeight} = this.$el;
    this.elementTop = offsetTop;
    this.elementHeight = offsetHeight;
  },
  // ...
},

mounted() {
  this.updateElementBounds();
},
// ...
</code></pre>

<p>The element&#39;s <code>offsetTop</code> property will represent the distance from its top boundary to that of the containing document element <code>div</code>. Recording its <code>offsetHeight</code> enables us to determine how far the bottom of the element is from the top of the container.</p>

<p>Note that the <code>updateElementBounds</code> and <code>updateScrollBounds</code> methods are necessary because properties of DOM elements are outside of Vue&#39;s control, i.e., they are not reactive. These methods exist to maintain reactive copies of these properties in Vue and we must trigger them somehow when scrolling or resizing the window so that the changes will propagate.</p>

<p>Since we can pass the scroll data of the parent component to the child page components as props, we now have what we need to determine if a given page is visible in the scroll area of the document.</p>

<pre><code class="javascript">// src/components/PDFPage.vue

props: {
  scrollTop: {
    type: Number,
    default: 0
  },
  clientHeight: {
    type: Number,
    default: 0
  },
  // ...
},

computed: {
  isElementVisible() {
    const {elementTop, elementBottom, scrollTop, scrollBottom} = this;
    if (!elementBottom) return;

    return elementTop &lt; scrollBottom &amp;&amp; elementBottom &gt; scrollTop;
  },

  elementBottom() {
    return this.elementTop + this.elementHeight;
  },

  scrollBottom() {
    return this.scrollTop + this.clientHeight;
  },
  // ...
},
// ...
</code></pre>

<p>We&#39;ll use a computed property <code>isElementVisible</code> which will update whenever either the <code>scrollBounds</code> or <code>elementBounds</code> change. It will simply check if the top of the element is above the bottom of the scroll area (<code>top &lt; scrollBottom</code>) and the bottom of the element is below the top of the scroll area (<code>bottom &gt; scrollTop</code>). Note that the <code>y</code> dimension increases moving down the screen.</p>

<p>For another approach to detecting visibility in Vue, checkout the <a href="https://github.com/Akryum/vue-observe-visibility">Akryum/vue-observe-visibility</a> on Github, which is also available as an NPM package.</p>

      <h3 id="lazy-rendering-pages" class="title">
        <a name="lazy-rendering-pages" class="anchor" href="#lazy-rendering-pages">       <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16">
       <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
       </svg>
</a>
        Lazy rendering pages
      </h3>
    
<p>Previously, we called the <code>drawPage</code> method (described in the <a href="https://rossta.net/blog/building-a-pdf-viewer-with-vue-part-1.html#rendering-the-page">previous post</a>) when the page component mounted. To make the page render lazily, now we call the method only when the element becomes visible, using a watcher.</p>

<pre><code class="javascript">// src/components/PDFPage.vue

watch: {
  isElementVisible(isElementVisible) {
    if (isElementVisible) this.drawPage();
  },
  // ...
},
// ...
</code></pre>

<p>We&#39;ve defined <code>drawPage</code> such that it will only render once if called multiple times.</p>

<p>In the page components, we can simply watch for changes in scroll boundaries and scale—changes to these props may cause a previously &quot;hidden&quot; page to become visible in the browser.</p>

<pre><code class="javascript">// src/components/PDFPage.vue

watch: {
  scale: &#39;updateElementBounds&#39;,
  scrollTop: &#39;updateElementBounds&#39;,
  clientHeight: &#39;updateElementBounds&#39;,
  // ...
},
// ...
</code></pre>

<p>For the document component, we add listeners to DOM events to trigger the <code>updateScrollBounds</code> method within the <code>mounted</code> hook.</p>

<pre><code class="javascript">// src/components/PDFDocument.vue
import throttle from &#39;lodash/throttle&#39;;

export default {
  // ...
  mounted() {
    this.updateScrollBounds();
    const throttledCallback = throttle(this.updateScrollBounds, 300);

    this.$el.addEventListener(&#39;scroll&#39;, throttledCallback, true);
    window.addEventListener(&#39;resize&#39;, throttledCallback, true);

    this.throttledOnResize = throttledCallback;
  },

  beforeDestroy() {
    window.removeEventListener(&#39;resize&#39;, this.throttledOnResize, true);
  },
  // ...
</code></pre>

<p>A few notes about the implementation above: we use lodash&#39;s <code>throttle</code> function to ensure our callback is only triggered once every 300ms; otherwise, we&#39;d be making this update potentially dozens of times a second, which for our purposes is unnecessary and could potentially be a performance bottleneck. Since we can attach our <code>throttledCallback</code> to the <code>&#39;scroll&#39;</code> event listener of <code>this.$el</code>, we will also be cleaned up nicely during Vue teardown phase. However, since the <code>&#39;resize&#39;</code> event will currently only work on the <code>window</code>, we&#39;ll need to store a reference to the throttled callback as <code>this.throttledOnResize</code> so we can remove the event listener in Vue&#39;s <code>beforeDestroy</code> hook.</p>

<p>For a great explanation of throttling (and its cousin, debouncing) event callbacks, check out <a href="https://css-tricks.com/debouncing-throttling-explained-examples/">this post on CSS tricks</a>.</p>

      <h3 id="adding-quot-infinite-quot-scrolling" class="title">
        <a name="adding-quot-infinite-quot-scrolling" class="anchor" href="#adding-quot-infinite-quot-scrolling">       <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16">
       <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
       </svg>
</a>
        Adding &quot;infinite&quot; scrolling
      </h3>
    
<p>So far we have deferred rendering individual pages to mounted canvas elements until scrolled into view. This allows us to spare CPU cycles at the cost of the brief visual delay as newly visible pages are drawn. However, we are still creating the <code>&lt;PDFPage&gt;</code> components for every PDF page, regardless of whether they are visible. This results in <code>n - visible</code> blank <code>&lt;canvas&gt;</code> elements below the fold.</p>

<p>We can go one step further. Instead of fetching all the pages up front, we&#39;ll fetch pages in batches as the user scrolls to the bottom of the document. In other words, we&#39;ll implement &quot;infinite scrolling&quot; for PDF pages (though most PDFs of which I&#39;m aware are finite in length). Fetching in batches is a compromise between eagerly loading all pages and fetching one at a time.</p>

<p>To keep things simple for this tutorial, we&#39;ll add batching directly to the <code>&lt;PDFDocument&gt;</code> component; in a future post, we&#39;ll extract this information to other parts of our application.</p>

      <h3 id="batched-fetching" class="title">
        <a name="batched-fetching" class="anchor" href="#batched-fetching">       <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16">
       <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
       </svg>
</a>
        Batched fetching
      </h3>
    
<p>Recall in our document component, we&#39;re tracking a <code>pdf</code> property and an array of <code>pages</code>. We now add a <code>cursor</code> to represent the highest page number in the document we&#39;ve attempted to fetch. We also will track the expected <code>pageCount</code> using a property provided by the <code>pdf</code> object.</p>

<pre><code class="javascript">// src/components/PDFDocument.vue

data() {
  return {
    pdf: undefined,
    pages: [],
    cursor: 0,
    // ...
  };
},

computed: {
  pageCount() {
    return this.pdf ? this.pdf.numPages : 0;
  },
  // ...
},
// ...
</code></pre>

<p>We also previously added a watcher for the <code>pdf</code> property to fetch all pages:</p>

<pre><code class="javascript">// src/components/PDFDocument.vue

watch: {
  pdf(pdf) {
    this.pages = [];
    const promises = range(1, pdf.numPages).
      map(number =&gt; pdf.getPage(number));

    Promise.all(promises).
      then(pages =&gt; (this.pages = pages));
  },
  // ...
},
// ...
</code></pre>

<p>We&#39;ll modify this watcher by extracting a method to fetch pages in batches:</p>

<pre><code class="javascript">// src/components/PDFDocument.vue

watch: {
  pdf(pdf) {
    this.pages = [];
    this.fetchPages();
  },
  // ...
},
// ...
</code></pre>

<p>Here is our new <code>fetchPages</code> implementation:</p>

<pre><code class="javascript">// src/components/PDFDocument.vue

const BATCH_COUNT = 10;

export default {
  // ...

  methods: {
    fetchPages() {
      if (!this.pdf) return;

      const currentCount = this.pages.length;
      if (this.pageCount &gt; 0 &amp;&amp; currentCount === this.pageCount) return;
      if (this.cursor &gt; currentCount) return;

      const startPage = currentCount + 1; // PDF page numbering starts at 1
      const endPage = Math.min(currentCount + BATCH_COUNT, this.pageCount);
      this.cursor = endPage;

      getPages(this.pdf, startPage, endPage)
        .then((pages) =&gt; {
          this.pages.splice(currentCount, 0, ...pages);
          return this.pages;
        })
        .catch((response) =&gt; {
          this.$emit(&#39;document-errored&#39;);
        });
    },
    // ...
  }
  // ...
</code></pre>

<p>The added complexity in <code>fetchPages</code> allows us to request small batches of pages with each subsequent call. The <code>currentCount</code> represents the total number of pages that have already been fetched. The <code>startPage</code> is simply the next page number of the next would-be page in the array, and the <code>endPage</code> of the batch is the lesser of an arbitrarily small batch of pages (<code>BATCH_COUNT</code>) and the remaining pages. We&#39;re able to insert these pages in the correct location in the tracked pages array with <code>this.pages.splice(currentCount, 0, ...pages)</code>. We also use the <code>this.cursor</code> property to track the most recently request <code>endPage</code> to ensure the same batch is only requested once.</p>

      <h3 id="why-splice-" class="title">
        <a name="why-splice-" class="anchor" href="#why-splice-">       <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16">
       <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
       </svg>
</a>
        Why splice?
      </h3>
    
<p>You may ask, why not simply add the new pages on to the end of the <code>this.pages</code> array instead? You could imagine using an expression like <code>this.pages.push.apply(this.pages, pages)</code> to modify the array in place or replacing the array altogether with <code>this.pages = [...this.pages, ...pages]</code> or <code>concat</code>. The reason is that <code>getPages</code> is asynchronous—it returns a promise that fulfills when all pages in the batch have been fetched. It is safer to assume this method can be called in rapid succession where multiple batch requests may be in flight simultaneously. Using <code>splice</code> to add new pages at the expected position will ensure our batches are inserted into the <code>this.pages</code> array in the correct order.</p>

      <h3 id="finding-the-bottom" class="title">
        <a name="finding-the-bottom" class="anchor" href="#finding-the-bottom">       <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16">
       <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
       </svg>
</a>
        Finding the bottom
      </h3>
    
<p>To determine whether the user has scrolled to the bottom of the last of the fetched pages, we will again lean on properties of <code>this.$el</code>. We can ask if the sum of the <code>scrollTop</code> of the document and its visible height, <code>clientHeight</code>, has equalled its total <code>scrollHeight</code>.</p>

<pre><code class="javascript">// src/components/PDFDocument.vue

methods: {
  isBottomVisible() {
    const {scrollTop, clientHeight, scrollHeight} = this.$el;
    return scrollTop + clientHeight &gt;= scrollHeight;
  },
  // ...
},
// ...
</code></pre>

<p>We&#39;ll call this method during <code>updateScrollBounds</code> method and record a tracked a true/false property, <code>didReachBottom</code>.</p>

<pre><code class="javascript">// src/components/PDFDocument.vue

data() {
  return {
    didReachBottom: false,
    // ...
  };
},

methods: {
  updateScrollBounds() {
    const {scrollTop, clientHeight} = this.$el;
    this.scrollTop = scrollTop;
    this.clientHeight = clientHeight;
    this.didReachBottom = this.isBottomVisible();
  },
  // ...
},
// ...
</code></pre>

<p>We can then use a watcher to call <code>fetchPages</code> if this property flips from <code>false</code> to <code>true</code>. This watcher would fire continuously in a cycle as the user scrolls to the bottom and more pages are fetched.</p>

<pre><code class="javascript">// src/components/PDFDocument.vue

watch: {
  didReachBottom(didReachBottom) {
    if (didReachBottom) this.fetchPages();
  },
  // ...
},
// ...
</code></pre>

<p>For another in-depth look at adding infinite scrolling for Vue, check out Chris Nwamba&#39;s <a href="https://scotch.io/tutorials/simple-asynchronous-infinite-scroll-with-vue-watchers">post on Scotch.io</a>. There are also a number of packages that abstract infinite scrolling if you&#39;d prefer to lean on open source, including <a href="https://github.com/Akryum/vue-virtual-scroller">Akryum/vue-virtual-scroller</a> and <a href="https://github.com/ElemeFE/vue-infinite-scroll">ElemeFE/vue-infinite-scroll</a>.</p>

      <h3 id="wrapping-up" class="title">
        <a name="wrapping-up" class="anchor" href="#wrapping-up">       <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16">
       <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
       </svg>
</a>
        Wrapping up
      </h3>
    
<p>We&#39;ve succeeded in making our documents more lazy; now we can defer both data fetching and page rendering until necessary, potentially improving performance of the initial page load and avoiding waste, especially for large documents.</p>

<p>We&#39;ve been adding quite a bit of complexity though to our existing <code>&lt;PDFDocument&gt;</code> and <code>&lt;PDFPage&gt;</code> components; they now both are responsible for making API requests, calculating element boundaries, lazy behavior, etc. Ideally, we&#39;ll want to limit the responsibility of a given component to make our application less resistant to change. In the next post, we&#39;ll refactor our PDF viewer to to separate out data fetching and scrolling behavior into separate &quot;renderless components&quot;. These changes will subsequently allow us to share code and add a new feature: a preview pane.</p>

<p>And now you&#39;ve reached the bottom of this post!</p>

    </article>

    <section class="signup-form-standalone margin-bottom quadruple">
      <script src="https://f.convertkit.com/ckjs/ck.5.js" async></script>
<form
  action="https://app.convertkit.com/forms/818387/subscriptions?ref=Vue"
  class="seva-form formkit-form"
  method="post"
  data-sv-form="818387"
  data-uid="cda82aafbf"
  data-format="inline"
  data-version="5"
  data-options="{&quot;settings&quot;:{&quot;after_subscribe&quot;:{&quot;action&quot;:&quot;message&quot;,&quot;success_message&quot;:&quot;Success! Now check your email to confirm your subscription.&quot;,&quot;redirect_url&quot;:&quot;&quot;},&quot;modal&quot;:{&quot;trigger&quot;:&quot;timer&quot;,&quot;scroll_percentage&quot;:null,&quot;timer&quot;:&quot;300&quot;,&quot;devices&quot;:null,&quot;show_once_every&quot;:&quot;7&quot;},&quot;recaptcha&quot;:{&quot;enabled&quot;:false},&quot;return_visitor&quot;:{&quot;action&quot;:&quot;show&quot;,&quot;custom_content&quot;:&quot;&quot;},&quot;slide_in&quot;:{&quot;display_in&quot;:null,&quot;trigger&quot;:null,&quot;scroll_percentage&quot;:null,&quot;timer&quot;:null,&quot;devices&quot;:null,&quot;show_once_every&quot;:null}}}"
  min-width="400 500 600 700 800"
>
  <div data-style="clean">
      <h3>
  Did you like this post?
</h3>
<p>
  Please
  <a href="https://twitter.com/intent/tweet?text=Displaying%20PDFs%20lazily%20with%20Vue&amp;url=https%3A%2F%2Frossta.net%2Fblog%2Fbuilding-a-pdf-viewer-with-vue-part-2.html" target="_blank" rel="noopener">share it on Twitter</a>
  and enter your email below to subscribe to my newsletter on
  Vue and the web. Thank you!
</p>

    <ul class="formkit-alert formkit-alert-error" data-element="errors" data-group="alert"></ul>
    <div data-element="fields" data-stacked="false" class="seva-fields formkit-fields">
      <div class="formkit-field">
        <input
          class="formkit-input"
          name="email_address"
          placeholder="Your email address"
          required=""
          type="text"
          style="border-color: rgb(227, 227, 227); border-radius: 4px; color: rgb(0, 0, 0); font-weight: 400;"
        />
      </div>
      <button
        data-element="submit"
        class="formkit-submit formkit-submit"
        style="background-color: rgb(22, 119, 190); border-radius: 4px; color: rgb(255, 255, 255); font-weight: 400;"
      >
        <div class="formkit-spinner">
          <div></div>
          <div></div>
          <div></div>
        </div>
        <span>Subscribe</span>
      </button>
    </div>
    <a
      href="https://convertkit.com/?utm_source=dynamic&amp;utm_medium=referral&amp;utm_campaign=poweredby&amp;utm_content=form"
      class="formkit-powered-by"
      data-element="powered-by"
      target="_blank"
      rel="noopener noreferrer"
      >Powered By ConvertKit</a
    >
  </div>
  <style>
    .formkit-form[data-uid='cda82aafbf'] * {
      font-family: 'Helvetica Neue', Helvetica, Arial, Verdana, sans-serif;
      box-sizing: border-box;
    }
    .formkit-form[data-uid='cda82aafbf'] legend {
      border: none;
      font-size: inherit;
      margin-bottom: 10px;
      padding: 0;
      position: relative;
      display: table;
    }
    .formkit-form[data-uid='cda82aafbf'] fieldset {
      border: 0;
      padding: 0.01em 0 0 0;
      margin: 0;
      min-width: 0;
    }
    .formkit-form[data-uid='cda82aafbf'] body:not(:-moz-handler-blocked) fieldset {
      display: table-cell;
    }

    .formkit-form[data-uid='cda82aafbf'][data-format='modal'] {
      display: none;
    }
    .formkit-form[data-uid='cda82aafbf'][data-format='slide in'] {
      display: none;
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-input,
    .formkit-form[data-uid='cda82aafbf'] .formkit-select,
    .formkit-form[data-uid='cda82aafbf'] .formkit-checkboxes {
      width: 100%;
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-button,
    .formkit-form[data-uid='cda82aafbf'] .formkit-submit {
      border: 0;
      border-radius: 5px;
      color: #ffffff;
      cursor: pointer;
      display: inline-block;
      text-align: center;
      font-size: 15px;
      font-weight: 500;
      cursor: pointer;
      margin-bottom: 15px;
      overflow: hidden;
      padding: 0;
      position: relative;
      vertical-align: middle;
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-button:hover,
    .formkit-form[data-uid='cda82aafbf'] .formkit-submit:hover,
    .formkit-form[data-uid='cda82aafbf'] .formkit-button:focus,
    .formkit-form[data-uid='cda82aafbf'] .formkit-submit:focus {
      outline: none;
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-button:hover > span,
    .formkit-form[data-uid='cda82aafbf'] .formkit-submit:hover > span,
    .formkit-form[data-uid='cda82aafbf'] .formkit-button:focus > span,
    .formkit-form[data-uid='cda82aafbf'] .formkit-submit:focus > span {
      background-color: rgba(0, 0, 0, 0.1);
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-button > span,
    .formkit-form[data-uid='cda82aafbf'] .formkit-submit > span {
      display: block;
      -webkit-transition: all 300ms ease-in-out;
      transition: all 300ms ease-in-out;
      padding: 12px 24px;
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-input {
      background: #ffffff;
      font-size: 15px;
      padding: 12px;
      border: 1px solid #e3e3e3;
      -webkit-flex: 1 0 auto;
      -ms-flex: 1 0 auto;
      flex: 1 0 auto;
      line-height: 1.4;
      margin: 0;
      -webkit-transition: border-color ease-out 300ms;
      transition: border-color ease-out 300ms;
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-input:focus {
      outline: none;
      border-color: #1677be;
      -webkit-transition: border-color ease 300ms;
      transition: border-color ease 300ms;
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-input::-webkit-input-placeholder {
      color: #848585;
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-input::-moz-placeholder {
      color: #848585;
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-input:-ms-input-placeholder {
      color: #848585;
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-input::placeholder {
      color: #848585;
    }
    .formkit-form[data-uid='cda82aafbf'] [data-group='dropdown'] {
      position: relative;
      display: inline-block;
      width: 100%;
    }
    .formkit-form[data-uid='cda82aafbf'] [data-group='dropdown']::before {
      content: '';
      top: calc(50% - 2.5px);
      right: 10px;
      position: absolute;
      pointer-events: none;
      border-color: #4f4f4f transparent transparent transparent;
      border-style: solid;
      border-width: 6px 6px 0 6px;
      height: 0;
      width: 0;
      z-index: 999;
    }
    .formkit-form[data-uid='cda82aafbf'] [data-group='dropdown'] select {
      height: auto;
      width: 100%;
      cursor: pointer;
      color: #333333;
      line-height: 1.4;
      margin-bottom: 0;
      padding: 0 6px;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      font-size: 15px;
      padding: 12px;
      padding-right: 25px;
      border: 1px solid #e3e3e3;
      background: #ffffff;
    }
    .formkit-form[data-uid='cda82aafbf'] [data-group='dropdown'] select:focus {
      outline: none;
    }
    .formkit-form[data-uid='cda82aafbf'] [data-group='checkboxes'] {
      text-align: left;
      margin: 0;
    }
    .formkit-form[data-uid='cda82aafbf'] [data-group='checkboxes'] [data-group='checkbox'] {
      margin-bottom: 10px;
    }
    .formkit-form[data-uid='cda82aafbf'] [data-group='checkboxes'] [data-group='checkbox'] * {
      cursor: pointer;
    }
    .formkit-form[data-uid='cda82aafbf']
      [data-group='checkboxes']
      [data-group='checkbox']:last-of-type {
      margin-bottom: 0;
    }
    .formkit-form[data-uid='cda82aafbf']
      [data-group='checkboxes']
      [data-group='checkbox']
      input[type='checkbox'] {
      display: none;
    }
    .formkit-form[data-uid='cda82aafbf']
      [data-group='checkboxes']
      [data-group='checkbox']
      input[type='checkbox']
      + label::after {
      content: none;
    }
    .formkit-form[data-uid='cda82aafbf']
      [data-group='checkboxes']
      [data-group='checkbox']
      input[type='checkbox']:checked
      + label::after {
      border-color: #ffffff;
      content: '';
    }
    .formkit-form[data-uid='cda82aafbf']
      [data-group='checkboxes']
      [data-group='checkbox']
      input[type='checkbox']:checked
      + label::before {
      background: #10bf7a;
      border-color: #10bf7a;
    }
    .formkit-form[data-uid='cda82aafbf'] [data-group='checkboxes'] [data-group='checkbox'] label {
      position: relative;
      display: inline-block;
      padding-left: 28px;
    }
    .formkit-form[data-uid='cda82aafbf']
      [data-group='checkboxes']
      [data-group='checkbox']
      label::before,
    .formkit-form[data-uid='cda82aafbf']
      [data-group='checkboxes']
      [data-group='checkbox']
      label::after {
      position: absolute;
      content: '';
      display: inline-block;
    }
    .formkit-form[data-uid='cda82aafbf']
      [data-group='checkboxes']
      [data-group='checkbox']
      label::before {
      height: 16px;
      width: 16px;
      border: 1px solid #e3e3e3;
      background: #ffffff;
      left: 0px;
      top: 3px;
    }
    .formkit-form[data-uid='cda82aafbf']
      [data-group='checkboxes']
      [data-group='checkbox']
      label::after {
      height: 4px;
      width: 8px;
      border-left: 2px solid #4d4d4d;
      border-bottom: 2px solid #4d4d4d;
      -webkit-transform: rotate(-45deg);
      -ms-transform: rotate(-45deg);
      transform: rotate(-45deg);
      left: 4px;
      top: 8px;
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-alert {
      background: #f9fafb;
      border: 1px solid #e3e3e3;
      border-radius: 5px;
      -webkit-flex: 1 0 auto;
      -ms-flex: 1 0 auto;
      flex: 1 0 auto;
      list-style: none;
      margin: 25px auto;
      padding: 12px;
      text-align: center;
      width: 100%;
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-alert:empty {
      display: none;
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-alert-success {
      background: #d3fbeb;
      border-color: #10bf7a;
      color: #0c905c;
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-alert-error {
      background: #fde8e2;
      border-color: #f2643b;
      color: #ea4110;
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-spinner {
      display: -webkit-box;
      display: -webkit-flex;
      display: -ms-flexbox;
      display: flex;
      height: 0px;
      width: 0px;
      margin: 0 auto;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      width: 0px;
      overflow: hidden;
      text-align: center;
      -webkit-transition: all 300ms ease-in-out;
      transition: all 300ms ease-in-out;
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-spinner > div {
      margin: auto;
      width: 12px;
      height: 12px;
      background-color: #fff;
      opacity: 0.3;
      border-radius: 100%;
      display: inline-block;
      -webkit-animation: formkit-bouncedelay-formkit-form-data-uid-cda82aafbf- 1.4s infinite
        ease-in-out both;
      animation: formkit-bouncedelay-formkit-form-data-uid-cda82aafbf- 1.4s infinite ease-in-out
        both;
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-spinner > div:nth-child(1) {
      -webkit-animation-delay: -0.32s;
      animation-delay: -0.32s;
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-spinner > div:nth-child(2) {
      -webkit-animation-delay: -0.16s;
      animation-delay: -0.16s;
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-submit[data-active] .formkit-spinner {
      opacity: 1;
      height: 100%;
      width: 50px;
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-submit[data-active] .formkit-spinner ~ span {
      opacity: 0;
    }
    @-webkit-keyframes formkit-bouncedelay-formkit-form-data-uid-cda82aafbf- {
      0%,
      80%,
      100% {
        -webkit-transform: scale(0);
        -ms-transform: scale(0);
        transform: scale(0);
      }
      40% {
        -webkit-transform: scale(1);
        -ms-transform: scale(1);
        transform: scale(1);
      }
    }
    @keyframes formkit-bouncedelay-formkit-form-data-uid-cda82aafbf- {
      0%,
      80%,
      100% {
        -webkit-transform: scale(0);
        -ms-transform: scale(0);
        transform: scale(0);
      }
      40% {
        -webkit-transform: scale(1);
        -ms-transform: scale(1);
        transform: scale(1);
      }
    }
    .formkit-form[data-uid='cda82aafbf'] {
      max-width: 700px;
    }
    .formkit-form[data-uid='cda82aafbf'] [data-style='clean'] {
      width: 100%;
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-fields {
      display: -webkit-box;
      display: -webkit-flex;
      display: -ms-flexbox;
      display: flex;
      -webkit-flex-wrap: wrap;
      -ms-flex-wrap: wrap;
      flex-wrap: wrap;
      margin: 0 auto;
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-field,
    .formkit-form[data-uid='cda82aafbf'] .formkit-submit {
      margin: 0 0 15px 0;
      -webkit-flex: 1 0 100%;
      -ms-flex: 1 0 100%;
      flex: 1 0 100%;
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-powered-by {
      color: #7d7d7d;
      display: block;
      font-size: 12px;
      margin: 0;
      text-align: center;
    }
    .formkit-form[data-uid='cda82aafbf'] .formkit-powered-by[data-active='false'] {
      opacity: 0.5;
    }
    .formkit-form[data-uid='cda82aafbf'][min-width~='700'] [data-style='clean'],
    .formkit-form[data-uid='cda82aafbf'][min-width~='800'] [data-style='clean'] {
      padding: 10px;
    }
    .formkit-form[data-uid='cda82aafbf'][min-width~='700'] .formkit-fields[data-stacked='false'],
    .formkit-form[data-uid='cda82aafbf'][min-width~='800'] .formkit-fields[data-stacked='false'] {
      margin-left: -5px;
      margin-right: -5px;
    }
    .formkit-form[data-uid='cda82aafbf'][min-width~='700']
      .formkit-fields[data-stacked='false']
      .formkit-field,
    .formkit-form[data-uid='cda82aafbf'][min-width~='800']
      .formkit-fields[data-stacked='false']
      .formkit-field,
    .formkit-form[data-uid='cda82aafbf'][min-width~='700']
      .formkit-fields[data-stacked='false']
      .formkit-submit,
    .formkit-form[data-uid='cda82aafbf'][min-width~='800']
      .formkit-fields[data-stacked='false']
      .formkit-submit {
      margin: 0 5px 15px 5px;
    }
    .formkit-form[data-uid='cda82aafbf'][min-width~='700']
      .formkit-fields[data-stacked='false']
      .formkit-field,
    .formkit-form[data-uid='cda82aafbf'][min-width~='800']
      .formkit-fields[data-stacked='false']
      .formkit-field {
      -webkit-flex: 100 1 auto;
      -ms-flex: 100 1 auto;
      flex: 100 1 auto;
    }
    .formkit-form[data-uid='cda82aafbf'][min-width~='700']
      .formkit-fields[data-stacked='false']
      .formkit-submit,
    .formkit-form[data-uid='cda82aafbf'][min-width~='800']
      .formkit-fields[data-stacked='false']
      .formkit-submit {
      -webkit-flex: 1 1 auto;
      -ms-flex: 1 1 auto;
      flex: 1 1 auto;
    }
  </style>
    <input type="hidden" name="tags[]" value="733963" />
  <input type="hidden" aria-label="URL" name="fields[url]" placeholder="URL" value="https://rossta.net/blog/2018-07-07-building-a-pdf-viewer-with-vue-part-2.html" />
</form>


    </section>
    <article>
    </article>
    <section class="margin-bottom double">
      <p>
          Part of the <a href="/blog/series/pdf-viewer.html">PDF Viewer</a> series.
        Published on Jul  7, 2018
      </p>
    </section>
  </section>

      </section>
    </div>
    
    <footer>
  <div class="row">
    <img src="/assets/images/turtle-logo.svg" class="turtle" alt="Turtle logo" />
    <section class="large-6 columns">
      <h5>Most Popular</h5>
      <ul>
          <li><a href="/blog/building-a-pdf-viewer-with-vue-part-1.html">Rendering PDF pages with PDF.js and Vue</a></li>
          <li><a href="/blog/local-ssl-for-rails-5.html">Local SSL for Rails 5 development and tests</a></li>
          <li><a href="/blog/from-sprockets-to-webpack.html">How we switched from Sprockets to Webpack</a></li>
          <li><a href="/blog/web-push-notifications-from-rails.html">Sending Web Push Notifications from Rails</a></li>
          <li><a href="/blog/how-to-specify-local-ruby-gems-in-your-gemfile.html">How to specify local Ruby gems in your Gemfile</a></li>
      </ul>
    </section>
    <section class="large-3 columns">
      <h5>Categories</h5>
      <ul>
          <li><a href="/blog/tags/ruby.html">Ruby</a></li>
          <li><a href="/blog/tags/rails.html">Rails</a></li>
          <li><a href="/blog/tags/javascript.html">JavaScript</a></li>
          <li><a href="/blog/tags/vue.html">Vue</a></li>
          <li><a href="/blog/tags/service-worker.html">Service Worker</a></li>
      </ul>
    </section>
    <section class="large-3 columns">
      <h5>Contact</h5>
      <ul>
        <li><a href="mailto:ross@rossta.net" rel="me noopener">email</a></li>
        <li><a href="https://twitter.com/rossta" rel="me noopener">twitter</a></li>
        <li><a href="https://medium.com/@rossta" rel="me noopener">medium</a></li>
        <li><a href="https://github.com/rossta" rel="me noopener">github</a></li>
        <!-- <li><a href="https://stackoverflow.com/users/771838/rossta?tab=profile" rel="me">stackoverflow</a></li> -->
        <li><a href="https://www.linkedin.com/in/rosskaffenberger" rel="me noopener">linkedin</a></li>
      </ul>
    </section>
  </div>
  <p class="copyright small subtle center">
    © 2019 Ross Kaffenberger. All rights reserved.
  </p>
</footer>

    <script src='/assets/js/runtime.269cddb94bf0453a0b81.js'></script><script src='/assets/js/vendors~app.chunk.744433b6240167794468.js'></script><script src='/assets/js/app.chunk.434a3f09ce036d4718fa.js'></script>
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-16458563-2"></script>
<script type="text/javascript">
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-16458563-2');
</script>

  </body>
</html>
