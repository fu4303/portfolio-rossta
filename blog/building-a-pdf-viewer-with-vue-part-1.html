<!doctype html>
<html>
  <head>
    <title>Building a PDF Viewer with Vue (Part 1) - rossta.net</title>
<meta name="description" content="This tutorial demonstrates how to create Vue.js components that can render PDFs along with tools like Webpack, PDF.js, and the canvas element." />
<meta name="keywords" content="Vue, Webpack" />
<meta name="site" content="rossta.net" />
<meta property="og:site_name" content="rossta.net" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:creator" content="Ross Kaffenberger" />
<meta name="twitter:description" content="This tutorial demonstrates how to create Vue.js components that can render PDFs along with tools like Webpack, PDF.js, and the canvas element." />
<meta name="twitter:image:src" content="https://rossta.net/assets/images/blog/stock/rafaela-biazi-typewriter-unsplash-a36fee2e.jpg" />
<meta name="twitter:title" content="Building a PDF Viewer with Vue (Part 1)" />
<meta property="og:description" content="This tutorial demonstrates how to create Vue.js components that can render PDFs along with tools like Webpack, PDF.js, and the canvas element." />
<meta property="og:image" content="https://rossta.net/assets/images/blog/stock/rafaela-biazi-typewriter-unsplash-a36fee2e.jpg" />
<meta property="og:title" content="Building a PDF Viewer with Vue (Part 1)" />
    <meta charset="utf-8" />
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="mobile-web-app-capable" content="yes">

    <link rel="manifest" href="/manifest.json" />
    <link rel="apple-touch-icon"                      href="/apple-touch-icon.png" />
    <link rel="icon"                                  href="/touch-icon-192x192.png" />
    <link rel="icon" type="image/png" sizes="192x192" href="/touch-icon-192x192.png" />
    <link rel="icon" type="image/png" sizes="144x144" href="/touch-icon-144x144.png" />
    <link rel="icon" type="image/png" sizes="96x96"   href="/touch-icon-96x96.png" />
    <link rel="icon" type="image/png" sizes="72x72"   href="/touch-icon-72x72.png" />
    <link rel="icon" type="image/png" sizes="32x32"   href="/touch-icon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16"   href="/touch-icon-16x16.png">

    <link rel="mask-icon" href="/safari-pinned-tab-5cdca7ae.svg" color="#5bbad5">
    <meta name="theme-color" content="#ffffff">

    <link rel="pingback" href="https://webmention.io/rossta.net/xmlrpc" />
    <link rel="webmention" href="https://webmention.io/rossta.net/webmention" />

    <script type="text/javascript" src="//use.typekit.net/ned0mml.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
    <link href="/assets/stylesheets/app.bundle-3f3ff3db.css" rel="stylesheet" />
  </head>
  <body id="application" class="typekit">
    <nav id="welcome-nav" class="top-bar" data-topbar>
  <ul class="title-area">
    <li class="name">
      <h1><a class="logo" href="/"><img src="/assets/images/turtle-logo-096698b6.svg" alt="Turtle logo" /><span>rossta.net</span></a></h1>
    </li>
    <li class="toggle-topbar menu-icon"><a href="#">Menu</a></li>
  </ul>

  <section class="top-bar-section">
    <ul class="left">
      <li class="nav"><a href="/blog">blog</a></li>
      <li class="nav"><a href="/series">series</a></li>
      <li class="nav"><a href="/talks">talks</a></li>
      <li class="nav"><a href="/projects">projects</a></li>
      <li class="nav"><a href="/about">about</a></li>
      <li class="nav"><a href="/feed.xml">feed</a></li>
    </ul>
  </section>
</nav>

    <div class="row">
      <section id="main" role="main" class="large-12 small-12 columns">
          <section id="blog" class="margin-bottom double">
    <article class="post margin-bottom double">
      <header class="page-header with-summary">
  <h1>
    Building a PDF Viewer with Vue (Part 1)
  </h1>
    <h3>
      A look at rendering PDF pages in HTML with PDF.js and Vue
    </h3>
</header>

        <figure>
          <img src="/assets/images/blog/stock/rafaela-biazi-typewriter-unsplash-a36fee2e.jpg" alt="Rafaela biazi typewriter unsplash" />
            <figcaption>Photo by Rafaela Biazi on Unsplash</figcaption>
        </figure>
      <p>I remember a time not too long ago when the possibility of rendering PDFs inline on a web page would have sounded crazy. Then <a href="https://mozilla.github.io/pdf.js/">PDF.js</a> came along and changed all that.</p>

<p>I was recently tasked with just this sort of project and I leveraged PDF.js, <a href="https://vuejs.org/">Vue</a> and <a href="https://webpack.js.org">Webpack</a> to put it all together. This post is the first in a series which will demonstrate how I used Vue to render PDF pages to <code>&lt;canvas&gt;</code> elements. Later we&#39;ll explore conditional rendering and adding paging and zoom controls.</p>

<p>Here&#39;s a <a href="https://rossta.net/vue-pdfjs-demo/">project demo</a>.</p>

<p><a href="https://rossta.net/vue-pdfjs-demo/"><img src="/assets/images/screenshots/screenshot-pdf-viewer-61e237fc.png" alt="Screenshot pdf viewer" /></a></p>

      <h3 id="similar-projects" class="title">
        <a name="similar-projects" class="anchor" href="#similar-projects">       <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16">
       <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
       </svg>
</a>
        Similar projects
      </h3>
    
<p>Mozilla&#39;s PDF.js package ships with its own web viewer (<a href="https://mozilla.github.io/pdf.js/web/viewer.html">demo</a>) For an alternative approach to PDF rendering in Vue, check out the <a href="https://github.com/FranckFreiburger/vue-pdf">vue-pdf</a> package.</p>

      <h3 id="an-incomplete-intro-to-pdf-js" class="title">
        <a name="an-incomplete-intro-to-pdf-js" class="anchor" href="#an-incomplete-intro-to-pdf-js">       <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16">
       <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
       </svg>
</a>
        An incomplete intro to PDF.js
      </h3>
    
<p>PDF.js is a JavaScript project by Mozilla that makes it easier to parse and render PDFs in HTML. It is comprised of three key pieces: Core, Display, and Viewer.</p>

<p>The Core layer is the lower level piece that parses and interprets PDFs for use by the other layers. This code is split out into a separate file, <code>pdf.worker.js</code>, which will run in its own web worker thread in the browser. Since we&#39;re using Webpack, it will handle bundling, fetching, and configuration of the worker script behind the scenes.</p>

<p>The Viewer layer, as I mentioned earlier, provides a basic user interface for viewing and paging through PDFs in Firefox (or other browsers with included extensions). We won&#39;t be using this piece; in fact, this tutorial could be used as the basis for a Vue.js implementation of alternative viewer.</p>

<p>Most of our interaction with the PDF.js library will be at the Display layer, which provides the JavaScript API for retrieving and manipulating PDF document and page data. The API relies heavily on Promises, which we&#39;ll be incorporating into our Vue.js components. We&#39;ll also take advantage of dynamic imports to code split our use of PDF.js, since, at least for my purposes, I only want to load the PDF.js library on demand. Keeping it out of the main application Webpack bundle will help keep the initial page load time small.</p>

      <h3 id="using-pdf-js" class="title">
        <a name="using-pdf-js" class="anchor" href="#using-pdf-js">       <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16">
       <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
       </svg>
</a>
        Using PDF.js
      </h3>
    
<p>Here&#39;s a basic ES6 example of dynamically loading PDF.js to render an entire PDF document (without Vue):</p>

<pre><code class="javascript">import range from &#39;lodash/range&#39;

import(&#39;pdfjs-dist/webpack&#39;).then(pdfjs =&gt; {
  pdfjs
    .getDocument(&#39;wibble.pdf&#39;)
    .then(pdf =&gt; {
      const pagePromises = range(1, pdf.numPages).map(number =&gt; pdf.getPage(number))
      return Promise.all(pagePromises)
    })
    .then(pages =&gt; {
        const scale = 2

        const canvases = pages.forEach(page =&gt; {
          const viewport = page.getViewport(scale)

          // Prepare canvas using PDF page dimensions
          const canvas = document.createElement(&#39;canvas&#39;)
          canvas.height = viewport.height
          canvas.width = viewport.width

          // Render PDF page into canvas context
          const canvasContext = canvas.getContext(&#39;2d&#39;)
          const renderContext = { canvasContext, viewport }
          page.render(renderContext).then(() =&gt; console.log(&#39;Page rendered&#39;))

          document.body.appendChild(canvas)
        })
      },
      error =&gt; console.log(&#39;Error&#39;, error),
    )
})
</code></pre>

<p>The code above dynamically imports the PDF.js distribution with <code>import(&#39;pdfjs/dist&#39;)</code>. Webpack will split the PDF.js code out into its own bundle and load it asynchronously only when that line is executed in the browser. This expression returns a promise that resolves with the PDF.js module when the bundle is successfully loaded and evaluated. With a reference to the modules, <code>pdfjs</code> we can now exercise the PDF.js document API.</p>

<p>The expression <code>pdjs.getDocument(&#39;url-to-pdf&#39;)</code> also returns a promise which resolves when the the document is loaded and parsed by the PDF.js core layer. This promise resolves to an instance of <a href="https://mozilla.github.io/pdf.js/api/draft/PDFDocumentProxy.html"><code>PDFDocumentProxy</code></a>, which we can use to retrieve additional data from the PDF document. We used the <code>PDFDocumentProxy#numPages</code> attribute to build a number range of all the pages (using lodash <code>range</code>) and build an array of promises representing requests for each of the documents pages returned by <code>PDFDocumentProxy#getPage(pageNumber)</code>. The key here to loading all pages at once is using <code>Promise.all</code> to resolve when all pages are retrieved as <a href="https://mozilla.github.io/pdf.js/api/draft/PDFPageProxy.html">PDFPageProxy</a> objects.</p>

<p>Finally, for each page object, we create a separate <code>canvas</code> element and trigger the <code>PDFPageProxy#render</code> method, which returns another promise and accepts options for a canvas context and viewport. This render method is responsible for drawing the PDF data into the canvas element asynchronously while we append the canvas elements to <code>document.body</code>.</p>

      <h3 id="refactoring-to-vue" class="title">
        <a name="refactoring-to-vue" class="anchor" href="#refactoring-to-vue">       <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16">
       <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
       </svg>
</a>
        Refactoring to Vue
      </h3>
    
<p>Our little script works, and for some applications, this may implementaiton may be sufficient. But let&#39;s say we need some interaction, like paging controls, zoom buttons, conditional page fetching and rendering while scrolling, etc. Adding complexity could get unwieldy quickly. For this next stage, we&#39;ll refactor to Vue components, so we can get the benefit of reactivity and make our code more declarative and easier to extend.</p>

<p>In pseudocode, our component architecture will resemble this:</p>

<pre><code class="html">&lt;PDFDocument&gt;
  &lt;PDFPage :number=&quot;1&quot; /&gt;
  &lt;PDFPage :number=&quot;2&quot; /&gt;
  &lt;PDFPage :number=&quot;3&quot; /&gt;
  ...
&lt;/PDFDocument&gt;
</code></pre>

      <h3 id="requirements" class="title">
        <a name="requirements" class="anchor" href="#requirements">       <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16">
       <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
       </svg>
</a>
        Requirements
      </h3>
    
<p>For my project, I used the following npm packages (installed using <code>yarn</code>).</p>

<ul>
<li><code>@vue/cli</code>: <code>^3.0.0-beta.15</code></li>
<li><code>vue</code>: <code>^2.5.16</code></li>
<li><code>pdfjs-dist</code>: <code>^2.0.489</code></li>
</ul>

<p>I would expect it to be straightforward to adapt the code for other relatively recent versions of these packages.</p>

<aside class="callout panel"><p>
Since PDF.js will request data via an XMLHTTPRequest in JavaScript, typical crossdomain restrictions apply. For the purposes of this tutorial, we'll assume we have a URL to a PDF that can be retrieved either from our development server or from a server that allows Cross-Origin Resource Sharing (CORS) from our host.
</p></aside>

      <h3 id="fetching-the-pdf" class="title">
        <a name="fetching-the-pdf" class="anchor" href="#fetching-the-pdf">       <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16">
       <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
       </svg>
</a>
        Fetching the PDF
      </h3>
    
<p>Our <code>&lt;App&gt;</code> component will hard-code default values for a PDF url and a rendering scale which will be passed to a <code>&lt;PDFDocument&gt;</code> component.</p>

<pre><code class="html">&lt;!-- src/App.vue --&gt;

&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;PDFDocument v-bind=&quot;{url, scale}&quot; /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  // ...
  data() {
    return {
      url: &#39;https://cdn.filestackcontent.com/5qOCEpKzQldoRsVatUPS&#39;, // a PDF
      scale: 2,
    }
  },
}
&lt;/script&gt;
</code></pre>

<p>The document component is responsible for fetching the PDF data through PDF.js and rendering  a <code>&lt;PDFPage&gt;</code> component for each <code>page</code> object returned by the API.</p>

<p>Its <code>data</code> will track the <code>pdf</code> object and a list of <code>page</code> object in <code>pages</code>.</p>

<pre><code class="javascript">// src/components/PDFDocument.vue

export default {
  props: [&#39;url&#39;, &#39;scale&#39;],

  data() {
    return {
      pdf: undefined,
      pages: [],
    };
  },
  // ...
</code></pre>

<p>When the component is mounted, it will fetch the PDF data using the <code>pdfjs.getDocument</code> function.</p>

<pre><code class="javascript">// src/components/PDFDocument.vue

export default {
  //...

  created() {
    this.fetchPDF();
  },

  methods: {
    fetchPDF() {
      import(&#39;pdfjs-dist/webpack&#39;).
        then(pdfjs =&gt; pdfjs.getDocument(this.url)).
        then(pdf =&gt; (this.pdf = pdf)).
        then(() =&gt; log(&#39;pdf fetched&#39;));
    },
  },
  //...
</code></pre>

<p>We&#39;ll use a watch callback for the <code>pdf</code> attribute to fetch all the pages via the <code>pdf.getPage</code> function provided by PDF.js. Since the return value of <code>getPage</code> behaves like a promise, we can use <code>Promise.all</code> to determine when all the <code>page</code> objects have been fetched and set the resolved collection as the <code>pages</code> data:</p>

<pre><code class="javascript">// src/components/PDFDocument.vue

import range from &#39;lodash/range&#39;;

export default {
  // ...
  watch: {
    pdf(pdf) {
      this.pages = [];
      const promises = range(1, pdf.numPages).
        map(number =&gt; pdf.getPage(number));

      Promise.all(promises).
        then(pages =&gt; (this.pages = pages)).
        then(() =&gt; log(&#39;pages fetched&#39;));
    },
  },
};
</code></pre>

<p>The template simply renders a <code>&lt;PDFPage&gt;</code> child component for each <code>page</code> object. Each page component also needs the <code>scale</code> prop for rendering the page data to <code>&lt;canvas&gt;</code>:</p>

<pre><code class="html">&lt;!-- src/components/PDFDocument.vue --&gt;

&lt;template&gt;
  &lt;div class=&quot;pdf-document&quot;&gt;
    &lt;PDFPage
      v-for=&quot;page in pages&quot;
      v-bind=&quot;{page, scale}&quot;
      :key=&quot;page.pageNumber&quot;
    /&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>

      <h3 id="setting-up-the-canvas" class="title">
        <a name="setting-up-the-canvas" class="anchor" href="#setting-up-the-canvas">       <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16">
       <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
       </svg>
</a>
        Setting up the canvas
      </h3>
    
<p>Now we can build out the <code>&lt;PDFPage&gt;</code> element. We&#39;ll simply will use a Vue <code>render</code> function to create a <code>&lt;canvas&gt;</code> element with computed attributes, <code>canvasAttrs</code>.</p>

<pre><code class="javascript">// src/components/PDFPage.vue

export default {
  props: [&#39;page&#39;, &#39;scale&#39;],

  render(h) {
    const {canvasAttrs: attrs} = this;
    return h(&#39;canvas&#39;, {attrs});
  },

  // ...
</code></pre>

<p>To render a PDF to <code>&lt;canvas&gt;</code> with an acceptable resolution, we can take advantage of a browser property called <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio"><code>window.devicePixelRatio</code></a>. This value represents the ratio of screen pixels to CSS pixels. Given a hi-resolution display with a <code>devicePixelRatio</code> of <code>2</code>, we&#39;d want to give the canvas initial width and height attributes that are two times greater than its corresponding width and height in CSS. Otherwise, rendering our PDF pixels to canvas may appear blurry.</p>

<p>When the <code>&lt;PDFPage&gt;</code> component is created, we can access the <code>viewport</code> property of the <code>page</code> object, via <code>PDFPageProxy#getViewport</code>, to obtain the pixel width and height of the PDF. These are the width and height attributes of the <code>&lt;canvas&gt;</code> element. For the actual size of the <code>&lt;canvas&gt;</code>, we&#39;ll use CSS attributes.</p>

<p>Since the <code>scale</code> prop is reactive and our <code>render</code> function depends on <code>canvasAttrs</code>, defining <code>canvasAttrs</code> as a computed property based off the scale means our PDF pages will automatically re-render when the scale changes. Future iterations will allow to the change <code>scale</code> prop (using future zoom controls, for example). We&#39;ll simply calculate the width and height via CSS to update the rendered size of the canvas to avoid redrawing the canvas data from the <code>page</code> object each time. For this, we use a clone of the original viewport, given via the <code>actualSizeViewport</code> computed property, and the <code>devicePixelRatio</code> to calculate the target width and height style attributes for the <code>&lt;canvas&gt;</code>.</p>

<p>Here&#39;s the code that puts all that together:</p>

<pre><code class="javascript">// src/components/PDFPage.vue

export default {
  created() {
    // PDFPageProxy#getViewport
    // https://mozilla.github.io/pdf.js/api/draft/PDFPageProxy.html
    this.viewport = this.page.getViewport(this.scale);
  },

  computed: {
    canvasAttrs() {
      let {width, height} = this.viewport;
      [width, height] = [width, height].map(dim =&gt; Math.ceil(dim));

      const style = this.canvasStyle;

      return {
        width,
        height,
        style,
        class: &#39;pdf-page&#39;,
      };
    },

    canvasStyle() {
      const {width: actualSizeWidth, height: actualSizeHeight} = this.actualSizeViewport;
      const pixelRatio = window.devicePixelRatio || 1;
      const [pixelWidth, pixelHeight] = [actualSizeWidth, actualSizeHeight]
        .map(dim =&gt; Math.ceil(dim / pixelRatio));
      return `width: ${pixelWidth}px; height: ${pixelHeight}px;`
    },

    actualSizeViewport() {
      return this.viewport.clone({scale: this.scale});
    },
    //...
  },

  // ...
</code></pre>

      <h3 id="rendering-the-page" class="title">
        <a name="rendering-the-page" class="anchor" href="#rendering-the-page">       <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16">
       <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
       </svg>
</a>
        Rendering the page
      </h3>
    
<p>When the <code>&lt;canvas&gt;</code> element mounts, we can draw the PDF page data to it using the <code>PDFPageProxy#render</code> method. It needs context from the <code>viewport</code> and <code>canvasContext</code> as arguments. Since that returns a promise, we can be notified when it&#39;s complete.</p>

<pre><code class="javascript">// src/components/PDFPage.vue

export default {
  mounted() {
    this.drawPage();
  },

  methods: {
    drawPage() {
      if (this.renderTask) return;

      const {viewport} = this;
      const canvasContext = this.$el.getContext(&#39;2d&#39;);
      const renderContext = {canvasContext, viewport};

      // PDFPageProxy#render
      // https://mozilla.github.io/pdf.js/api/draft/PDFPageProxy.html
      this.renderTask = this.page.render(renderContext);
      this.renderTask.
        then(() =&gt; this.$emit(&#39;rendered&#39;, this.page)).
        then(() =&gt; log(`Page ${this.pageNumber} rendered`));
    },
    // ...
  },
  // ...
</code></pre>

      <h3 id="cleaning-up-after-ourselves" class="title">
        <a name="cleaning-up-after-ourselves" class="anchor" href="#cleaning-up-after-ourselves">       <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16">
       <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
       </svg>
</a>
        Cleaning up after ourselves
      </h3>
    
<p>As we&#39;re working with JavaScript objects that keep state outside of Vue&#39;s control, we should be mindful to call provided teardown methods. The PDF document and page objects provide <code>destroy</code> methods to be called on teardown, such as, when our render promise fails, the <code>page</code> object is replaced, or the Vue component itself is destroyed.</p>

<pre><code class="javascript">// src/components/PDFPage.vue

export default {
  beforeDestroy() {
    this.destroyPage(this.page);
  },

  methods: {
    drawPage() {
      // ...
      this.renderTask.
        then(/* */).
        catch(this.destroyRenderTask);
    },

    destroyPage(page) {
      if (!page) return;

      // PDFPageProxy#_destroy
      // https://mozilla.github.io/pdf.js/api/draft/PDFPageProxy.html
      page._destroy();

      // RenderTask#cancel
      // https://mozilla.github.io/pdf.js/api/draft/RenderTask.html
      if (this.renderTask) this.renderTask.cancel();
    },

    destroyRenderTask() {
      if (!this.renderTask) return;

      // RenderTask#cancel
      // https://mozilla.github.io/pdf.js/api/draft/RenderTask.html
      this.renderTask.cancel();
      delete this.renderTask;
    },
  },

  watch: {
    page(page, oldPage) {
      this.destroyPage(oldPage);
    },
  },
};
</code></pre>

      <h3 id="wrapping-up" class="title">
        <a name="wrapping-up" class="anchor" href="#wrapping-up">       <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16">
       <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
       </svg>
</a>
        Wrapping up
      </h3>
    
<p>We&#39;ve now converted our original, imperative PDF rendering script with a declarative Vue component hierarchy. We&#39;ve certainly added a lot of code to make this work, but with working knowledge of Vue, we&#39;ve made it easier to reason about, easier to extend, and easier to add features to give our PDF viewer more functionality.</p>

<p>In the next post, we&#39;ll look at adding some conditional rendering; since all pages aren&#39;t visible when the document is initially loaded, Vue can help us design a system that only fetches and renders PDF pages when scrolled into view.</p>

    </article>
    <section class="margin-bottom double">
      <a href="https://twitter.com/intent/tweet?text=Building%20a%20PDF%20Viewer%20with%20Vue%20%28Part%201%29&amp;url=https%3A%2F%2Frossta.net%2Fblog%2Fbuilding-a-pdf-viewer-with-vue-part-1.html" class="button" target="_blank" rel="noopener">Share this post on Twitter</a>
    </section>
    <section class="signup-form-standalone margin-bottom quadruple">
      <!-- Begin MailChimp Signup Form -->
<div class="signup-form">
  <h3>Did you like this post?</h3>
  <p>Stay in the LOOP! Leave your email and I'll send you an occasional email on Ruby, Javascript, or Elixir for the web.</p>
  <div id="mc_embed_signup">
    <form action="//rossta.us6.list-manage.com/subscribe/post?id=96030b0bda&u=8ce159842b5c98cecb4ebdf16" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
      <div id="mc_embed_signup_scroll">

        <div class="row">
          <div class="large-10 columns">
            <div class="row collapse">
              <div class="large-8 small-7 columns">
                <input type="email" placeholder="Your email..." value="" name="EMAIL" class="required email" id="mce-EMAIL">
              </div>
              <div class="large-4 small-5 columns">
                <input type="submit" value="Sign me up!" name="subscribe" id="mc-embedded-subscribe" class="button postfix">
              </div>
            </div>
          </div>
        </div>

        <div id="mce-responses" class="clear">
          <div class="response" id="mce-error-response" style="display:none"></div>
          <div class="response" id="mce-success-response" style="display:none"></div>
        </div>
        <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
        <div style="position: absolute; left: -5000px;"><input type="text" name="b_8ce159842b5c98cecb4ebdf16_96030b0bda" tabindex="-1" value=""></div>
      </div>

      <input type="hidden" name="SIGNUP" value="https://rossta.net/blog/2018-06-11-building-a-pdf-viewer-with-vue-part-1.html" />
      <input type="hidden" name="SIGNUP_APP" value="Mailchimp" />
      <input type="hidden" name="SIGNUP_LOCATION" id="signup_location" value="blog/2018-06-11-building-a-pdf-viewer-with-vue-part-1.html" />
      <input type="hidden" name="SIGNUP_TAGS" id="signup_tags" value="Vue,Webpack" />
    </form>
  </div>
  <!--End mc_embed_signup-->
</div>

    </section>
    <section class="margin-bottom double">
      <p>
          Part of the <a href="/blog/series/pdf-viewer.html">PDF Viewer</a> series.
        Published on Jun 11, 2018
      </p>
    </section>
  </section>
    <hr />
    <section class="comments">
      <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname  = "rosskaff";
    var disqus_identifier = "building-a-pdf-viewer-with-vue-part-1";
    var disqus_title      = "Building a PDF Viewer with Vue (Part 1)";
    var disqus_url        = "https://rossta.net/blog/building-a-pdf-viewer-with-vue-part-1.html";

    var disqus_config = function () {
        this.page.url = disqus_url;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = disqus_identifier; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        this.page.title = disqus_title;
    };

    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = '//rosskaff.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>

<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

<!-- <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a> -->

    </section>

      </section>
    </div>
    
    <footer>
  <div class="row">
    <img src="/assets/images/turtle-logo-096698b6.svg" class="turtle" alt="Turtle logo" />
    <section class="large-6 columns">
      <h5>Most Popular</h5>
      <ul>
          <li><a href="/blog/web-push-notifications-from-rails.html">Sending Web Push Notifications from Rails</a></li>
          <li><a href="/blog/n-1-is-a-rails-feature.html">N+1 is a Rails feature</a></li>
          <li><a href="/blog/what-i-learned-about-hanami.html">What I learned building an app in Hanami</a></li>
          <li><a href="/blog/how-to-specify-local-ruby-gems-in-your-gemfile.html">How to specify local Ruby gems in your Gemfile</a></li>
          <li><a href="/blog/service-worker-on-rails.html">Service Worker on Rails</a></li>
      </ul>
    </section>
    <section class="large-3 columns">
      <h5>Categories</h5>
      <ul>
          <li><a href="/blog/tags/ruby.html">Ruby</a></li>
          <li><a href="/blog/tags/javascript.html">JavaScript</a></li>
          <li><a href="/blog/tags/rails.html">Rails</a></li>
          <li><a href="/blog/tags/vue.html">Vue</a></li>
          <li><a href="/blog/tags/service-worker.html">Service Worker</a></li>
      </ul>
    </section>
    <section class="large-3 columns">
      <h5>Contact</h5>
      <ul>
        <li><a href="mailto:ross@rossta.net" rel="me noopener">email</a></li>
        <li><a href="https://twitter.com/rossta" rel="me noopener">twitter</a></li>
        <li><a href="https://medium.com/@rossta" rel="me noopener">medium</a></li>
        <li><a href="https://github.com/rossta" rel="me noopener">github</a></li>
        <!-- <li><a href="https://stackoverflow.com/users/771838/rossta?tab=profile" rel="me">stackoverflow</a></li> -->
        <li><a href="https://www.linkedin.com/in/rosskaffenberger" rel="me noopener">linkedin</a></li>
      </ul>
    </section>
  </div>
  <p class="copyright small subtle center">
    © 2018 Ross Kaffenberger. All rights reserved.
  </p>
</footer>

    <script src="/assets/javascripts/runtime.bundle-2352c808.js"></script><script src="/assets/javascripts/vendor.bundle-0116f3b0.js"></script><script src="/assets/javascripts/app.bundle-ed1e4144.js"></script>
    
    <script type="text/javascript">
!function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","page","once","off","on"];analytics.factory=function(t){return function(){var e=Array.prototype.slice.call(arguments);e.unshift(t);analytics.push(e);return analytics}};for(var t=0;t<analytics.methods.length;t++){var e=analytics.methods[t];analytics[e]=analytics.factory(e)}analytics.load=function(t){var e=document.createElement("script");e.type="text/javascript";e.async=!0;e.src=("https:"===document.location.protocol?"https://":"http://")+"cdn.segment.com/analytics.js/v1/"+t+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(e,n)};analytics.SNIPPET_VERSION="3.1.0";
analytics.load("NdBtrprkAGAjQryMShljRdVf90saElAU");
analytics.page()
window.$.tracking.flush(analytics);
}}();
</script>

  </body>
</html>
