<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rossta.net</title>
  <subtitle>Ross Kaffenberger</subtitle>
  <id>https://rossta.net/</id>
  <link href="https://rossta.net/"/>
  <link href="https://rossta.net/feed.xml" rel="self"/>
  <updated>2016-08-26T00:00:00+00:00</updated>
  <author>
    <name>Ross Kaffenberger</name>
  </author>
  <entry>
    <title>Quiet assets in Rails 5</title>
    <link rel="alternate" href="/blog/quiet-assets-in-rails-5.html"/>
    <id>/blog/quiet-assets-in-rails-5.html</id>
    <published>2016-08-26T00:00:00+00:00</published>
    <updated>2016-08-26T00:00:00+00:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;Recent changes to the &lt;a href="https://github.com/rails/sprockets-rails"&gt;&lt;code&gt;sprockets-rails&lt;/code&gt;&lt;/a&gt; gem now include a configuration option
to silence asset request logging in development.&lt;/p&gt;

&lt;h3&gt;The problem&lt;/h3&gt;

&lt;p&gt;I love logs. Whenever someone comes to me with a Rails problem or we need to
debug something, the first question...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Recent changes to the &lt;a href="https://github.com/rails/sprockets-rails"&gt;&lt;code&gt;sprockets-rails&lt;/code&gt;&lt;/a&gt; gem now include a configuration option
to silence asset request logging in development.&lt;/p&gt;

&lt;h3&gt;The problem&lt;/h3&gt;

&lt;p&gt;I love logs. Whenever someone comes to me with a Rails problem or we need to
debug something, the first question I&amp;rsquo;m thinking is, &amp;ldquo;What do the logs say?&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;That said, sometimes Rails logs more info than we need. By default, Rails will record the web requests for each asset in development. Each page load could incur several to many additional requests for JavaScript, CSS, and images, potentially drowning your &lt;code&gt;STDOUT&lt;/code&gt; or &lt;code&gt;development.log&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As &lt;a href="https://eliotsykes.com/quiet-assets"&gt;this great article on Rails debugging with quiet logs points out&lt;/a&gt;, your log may get filled with lines like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;Started GET &amp;quot;/assets/jquery.abcde.js?body=1&amp;quot; for 127.0.0.1 at 2016-08-27 18:38:00 -0400
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unless you&amp;rsquo;re debugging an issue in the asset pipeline, numerous asset requests are not very useful and tend to mask more important info logged in the controller actions.&lt;/p&gt;

&lt;h3&gt;Quieting assets, the old way&lt;/h3&gt;

&lt;p&gt;To disable asset logging behavior, many Rails 4 projects have used the &lt;code&gt;quiet_assets&lt;/code&gt; gem.&lt;/p&gt;

&lt;p&gt;So, why did we need a separate gem in the first place?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Rails::Rack::Logger&lt;/code&gt; is a middleware in the Rails middleware stack that logs all requests coming into your Rails app and implements an &lt;code&gt;ActiveSupport::Notification&lt;/code&gt; for each request you can hook into for additional information. The &lt;code&gt;quiet_assets&lt;/code&gt; gem simply sets the log level to &lt;code&gt;Logger::Error&lt;/code&gt; for any request matching your application&amp;rsquo;s assets path prefix, which means it won&amp;rsquo;t show up in your log file or &lt;code&gt;STDOUT&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;quiet_assets&lt;/code&gt; gem &lt;a href="https://github.com/evrone/quiet_assets/blob/e54ca548f005ca2a93e781c7b583ff4d0b59dd35/lib/quiet_assets.rb#L20"&gt;monkeypatches &lt;code&gt;Rails::Rack::Logger&lt;/code&gt;&lt;/a&gt; to accomplish this. Here&amp;rsquo;s the relevant code provided in the gem:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;Rails::Rack::Logger.class_eval do
  def call_with_quiet_assets(env)
    begin
      if env[&amp;#39;PATH_INFO&amp;#39;] =~ ASSETS_REGEX
        env[KEY] = Rails.logger.level
        Rails.logger.level = Logger::ERROR       # set the log level to silence
      end
      call_without_quiet_assets(env)
    ensure
      Rails.logger.level = env[KEY] if env[KEY]  # resets the previous log level
    end
  end
  alias_method_chain :call, :quiet_assets
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While useful, it would be preferable to avoid monkeypatching the Rails logging
middleware and remove the &lt;code&gt;quiet_assets&lt;/code&gt; dependency if &lt;code&gt;sprockets-rails&lt;/code&gt; could
handle this for us.&lt;/p&gt;

&lt;h3&gt;Replacing the quiet_assets gem&lt;/h3&gt;

&lt;p&gt;Now, as of the most recent version of &lt;code&gt;sprockets-rails&lt;/code&gt; (at the time of this writing, version &lt;code&gt;3.1.1&lt;/code&gt;) provides the ability to silence assets requests. This means the &lt;code&gt;quiet_assets&lt;/code&gt; gem is no longer needed in a fresh Rails 5 application.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how to configure your Rails app to silence asset logging with this most
recent version of &lt;code&gt;sprockets-rails&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# config/environments/development.rb

Rails.application.configure do

  config.assets.quiet = true

  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So how does this work? The &lt;code&gt;sprockets-rails&lt;/code&gt; gem now inserts an additional middleware ahead of &lt;code&gt;Rails::Rack::Logger&lt;/code&gt; in the middleware stack:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ bin/rake middleware
# ...
use Sprockets::Rails::QuietAssets
use Rails::Rack::Logger
# ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code&gt;config.assets.quiet&lt;/code&gt; is enabled in development, the &lt;code&gt;Sprockets::Rails::Middleware&lt;/code&gt; also matches on asset requests, but instead uses the &lt;code&gt;Rails.logger.silence { ... }&lt;/code&gt; block method to change the log level to &lt;code&gt;Logger::ERROR&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a &lt;a href="https://github.com/rails/sprockets-rails/pull/355"&gt;link to the recent pull request&lt;/a&gt; if you&amp;rsquo;re interested to take a closer look at how this functionality works. The entire middleware is &lt;a href="https://github.com/rails/sprockets-rails/blob/df5950017d7f2aa6fcbfa3949edfef85c35c28c7/lib/sprockets/rails/quiet_assets.rb"&gt;currently only 18 lines&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;module Sprockets
  module Rails
    class QuietAssets
      def initialize(app)
        @app = app
        @assets_regex = %r(\A/{0,2}#{::Rails.application.config.assets.prefix})
      end

      def call(env)
        if env[&amp;#39;PATH_INFO&amp;#39;] =~ @assets_regex
          ::Rails.logger.silence { @app.call(env) }  # silences the logs!
        else
          @app.call(env)
        end
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, this feature isn&amp;rsquo;t just for Rails 5; it should also be possible for you to upgrade to this version of &lt;code&gt;sprockets-rails&lt;/code&gt; for existing Rails 4 applications.&lt;/p&gt;

&lt;p&gt;In case you&amp;rsquo;re wondering, the &lt;code&gt;Rails.logger.silence { ... }&lt;/code&gt; call assumes your
Rails logger includes the &lt;a href="http://api.rubyonrails.org/classes/LoggerSilence.html"&gt;&lt;code&gt;LoggerSilence&lt;/code&gt; module&lt;/a&gt;, which adds the &lt;code&gt;#silence&lt;/code&gt; method to the including logger class, which will set the log level to &lt;code&gt;Logger::ERROR&lt;/code&gt; for the duration of the block, similar to how the &lt;code&gt;quiet_assets&lt;/code&gt; gem works, but without monkeypatching.&lt;/p&gt;

&lt;h3&gt;Logging to STDOUT&lt;/h3&gt;

&lt;p&gt;You may be surprised then to see asset requests fail if you&amp;rsquo;re using a non-compliant logger. Unfortunately, this includes the &lt;code&gt;Logger&lt;/code&gt; class from the Ruby standard library, which, of course, does not include the &lt;code&gt;LoggerSilence&lt;/code&gt; module. You might be using Ruby&amp;rsquo;s &lt;code&gt;Logger&lt;/code&gt; if you&amp;rsquo;ve followed common recommendations to change your Rails logger to log to &lt;code&gt;STDOUT&lt;/code&gt;, as in &lt;a href="http://blog.bigbinary.com/2016/04/12/rails-5-allows-to-send-log-to-stdout-via-environment-variable.html"&gt;this tutorial&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;config.logger = ActiveSupport::TaggedLogging.new(Logger.new(STDOUT))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I ran into this issue recently when assets were failing to load after I upgraded
to &lt;code&gt;sprockets-rails 3.1.1&lt;/code&gt; and began seeing &lt;code&gt;NoMethodError: undefined method &amp;#39;silence&amp;#39; for #&amp;lt;Logger:...&amp;gt;&lt;/code&gt; in my development logs.&lt;/p&gt;

&lt;p&gt;The fix is simple: to log to &lt;code&gt;STDOUT&lt;/code&gt; and take advantage of the new
&lt;code&gt;Sprockets::Rails::QuietAssets&lt;/code&gt; middleware, you could use &lt;code&gt;ActiveSupport::Logger&lt;/code&gt; instead, which inherits from Ruby &lt;code&gt;Logger&lt;/code&gt; and includes &lt;code&gt;LoggerSilence&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;config.logger = ActiveSupport::TaggedLogging.new(ActiveSupport::Logger.new(STDOUT))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, we could create our own subclass of &lt;code&gt;Logger&lt;/code&gt; with &lt;code&gt;LoggerSilence&lt;/code&gt;
included. If we just want &lt;code&gt;STDOUT&lt;/code&gt; logging, we could instead use Heroku&amp;rsquo;s
&lt;a href="https://github.com/heroku/rails_stdout_logging"&gt;&lt;code&gt;rails_stdout_logging&lt;/code&gt;&lt;/a&gt; gem,
which will also try to include the &lt;code&gt;LoggerSilence&lt;/code&gt; module in our logger, if available.&lt;/p&gt;

&lt;h3&gt;Resources&lt;/h3&gt;

&lt;p&gt;Be sure to check out the following links if you&amp;rsquo;re interested to learn more
about customizing your Rails logger. Happy logging!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://hawkins.io/2013/08/using-the-ruby-logger/"&gt;Using the Ruby Logger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.bigbinary.com/2016/04/12/rails-5-allows-to-send-log-to-stdout-via-environment-variable.html"&gt;Rails 5 allows to send log to STDOUT via environment variable&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ruby-doc.org/stdlib-2.3.0/libdoc/logger/rdoc/Logger.html"&gt;Ruby Logger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://apidock.com/rails/LoggerSilence/silence"&gt;LoggerSilence&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://eliotsykes.com/quiet-assets"&gt;Debug Rails faster with quiet assets &amp;amp; quieter logs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/evrone/quiet_assets"&gt;Quiet Assets gem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/heroku/rails_stdout_logging"&gt;Rails STDOUT logging gem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/rails/sprockets-rails/pull/355"&gt;PR to introduce quiet assets to &lt;code&gt;sprockets-rails&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Sending Web Push Notifications from Rails</title>
    <link rel="alternate" href="/blog/web-push-notifications-from-rails.html"/>
    <id>/blog/web-push-notifications-from-rails.html</id>
    <published>2016-05-13T00:00:00+00:00</published>
    <updated>2016-05-13T00:00:00+00:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;We’ve had push notifications in our mobile and desktop apps for sometime. It’s now becoming possible on the open web.&lt;/p&gt;

&lt;p&gt;Web Push notifications are powerful because they allow you to engage with your users &lt;em&gt;even when they’re not on your site&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;I’m going...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;We&amp;rsquo;ve had push notifications in our mobile and desktop apps for sometime. It&amp;rsquo;s now becoming possible on the open web.&lt;/p&gt;

&lt;p&gt;Web Push notifications are powerful because they allow you to engage with your users &lt;em&gt;even when they&amp;rsquo;re not on your site&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m going to share how to I got a working demo of the new &lt;a href="https://www.w3.org/TR/push-api/"&gt;Web Push API&lt;/a&gt; from a Rails (or any Ruby) web application to push desktop-style notifications through supporting browsers - currently Chrome and Firefox at the time of this writing.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll cover the basics of implementing Push yourself though it&amp;rsquo;s interesting to note that third party services are already stepping in to do some of the technical work for you, like &lt;a href="https://goroost.com/"&gt;Roost&lt;/a&gt;, &lt;a href="https://pushcrew.com/"&gt;PushCrew&lt;/a&gt;, or
&lt;a href="https://onesignal.com/webpush"&gt;OneSignal&lt;/a&gt;.&lt;/p&gt;

&lt;div class="callout panel"&gt;
&lt;p&gt;
  The &lt;a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/ApplePushService.html"&gt;Apple Push Notification Service&lt;/a&gt; has made push notifications available to Safari since 2013. There are some &lt;a href="http://samuli.hakoniemi.net/how-to-implement-safari-push-notifications-on-your-website/"&gt;nice tutorials&lt;/a&gt; for implementing Apple Push on Safari. The status of future support for Web Push in Safari is: &amp;ldquo;maybe?&amp;rdquo;.
&lt;/p&gt;
&lt;/div&gt;

&lt;h2&gt;Why?&lt;/h2&gt;

&lt;p&gt;&amp;ldquo;Yeah, Ross, but Rails 5. Action Cable. Web Sockets. Server Sent Events. &lt;code&gt;$MY_FAVORITE_ALTERNATIVE&lt;/code&gt;!&amp;rdquo;&lt;/p&gt;

&lt;p&gt;You might not want to drop all those alternatives just yet, as &lt;a href="http://caniuse.com/#feat=push-api"&gt;browser support for Web Push&lt;/a&gt; still needs improvement. Web Push could be a good alternative for a subset push features for applications where deploying Rails 5 Action Cable would be overkill. Web push also currently relies on third party web which may or may not be advantage depending on your deployment options.&lt;/p&gt;

&lt;p&gt;But the killer feature of Web Push is that notifications can be displayed even when the user is not on the site, something those other solutions cannot provide.&lt;/p&gt;

&lt;h2&gt;Demo&lt;/h2&gt;

&lt;p&gt;Want to see it in action first?&lt;/p&gt;

&lt;p&gt;I created a demo at the &lt;a href="https://serviceworker-rails.herokuapp.com/push-simple/"&gt;Service Worker Rails
Sandbox&lt;/a&gt; to show how a
simple push message would look like. Try it out in Firefox or Chrome or check
out the &lt;a href="https://github.com/rossta/serviceworker-rails-sandbox"&gt;source code on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://serviceworker-rails.herokuapp.com/push-simple/"&gt;&lt;img src="/assets/images/screenshots/screenshot-sw-sandbox-push-simple-1-2927dd61.png" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;My demo is mostly informed by Mozilla&amp;rsquo;s &lt;a href="https://serviceworke.rs/"&gt;Service Worker
Cookbook&lt;/a&gt;, which I highly recommend if you&amp;rsquo;re looking
to learn more about Service Worker.&lt;/p&gt;

&lt;h2&gt;Bird&amp;rsquo;s eye view&lt;/h2&gt;

&lt;p&gt;Delivering push notifications involve interactions among three parties - the
user (through her browser), your Rails application, and the Web Push server,
which for our purposes is either Google or Firefox.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/blog/push-notification-high-level-9cb4f185.png" /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Diagram courtesy of the &lt;a href="https://wiki.mozilla.org/Firefox/Push_Notifications"&gt;Firefox wiki&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;We&amp;rsquo;ll use JavaScript on the user&amp;rsquo;s current page to &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register"&gt;register a service worker&lt;/a&gt; subscribe to push notifications via the &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/PushManager/subscribe"&gt;&lt;code&gt;pushManager&lt;/code&gt;&lt;/a&gt; interface. The browser will make a request to the Web Push server to a &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription"&gt;&lt;code&gt;PushSubscription&lt;/code&gt;&lt;/a&gt; which will contain a unique endpoint to the Web Push server and authorization keys required for encrypting the push notification request body.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We&amp;rsquo;ll post the subscription info to our Rails app to be persisted on the server side.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;To send a push notification, we&amp;rsquo;ll use the &lt;a href="https://github.com/zaru/webpush"&gt;&lt;code&gt;webpush&lt;/code&gt;&lt;/a&gt; Ruby gem triggered from our Rails app. &lt;code&gt;webpush&lt;/code&gt; is responsible for sending a proper request to the Web Push server, including &lt;a href="https://developers.google.com/web/updates/2016/03/web-push-encryption?hl=en"&gt;encryption of the message payload&lt;/a&gt; for delivery.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If the request is successful, the Web Push server opens a socket to our
registered service worker which can listen for &lt;code&gt;&amp;#39;push&amp;#39;&lt;/code&gt; events to show a
notification to the user. Since service workers have a lifecycle independent of
the web page, they can process events even when the user is not visiting our
website.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Setup&lt;/h2&gt;

&lt;p&gt;At the time of this writing, we&amp;rsquo;ll need to configure our app to use the Google Cloud Messaging platform by registering for application keys. No special authorization is needed to use the Firefox push server as far as I can tell.&lt;/p&gt;

&lt;p&gt;Google provides some decent &lt;a href="https://developers.google.com/web/fundamentals/getting-started/push-notifications/step-04?hl=en"&gt;instructions for registering your app for push
notifications&lt;/a&gt; which involves some clicking around on the &lt;a href="https://console.developers.google.com"&gt;Google developer console&lt;/a&gt;. (I&amp;rsquo;ve heard rumors this may not be necessary in the near future.) You&amp;rsquo;ll want to come away with a project id for your app and an API key to make authorized requests to the push server.&lt;/p&gt;

&lt;p&gt;Both Firefox and Chrome will expect us to link to a &lt;code&gt;manifest&lt;/code&gt; json file to
provide metadata for push subscriptions and notifications. Here&amp;rsquo;s an example:&lt;/p&gt;

&lt;pre&gt;&lt;code class="json"&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;Your app name&amp;quot;,
  &amp;quot;short_name&amp;quot;: &amp;quot;Your app&amp;quot;,
  &amp;quot;icons&amp;quot;: [{
    &amp;quot;src&amp;quot;: &amp;quot;images/icon-192x192.png&amp;quot;,
    &amp;quot;sizes&amp;quot;: &amp;quot;192x192&amp;quot;,
    &amp;quot;type&amp;quot;: &amp;quot;image/png&amp;quot;
  }],
  &amp;quot;start_url&amp;quot;: &amp;quot;/&amp;quot;,
  &amp;quot;display&amp;quot;: &amp;quot;standalone&amp;quot;,
  &amp;quot;gcm_sender_id&amp;quot;: &amp;quot;&amp;lt;Your Project ID&amp;gt;&amp;quot;,
  &amp;quot;gcm_user_visible_only&amp;quot;: true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For now, this file can go in &lt;code&gt;public/manifest.json&lt;/code&gt;. In your &lt;code&gt;app/views/layouts/application.html.erb&lt;/code&gt; template, you&amp;rsquo;ll also need to
add a special &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; tag to the manifest:&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;link rel=&amp;quot;manifest&amp;quot; href=&amp;quot;/manifest.json&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s the &lt;a href="https://serviceworker-rails.herokuapp.com/push-simple/manifest.json"&gt;actual manifest.json&lt;/a&gt; for the Service Worker Rails Sandbox &lt;a href="https://serviceworker-rails.herokuapp.com/push-simple/"&gt;push demo&lt;/a&gt; as another point of reference.&lt;/p&gt;

&lt;h2&gt;Subscribe through a service worker&lt;/h2&gt;

&lt;p&gt;Yes, Service Worker time! In case you missed it, I&amp;rsquo;m really &lt;a href="/blog/series/service-worker.html"&gt;excited about
Service Workers&lt;/a&gt;. Service Workers have the
potential to level the playing field of reliability between the web and mobile devices.&lt;/p&gt;

&lt;p&gt;Service workers must be deployed a bit differently than JavaScript evaluated in
the web page context. I&amp;rsquo;ve gone into more detail on how to &lt;a href="/blog/service-worker-on-rails.html"&gt;integrate Service
Worker with Rails&lt;/a&gt; previously but for now, here&amp;rsquo;s the quick setup for push.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;application.js&lt;/code&gt; (or another &lt;code&gt;.js&lt;/code&gt; required by &lt;code&gt;application.js&lt;/code&gt;) we&amp;rsquo;ll use this following snippet to request registration of
a service worker script.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// app/assets/javascripts/application.js

if (&amp;#39;serviceWorker&amp;#39; in navigator) {
  console.log(&amp;#39;Service Worker is supported&amp;#39;);
  navigator.serviceWorker.register(&amp;#39;/serviceworker.js&amp;#39;)
    .then(function(registration) {
      console.log(&amp;#39;Successfully registered!&amp;#39;, &amp;#39;:^)&amp;#39;, registration);
      registration.pushManager.subscribe({ userVisibleOnly: true })
        .then(function(subscription) {
            console.log(&amp;#39;endpoint:&amp;#39;, subscription.endpoint);
        });
  }).catch(function(error) {
    console.log(&amp;#39;Registration failed&amp;#39;, &amp;#39;:^(&amp;#39;, error);
  });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code registers a service worker on the given scope via &lt;code&gt;navigator.serviceWorker.register&lt;/code&gt;. This returns a &lt;a href="#"&gt;Promise&lt;/a&gt; which will resolve to an instance of &lt;code&gt;ServiceWorkerRegistration&lt;/code&gt;. This registration object has a &lt;code&gt;pushManager&lt;/code&gt; property which we use to &lt;code&gt;subscribe&lt;/code&gt; to the Web Push server. The &lt;code&gt;{ userVisibleOnly: true }&lt;/code&gt; parameter is required for us to use notifications.&lt;/p&gt;

&lt;h3&gt;Troubleshooting&lt;/h3&gt;

&lt;p&gt;I got an error at this stage in Google Chrome the first time: &lt;code&gt;Unable to subscribe to push DOMException: Registration failed - push service error&lt;/code&gt;. Turns out, the &lt;code&gt;pushmanage.subscribe&lt;/code&gt; request can fail if you haven&amp;rsquo;t properly configured your &lt;code&gt;manifest.json&lt;/code&gt; with a valid Google Cloud Message sender id.&lt;/p&gt;

&lt;p&gt;Also, if the &lt;code&gt;pushManager&lt;/code&gt; can&amp;rsquo;t find the &lt;code&gt;manifest.json&lt;/code&gt; via the link tag, or
if it&amp;rsquo;s not included in the page altogether, you may see another error: &lt;code&gt;Unable to subscribe to push DOMException: Registration failed - manifest empty or missing&lt;/code&gt;, so you&amp;rsquo;ll need to get that working to proceed.&lt;/p&gt;

&lt;h3&gt;The Service Worker&lt;/h3&gt;

&lt;p&gt;In a separate file, &lt;code&gt;app/assets/javascripts/serviceworker.js&lt;/code&gt;, we&amp;rsquo;ll have our service worker show notifications when the &lt;code&gt;&amp;#39;push&amp;#39;&lt;/code&gt; event is received:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;function onPush(event) {
  var title = (event.data &amp;amp;&amp;amp; event.data.text()) || &amp;quot;Yay a message&amp;quot;;

  event.waitUntil(
    self.registration.showNotification(title, {
      body: &amp;quot;We have received a push message&amp;quot;,
      icon: &amp;quot;/assets/path/to/icon.png&amp;quot;,
      tag:  &amp;quot;push-simple-demo-notification-tag&amp;quot;
    });
  )
}

self.addEventListener(&amp;quot;push&amp;quot;, onPush);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because &lt;code&gt;serviceworker.js&lt;/code&gt; needs to be a separate script available on the root
path, we either need to copy it to our &lt;code&gt;public/&lt;/code&gt; directory , or, even better, we
can use the &lt;a href="https://github.com/rossta/serviceworker-rails"&gt;&lt;code&gt;serviceworker-rails&lt;/code&gt; (Star it on GitHub!)&lt;/a&gt; gem which will allow us to make use of both the asset pipeline and custom routing features we need.&lt;/p&gt;

&lt;h3&gt;Rails setup&lt;/h3&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Gemfile

gem &amp;#39;serviceworker-rails&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To routes requests from &lt;code&gt;/serviceworker.js&lt;/code&gt; to our JavaScript file in the asset pipeline, we&amp;rsquo;ll configure the service worker rails middleware as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# config/initializers/serviceworker.rb

Rails.application.configure do
  config.serviceworker.routes do
    match &amp;quot;serviceworker.js&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With these settings, we should be able to see our service worker register with the logging we put in place and be able to accept the browser prompt to receive notifications&lt;/p&gt;

&lt;h2&gt;Persist the subscription&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s set up a controller action to serialize the subscription into the visitor&amp;rsquo;s session though any persistence method that will allow us to retrieve the subscription(s) for a given user will do.&lt;/p&gt;

&lt;p&gt;The push subscription has important pieces of data: the endpoint and a set of keys: p256dh and auth. We need use this data in requests from our rails app to the push server.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// subscription.toJSON();

{
  endpoint: &amp;quot;https://android.googleapis.com/gcm/send/a-subscription-id&amp;quot;,
  keys: {
    auth: &amp;quot;16ByteString&amp;quot;,
    p256dh: &amp;quot;65ByteString&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When our visitor subscribes, we can post the subscription to our Rails app:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;reg.pushManager.subscribe({ userVisibleOnly: true })
  .then(function(subscription) {
    $.post(&amp;quot;/subscribe&amp;quot;, { subscription: subscription.toJSON() });
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The route:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# config/routes.rb

post &amp;quot;/subscribe&amp;quot; =&amp;gt; &amp;quot;subscriptions#create&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our controller - of course, greatly simplified for the purposes of the this demo:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# app/controllers/subscriptions_controller.rb

class SubscriptionsController &amp;lt; ApplicationController
  def create
    session[:subscription] = JSON.dump(params.fetch(:subscription, {}))

    head :ok
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Push it&lt;/h2&gt;

&lt;p&gt;Now that we have a subscription, we can send a push notification. For this, we&amp;rsquo;ll use the &lt;code&gt;webpush&lt;/code&gt; gem:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Gemfile

gem &amp;quot;webpush&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the subscription info, we have what we need to send a message to a specific
user that will get encrypted in passing over the wire.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a typical usage:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;Webpush.payload_send(
  message: &amp;quot;Hello World!&amp;quot;,
  endpoint: &amp;quot;https://android.googleapis.com/gcm/send/a-subscription-id&amp;quot;,
  auth: &amp;quot;16ByteString&amp;quot;,
  p256dh: &amp;quot;65ByteString&amp;quot;
  api_key: &amp;quot;google_api_key&amp;quot; # omit for Firefox, required for Google
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a proof of concept, we&amp;rsquo;ll create an endpoint to trigger a push notification directly from a user interaction in the browser.&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;!-- a view --&amp;gt;
&amp;lt;button class=&amp;quot;js-push-button&amp;quot;&amp;gt;Send a message&amp;lt;/button&amp;gt;

&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
  (function() {
    $(&amp;#39;.js-push-button&amp;#39;).on(&amp;quot;click&amp;quot;, function onClick() {
      $.post(&amp;quot;/push&amp;quot;);
    });
  })();
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Start with a button to trigger a &lt;code&gt;POST&lt;/code&gt; to a new &lt;code&gt;/push&lt;/code&gt; endpoint in our app. In a real Rails app, you&amp;rsquo;d probably deliver push notifications from background jobs in response to other events in the system.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# config/routes.rb

post &amp;quot;/push&amp;quot; =&amp;gt; &amp;quot;push_notifications#create&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Route the request to a new controller.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# app/controllers/push_notifications_controller.rb

class PushNotificationsController &amp;lt; ApplicationController
  def create
    Webpush.payload_send webpush_params

    head :ok
  end

  private

  def webpush_params
    subscription_params = fetch_subscription
    message = &amp;quot;Hello world, the time is #{Time.zone.now}&amp;quot;
    endpoint = subscription_params[:endpoint],
    p256dh = subscription_params.dig(:keys, :p256dh)
    auth = subscription_params.dig(:keys, :auth)
    api_key = enpoint =~ /\.google.com\// = ENV.fetch(&amp;#39;GOOGLE_CLOUD_MESSAGE_API_KEY&amp;#39;) || &amp;quot;&amp;quot;

    { message: message, endpoint: endpoint, p256dh: p256dh, auth: auth, api_key: api_key }
  end

  def fetch_subscription
    encoded_subscription = session.fetch(:subscription) do
      raise &amp;quot;Cannot create notification: no :subscription in params or session&amp;quot;
    end

    JSON.parse(Base64.urlsafe_decode64(encoded_subscription)).with_indifferent_access
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The controller deserializes the subscription from the session and builds up the
necessary parameters to send to the &lt;code&gt;Webpush&lt;/code&gt; Ruby client. Only the &lt;code&gt;:endpoint&lt;/code&gt; is
required to send a notification in theory. The &lt;code&gt;:p256dh&lt;/code&gt; and &lt;code&gt;:auth&lt;/code&gt; keys are also required if providing a &lt;code&gt;:message&lt;/code&gt; parameter, which must be encrypted to deliver over the wire. Google requires the Google Cloud Message API key we grabbed from th developer console, so we test the endpoint to
decide whether to include it in the request.&lt;/p&gt;

&lt;p&gt;If everything worked, we get a push notification!&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/screenshots/screenshot-sw-sandbox-push-simple-2-b270f8bc.jpg" /&gt;&lt;/p&gt;

&lt;h2&gt;Unsubscribing&lt;/h2&gt;

&lt;p&gt;We can programmatically turn off notifications by calling
&lt;code&gt;PushSubscription#unsubscribe&lt;/code&gt;. This could be done in a callback to a click handler, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;function unsubscribe() {
  navigator.serviceWorker.ready
    .then((serviceWorkerRegistration) =&amp;gt; {
      serviceWorkerRegistration.pushManager.getSubscription()
        .then((subscription) =&amp;gt; {
          if (!subscription) {
            console.log(&amp;quot;Not subscribed, nothing to do.&amp;quot;);
            return;
          }

          subscription.unsubscribe()
            then(function() {
              console.log(&amp;quot;Successfully unsubscribed!.&amp;quot;);
            })
            .catch((e) =&amp;gt; {
              logger.error(&amp;#39;Error thrown while unsubscribing from push messaging&amp;#39;, e);
            });
        });
    });
}

$(&amp;quot;.js-unsubscribe-button&amp;quot;).on(&amp;quot;click&amp;quot;, unsubscribe)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;d also want to send a request to your Rails app to delete the persisted
subscription data from the backend which will no longer be valid on the Web Push
server. That exercise is left up to you!&lt;/p&gt;

&lt;h2&gt;Wrap up&lt;/h2&gt;

&lt;p&gt;This took quite a bit of setup though not nearly as much as getting &lt;a href="https://developer.apple.com/notifications/safari-push-notifications/"&gt;Apple
Push Notifications to work in Safari&lt;/a&gt;. Overall, the Web Push API is an interesting step for the web in terms of feature parity with mobile.&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>An offline page for your Rails application</title>
    <link rel="alternate" href="/blog/offline-page-for-your-rails-application.html"/>
    <id>/blog/offline-page-for-your-rails-application.html</id>
    <published>2016-05-09T00:00:00+00:00</published>
    <updated>2016-05-09T00:00:00+00:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;When you visit a website without an internet connection in Chrome, you see the
offline dinosaur.&lt;/p&gt;

&lt;p&gt;No wonder we tend to think of websites as less reliable than mobile applications - we can’t use them without the network.&lt;/p&gt;

&lt;p&gt;At least, not typically. We...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;When you visit a website without an internet connection in Chrome, you see the
offline dinosaur.&lt;/p&gt;

&lt;p&gt;No wonder we tend to think of websites as less reliable than mobile applications - we can&amp;rsquo;t use them without the network.&lt;/p&gt;

&lt;p&gt;At least, not typically. We could use &lt;a href="http://diveintohtml5.info/offline.html"&gt;App Cache&lt;/a&gt; and the Cache Manifest to create an offline experience. For &lt;a href="http://alistapart.com/article/application-cache-is-a-douchebag"&gt;a number of reasons&lt;/a&gt;, developers have found App Cache difficult to work with.&lt;/p&gt;

&lt;p&gt;Luckily, there&amp;rsquo;s a new web standard, &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API"&gt;Service Worker&lt;/a&gt;, that potentially supplants App Cache by providing more granular control over networking in JavaScript, as opposed to manifest files.&lt;/p&gt;

&lt;p&gt;For now, we use a service worker to render a simple error page with our own branding
when a user attempts to come back to our site without a connection. Keep in
mind, the techniques used here are building blocks that can be taken further to enhance functionality.&lt;/p&gt;

&lt;aside class="callout panel"&gt;
  &lt;p&gt;
Sidebar: I&amp;rsquo;ve wondered: should the offline response be associated with an HTTP status code? I don&amp;rsquo;t believe one exists for &amp;ldquo;No network connection&amp;rdquo;. If the potential for service workers is fully realized, then in theory, web developers will be able to create rich experiences for users regardless of connectivity - so perhaps question won&amp;rsquo;t be relevant. But our use case for a singular offline response - one in which we give visitors feedback about why their request cannot be fulfilled - correlates with statuses like &amp;ldquo;Not found&amp;rdquo;, &amp;ldquo;Moved permanently&amp;rdquo;, and &amp;ldquo;Site offline for maintenance&amp;rdquo;. Philosophically, is a request that never reaches the server a request at all?
&lt;/p&gt;
&lt;/aside&gt;

&lt;p&gt;To do this, we&amp;rsquo;re going to use a service worker to precache the offline
assets on the first visit to the site. Later, during a return visit without a
network connection, we can use our service worker to render the offline page.&lt;/p&gt;

&lt;p&gt;This is possible because Service Worker acts as a liason between your
visitor&amp;rsquo;s browser and your servers &lt;em&gt;outside the lifecycle of a page&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Keep in mind also, will be a &lt;em&gt;progressive enhancement&lt;/em&gt;. Since service workers are &lt;a href="https://jakearchibald.github.io/isserviceworkerready/"&gt;not available in all browsers&lt;/a&gt;, this approach won&amp;rsquo;t work for everyone, but the experience won&amp;rsquo;t degrade for those visitors either.&lt;/p&gt;

&lt;h3&gt;Produce the assets&lt;/h3&gt;

&lt;p&gt;First we need an offline page. We could simply use an HTML page in the public directory with embedded styles like the generated Rails 404 and 500 pages.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://gist.github.com/rossta/c4f6de214a138a355a9993c7cdadbdc0"&gt;Source: /offline.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alternatively, set up a route to a controller action as a &lt;a href="https://mattbrictson.com/dynamic-rails-error-pages"&gt;dynamic Rails error page&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Add a service worker file&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;re going to cache this offline HTML on the client side during their first
visit so that it&amp;rsquo;s available later. We can of course add links
to external CSS, JavaScript, and images in our offline pages - we just need to
remember to cache those resources as well.&lt;/p&gt;

&lt;p&gt;(The following assumes Sprockets, so if using something else, we&amp;rsquo;ll need to adjust accordingly where the asset pipeline is concerned.)&lt;/p&gt;

&lt;p&gt;The service worker script file must live outside our &lt;code&gt;application.js&lt;/code&gt; or other
bundled assets. It can live in any path from which Sprockets can load assets,
but for now, we&amp;rsquo;ll add a new JavaScript file in &lt;code&gt;app/assets/javascripts/serviceworker.js&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Since it won&amp;rsquo;t be bundled with &lt;code&gt;application.js&lt;/code&gt;, we&amp;rsquo;ll need to let our Rails
configuration know to precompile our serviceworker separately:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# config/initializers/assets.rb

Rails.application.config.assets.precompile += %w[serviceworker.js]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Declare an &amp;lsquo;install&amp;rsquo; event&lt;/h3&gt;

&lt;p&gt;Since service workers are event driven, we&amp;rsquo;ll provide callbacks to three key events in the servive worker lifecycle: &lt;code&gt;install&lt;/code&gt;, &lt;code&gt;activate&lt;/code&gt;, and &lt;code&gt;fetch&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;install&lt;/code&gt; event will be invoked just the first time the service worker is
requested or any time it is updated and redeployed prior to being activated. Here, we&amp;rsquo;ll precache our offline assets:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;var version = &amp;#39;v1::&amp;#39;;

self.addEventListener(&amp;#39;install&amp;#39;, function onInstall(event) {
  event.waitUntil(
    caches.open(version + &amp;#39;offline&amp;#39;).then(function prefill(cache) {
      return cache.addAll([
        &amp;#39;/offline.html&amp;#39;,
        // etc
      ]);
    })
  );
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;event.waitUntil&lt;/code&gt; accepts &lt;a href="http://www.html5rocks.com/en/tutorials/es6/promises/"&gt;a promise&lt;/a&gt; which must succeed for the &lt;code&gt;install&lt;/code&gt; event to install the service worker successfully. We use &lt;code&gt;caches.open&lt;/code&gt; to return a promise that adds our static offline assets to a named cache associated with our site and the user&amp;rsquo;s browser. The &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache"&gt;Cache API&lt;/a&gt; provides client-side storage for request/response pairs, a lot like a built in HTTP cache.&lt;/p&gt;

&lt;p&gt;We can also cache precompiled assets by renaming our &lt;code&gt;serviceworker.js&lt;/code&gt; to &lt;code&gt;serviceworker.js.erb&lt;/code&gt; and embedding helper methods:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;return cache.addAll([
  &amp;#39;/offline.html&amp;#39;,
  &amp;#39;&amp;lt;%= asset_path &amp;quot;application.css&amp;quot; %&amp;gt;&amp;#39;,
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&amp;#39;fetch&amp;rsquo; or fallback&lt;/h3&gt;

&lt;p&gt;Our service worker can intercept any external network request from our visitor&amp;rsquo;s
browser - even to cross-origin hosts - within the fetch event.&lt;/p&gt;

&lt;p&gt;There are &lt;a href="https://jakearchibald.com/2014/offline-cookbook/"&gt;a ton of strategies we can
employ&lt;/a&gt; to give the service
worker power to respond to various requests, for our simple offline page&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;self.addEventListener(&amp;#39;fetch&amp;#39;, function onFetch(event) {
  var request = event.request;

  if (!request.url.match(/^https?:\/\/example.com/) ) { return; }
  if (request.method !== &amp;#39;GET&amp;#39;) { return; }

  event.respondWith(
    fetch(request).                                      // first, the network
      .catch(function fallback() {
        caches.match(request).then(function(response) {  // then, the cache
          response || caches.match(&amp;quot;/offline.html&amp;quot;);     // then, /offline cache
        })
      })
  );
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code will filter for GET requests to our host. Ignored &lt;code&gt;fetch&lt;/code&gt; events will simply proceed to the network. When we may want to provide the offline fallback, we&amp;rsquo;ll then ask then network to &lt;code&gt;fetch&lt;/code&gt; the
request. If that doesn&amp;rsquo;t resolve, our &lt;code&gt;catch&lt;/code&gt; handler will be invoked and
attempt to match the request in the cache or simply return our cached offline
page.&lt;/p&gt;

&lt;h3&gt;Clean up during &amp;#39;activate&amp;rsquo;&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;activate&lt;/code&gt; event is useful to clean up old caches, say when the offline page
or any of the linked static resources changes.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// var version = &amp;quot;v2::&amp;quot;;

self.addEventListener(&amp;#39;activate&amp;#39;, function onActivate(event) {
  event.waitUntil(
    caches.keys().then(function deleteOldCache(cacheNames) {
      return Promise.all(
        cacheNames.filter(function(cacheName) {
          return key.indexOf(version) !== 0;
        }).map(function(cacheName) {
          return caches.delete(cacheName);
        })
      );
    })
  );
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we deploy a service worker with a new version number, the &lt;code&gt;install&lt;/code&gt; event
will be invoked again to re-cache the static resources for the offline page.
During &lt;code&gt;activate&lt;/code&gt;, any cache names that don&amp;rsquo;t match the new version number will
be removed.&lt;/p&gt;

&lt;h3&gt;Register that worker&lt;/h3&gt;

&lt;p&gt;With our service worker event handling in place, we must register the script
from the main page. In any file included in &lt;code&gt;application.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// app/assets/application.js

if (&amp;#39;serviceWorker&amp;#39; in navigator) {
  navigator.serviceWorker.register(&amp;#39;/serviceworker.js&amp;#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s important for this script to be available at the scope for which we want
the service worker to be active. In other words, registering the service worker
at its precompiled path &lt;code&gt;/assets/serviceworker.js&lt;/code&gt;, won&amp;rsquo;t be helpful since we
won&amp;rsquo;t be able to intercept requests to the root path.&lt;/p&gt;

&lt;h3&gt;Sprinkle in some middleware&lt;/h3&gt;

&lt;p&gt;To make this work with the Rails asset pipeline, we can use the
&lt;a href="https://github.com/rossta/serviceworker-rails"&gt;&lt;code&gt;serviceworker-rails&lt;/code&gt;&lt;/a&gt; gem.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Gemfile

gem &amp;quot;serviceworker-rails&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ServiceWorker::Rails&lt;/code&gt; will insert middleware into the Rails stack that we can
configure to route requests to bundled assets.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# config/initializers/serviceworker.rb

Rails.application.configure do
  config.serviceworker.routes.draw do
    match &amp;quot;/serviceworker.js&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, any request to the path &lt;code&gt;/serviceworker.js&lt;/code&gt; will match an asset of that
name. If your service worker script is in a nested directory, you&amp;rsquo;d use this
instead:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;match &amp;quot;/serviceworker.js&amp;quot; =&amp;gt; &amp;quot;nested/directory/serviceworker.js&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See the project &lt;a href="https://github.com/rossta/serviceworker-rails/blob/master/README.md"&gt;README&lt;/a&gt; for more info on how to configure the middleware.&lt;/p&gt;

&lt;p&gt;While you&amp;rsquo;re at it, &lt;a href="https://github.com/rossta/serviceworker-rails"&gt;star the project on GitHub&lt;/a&gt;!&lt;/p&gt;

&lt;h3&gt;Moment of truth&lt;/h3&gt;

&lt;p&gt;Phew! That took some setup. Our offline page should now be ready for consumption. Try disabling your
network connection to test it out. You can use the &lt;em&gt;Network&lt;/em&gt; tab in Chrome and
Chrome Canary to take your browser offline while Firefox has the &lt;em&gt;Work Offline&lt;/em&gt; mode under the File menu.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/screenshots/screenshot-dev-tools-network-offline-fc2a31d1.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;To see a working demo of an offline page, check out the &lt;a href="https://serviceworker-rails.herokuapp.com/offline-fallback/"&gt;Service Worker Rails
Sandbox app&lt;/a&gt;. You
can find its &lt;a href="https://github.com/rossta/serviceworker-rails-sandbox"&gt;source code on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/screenshots/screenshot-offline-custom-4e1f1089.jpg" /&gt;&lt;/p&gt;

&lt;h3&gt;Debugging&lt;/h3&gt;

&lt;p&gt;Chrome also provides some useful debugging tools for service workers under the
&lt;em&gt;Resources&lt;/em&gt;. It&amp;rsquo;s helpful to read up on the Service Worker life cycle since it is treated
differently than other JavaScript resources. For example, a hard refresh isn&amp;rsquo;t
enough to get your browser to install an updated service worker &amp;ndash; the browser
will keep the current worker active while any tab to your browser is currently
open.&lt;/p&gt;

&lt;p&gt;You can navigate to a different host and back or close and reopen
the tab(s). The &lt;code&gt;self.skipWaiting&lt;/code&gt; function will also instruct the browser to
let a new service worker take control immediately when used during &lt;code&gt;install&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;self.addEventListener(&amp;#39;install&amp;#39;, function(event) {
  event.waitUntil(self.skipWaiting());
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Final word&lt;/h3&gt;

&lt;p&gt;I believe it&amp;rsquo;s important for web developers to start thinking about ways to make
our application more reliable in the eyes of consumers. While rendering an
offline page isn&amp;rsquo;t a game changer by itself, it is a low-risk way to begin
experimenting with the Service Worker API which has the potential for &lt;a href="http://serviceworke.rs/"&gt;many more
advanced use cases&lt;/a&gt; and can help the web get
closer to an even playing field with mobile apps.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Service Worker on Rails</title>
    <link rel="alternate" href="/blog/service-worker-on-rails.html"/>
    <id>/blog/service-worker-on-rails.html</id>
    <published>2016-05-03T00:00:00+00:00</published>
    <updated>2016-05-03T00:00:00+00:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;Have you heard about &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API"&gt;Service
Worker&lt;/a&gt;? I
believe this new JavaScript API has the potential to transform the way users
interact with the web and how web developers construct websites. Though still in
development, Service Worker is already &lt;a href="https://jakearchibald.github.io/isserviceworkerready/"&gt;landing in modern...&lt;/a&gt;&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Have you heard about &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API"&gt;Service
Worker&lt;/a&gt;? I
believe this new JavaScript API has the potential to transform the way users
interact with the web and how web developers construct websites. Though still in
development, Service Worker is already &lt;a href="https://jakearchibald.github.io/isserviceworkerready/"&gt;landing in modern
browsers&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So far, there hasn&amp;rsquo;t been a good story for adding Service Worker to Rails. Until
now!&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a new Ruby gem, &lt;a href="https://github.com/rossta/serviceworker-rails"&gt;&lt;code&gt;serviceworker-rails&lt;/code&gt;&lt;/a&gt;, to make it easier to integrate Service Worker with the Rails asset pipeline. To understand why Rails developers might want to use this, let&amp;rsquo;s take a step back.&lt;/p&gt;

&lt;h2&gt;A brief intro&lt;/h2&gt;

&lt;p&gt;In its plainest form, service workers are just JavaScript running in a separate thread outside the context of a web page, like any other &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API"&gt;web worker&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But, service workers are special; they can act as &lt;strong&gt;client-side proxies&lt;/strong&gt;. This means they can &lt;em&gt;hook into the request/response cycle&lt;/em&gt; on the user&amp;rsquo;s machine.&lt;/p&gt;

&lt;p&gt;Hooking in to the request/response cycle on the client-side means we can improve the user experience in ways that weren&amp;rsquo;t possible (or much more difficult) previously. We could render HTML from a local cache while waiting for a response from the network or we could display another friendly page altogether when the network is offline. With service workers, we&amp;rsquo;ll be able to pre-fetch and sync data in the background, push activity notifications to users and even let them know when new releases have been deployed.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve been &lt;a href="/blog/adding-serviceworker-to-a-simple-website.html"&gt;playing with Service Worker&lt;/a&gt; a bit lately. Now that you&amp;rsquo;ve visited my site, your browser has cached the data for &lt;a href="/offline.html"&gt;my offline page&lt;/a&gt;, so if you lost your network connection, you&amp;rsquo;d at least see a friendly message instead of the dreaded Chrome dinosaur.&lt;/p&gt;

&lt;p&gt;Go ahead and take a look at the &lt;a href="https://github.com/rossta/rossta.github.com/blob/45b67d326bb1118c9e0743ae74e1a5ca570a5947/source/assets/javascripts/serviceworker.js"&gt;source code for the rossta.net service worker&lt;/a&gt; to see how I did it. I&amp;rsquo;m still learning about Service Worker - is it &lt;em&gt;really&lt;/em&gt; new after all - so I&amp;rsquo;m sure there&amp;rsquo;s lots of ways I could improve it!&lt;/p&gt;

&lt;h2&gt;Let&amp;rsquo;s talk Rails&lt;/h2&gt;

&lt;p&gt;Next I wondered how I&amp;rsquo;d add a Service Worker to a Rails application. I&amp;rsquo;d expect Rails developers would want to be able to develop and deploy their service workers like any other JavaScript assets using the Rails asset pipeline. Not so fast though.&lt;/p&gt;

&lt;p&gt;As it turns out, to use Service Workers on Rails, we want some, but not all, of the Rails asset pipeline.&lt;/p&gt;

&lt;p&gt;The Rails asset pipeline makes a number of assumptions about what&amp;rsquo;s best for deploying JavaScript, including asset digest fingerprints and long-lived cache headers - mostly to increase &amp;ldquo;cacheability&amp;rdquo;. Rails also assumes a single parent directory, &lt;code&gt;/public/assets&lt;/code&gt;, to make it easier to look up the file path for a given asset.&lt;/p&gt;

&lt;p&gt;Service worker assets must play by different rules. Consider these behaviors:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Service workers may only be active from within the scope from which they are
served. So if you try to register a service worker from a Rails asset pipeline
path, like &lt;code&gt;/assets/serviceworker-abcd1234.js&lt;/code&gt;, it will only be able to interact
with requests and responses within &lt;code&gt;/assets/&lt;/code&gt;&lt;em&gt;**&lt;/em&gt;. This is not what we want.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API#Download_install_and_activate"&gt;MDN states&lt;/a&gt; browsers check for updated service worker scripts in the background every 24 hours (possibly less). Rails developers wouldn&amp;rsquo;t be able to take advantage of this feature since the fingerprint strategy means assets at a given url are immutable. Beside fingerprintings, the &lt;code&gt;Cache-Control&lt;/code&gt; headers used for static files served from Rails also work against browser&amp;rsquo;s treatment of service workers.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;**&lt;/em&gt;&lt;a href="https://slightlyoff.github.io/ServiceWorker/spec/service_worker/#service-worker-allowed"&gt;There is an early proposal&lt;/a&gt; to use the &lt;code&gt;Service-Worker-Allowed&lt;/code&gt; header to change scopes.&lt;/p&gt;

&lt;h2&gt;What to do?&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://github.com/rails/sprockets/issues/44"&gt;For now&lt;/a&gt;, Rails developers need to work around best practices in the Rails asset pipeline to use service workers.&lt;/p&gt;

&lt;p&gt;One approach would be to just place service worker scripts in &lt;code&gt;/public&lt;/code&gt;. That
could work, but it could mean foregoing the asset pipeline altogether. We lose
bundling, transpilation, testing and other features we do want. You could use
the pipeline but would then need to add steps to the build process to copy
precompiled service workers to the correct paths. In this case, you may want toaugment your
web server configuration to change &lt;code&gt;Cache-Control&lt;/code&gt; headers for those selected service worker scripts - this may not be possible in certain environments.&lt;/p&gt;

&lt;p&gt;Given the constraints around scoping, you could create
special controller actions to mount service workers at arbitrary routes. Rails
also gives you the ability to set custom headers on controller actions so that&amp;rsquo;s
another benefit. From there, you either write your JavaScript in a template where you may lose the advantage of the asset pipeline or
expose the contents of a precompiled asset from within the controller.&lt;/p&gt;

&lt;p&gt;I like this last option up until the point where a standard Rails controller
adds a lot of overhead, e.g. parameter parsing, session and cookie management, CSRF
protection, that isn&amp;rsquo;t needed for serving static files. From there, you can drop
down to a &lt;code&gt;ActionController::Metal&lt;/code&gt; subclass and figure out which extensions to
pull in&amp;hellip; or put this in a Rack middleware!&lt;/p&gt;

&lt;h2&gt;Using serviceworker-rails&lt;/h2&gt;

&lt;p&gt;This is what I&amp;rsquo;ve done with &lt;a href="https://github.com/rossta/serviceworker-rails"&gt;&lt;code&gt;serviceworker-rails&lt;/code&gt;&lt;/a&gt;. It inserts a middleware into the Rails stack that acts as a separate router for service worker scripts. In development, you can edit and recompile your service workers on the fly as with any other asset in the pipeline. In production, the service worker endpoints map to the precompiled asset in &lt;code&gt;/public/assets&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Once the gem is added to your &lt;code&gt;Gemfile&lt;/code&gt;, you can add a Rails initializer to set
up the service worker middleware router:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# config/initializers/serviceworker.rb
Rails.application.configure do
  config.serviceworker.routes.draw do
    match &amp;quot;/serviceworker.js&amp;quot; =&amp;gt; &amp;quot;path/to/precompiled/serviceworker&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default, the middleware sets the &lt;code&gt;Cache-Control&lt;/code&gt; header to avoid aggressive caching. It also gives you the ability to customize headers as desired.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;match &amp;quot;/serviceworker.js&amp;quot; =&amp;gt; &amp;quot;app/serviceworker&amp;quot;, headers: { &amp;quot;X-Custom-Header&amp;quot; =&amp;gt; &amp;quot;foobar&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use globbing or named parameters in the service worker paths to interpolate
asset names.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;match &amp;quot;/*segments/serviceworker.js&amp;quot; =&amp;gt; &amp;quot;%{segments}/serviceworker&amp;quot;
match &amp;quot;/project/:id/serviceworker.js&amp;quot; =&amp;gt; &amp;quot;project/%{id}/serviceworker&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check out the project &lt;a href="https://github.com/rossta/serviceworker-rails#serviceworkerrails"&gt;README&lt;/a&gt; for more info on how to set up and configure the middleware for your Rails app.&lt;/p&gt;

&lt;p&gt;Though the project is still young, you can see &lt;code&gt;serviceworker-rails&lt;/code&gt; in action in the &lt;a href="https://serviceworker-rails.herokuapp.com/"&gt;Service Workers on Rails Sandbox&lt;/a&gt;. Inspired by Mozilla&amp;rsquo;s &lt;a href="https://serviceworke.rs/"&gt;Service Workers Cookbook&lt;/a&gt;, it serves as good place to experiment with Service Workers on Rails in an open source setting. Try using the site in Chrome Canary with the &lt;a href="https://www.chromium.org/blink/serviceworker/service-worker-faq"&gt;advanced service worker debugging tools&lt;/a&gt; to play around. I&amp;rsquo;ve added just a few examples so far but am interested to explore further with various caching strategies, push notifications, and eventually background sync to name a few.&lt;/p&gt;

&lt;p&gt;What do you think of this approach?&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Interested in contributing? &lt;a href="https://github.com/rossta/serviceworker-rails"&gt;Fork the serviceworker-rails gem&lt;/a&gt; or the &lt;a href="https://github.com/rossta/serviceworker-rails-sandbox"&gt;Service Workers on Rails Sandbox&lt;/a&gt; to get started.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>How to specify local Ruby gems in your Gemfile</title>
    <link rel="alternate" href="/blog/how-to-specify-local-ruby-gems-in-your-gemfile.html"/>
    <id>/blog/how-to-specify-local-ruby-gems-in-your-gemfile.html</id>
    <published>2016-04-23T00:00:00+00:00</published>
    <updated>2016-04-23T00:00:00+00:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;Let’s say you’re building a Ruby app and your team has extracted one or more
gems referenced in your Gemfile, such as your custom Trello API client, &lt;a href="https://github.com/rossta/tacokit.rb"&gt;Tacokit.rb&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Gemfile
source "https://rubygems.org"

# lots of gems ...

gem "tacokit"
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Maybe Trello...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Let&amp;rsquo;s say you&amp;rsquo;re building a Ruby app and your team has extracted one or more
gems referenced in your Gemfile, such as your custom Trello API client, &lt;a href="https://github.com/rossta/tacokit.rb"&gt;Tacokit.rb&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Gemfile
source &amp;quot;https://rubygems.org&amp;quot;

# lots of gems ...

gem &amp;quot;tacokit&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Maybe Trello made some recent changes to their API that your current feature depends
on, so you need to update the &lt;code&gt;Tacokit&lt;/code&gt; gem as part of your work. You have a
local checkout of the &lt;code&gt;tacokit&lt;/code&gt; gem in another directory in your laptop.&lt;/p&gt;

&lt;p&gt;You add some code to the gem, but now you want to test the changes in your app. How do you do that?&lt;/p&gt;

&lt;p&gt;According to &lt;em&gt;&lt;a href="http://stackoverflow.com/questions/4487948/how-can-i-specify-a-local-gem-in-my-gemfile#answer-4488110"&gt;the most popular answer (and accepted) answer&lt;/a&gt;&lt;/em&gt; to the question, &lt;a href="http://stackoverflow.com/questions/4487948/how-can-i-specify-a-local-gem-in-my-gemfile"&gt;&amp;ldquo;How can I specify a local gem in my Gemfile?&amp;rdquo;&lt;/a&gt;, we should do the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;gem &amp;quot;tacokit&amp;quot;, path: &amp;quot;/path/to/tacokit&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s my take: &lt;strong&gt;avoid this recommendation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&amp;hellip;especially if you work on a team and/or deploy this code to remote servers.&lt;/p&gt;

&lt;h2&gt;WAT&lt;/h2&gt;

&lt;p&gt;Technically, it does work. Run &lt;code&gt;$ bundle update&lt;/code&gt;, restart the app, and - boom! - our changes in
the local &lt;code&gt;tacokit&lt;/code&gt; checkout are showing up as expected.&lt;/p&gt;

&lt;p&gt;Then the trouble begins.&lt;/p&gt;

&lt;p&gt;We push our app changes and deploy to the staging server to test them out
in the shared environment and - wait a minute - the app won&amp;rsquo;t even start.&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ bundle
The path `/Users/ross/does/not/exist` does not exist.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oops! We forgot to remove the &lt;code&gt;:path&lt;/code&gt; reference in the &lt;code&gt;Gemfile&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s fix that&amp;hellip; we remove the &lt;code&gt;:path&lt;/code&gt; reference, push, and redeploy. The app
restarts fine. But while testing the feature, we start getting 500 errors. This wasn&amp;rsquo;t happening locally.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;But it worked on my machine!&amp;rdquo; - &lt;em&gt;every developer ever&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The Rails logs reveal we have a bunch of undefined method errors coming from calls to &lt;code&gt;Tacokit&lt;/code&gt;. That&amp;rsquo;s right, we forgot another key step in this workflow: pushing our local &lt;code&gt;Tacokit&lt;/code&gt; changes to the remote!&lt;/p&gt;

&lt;p&gt;OK, after we&amp;rsquo;ve done that and redeployed the app, we&amp;rsquo;re still getting 500 errors.&lt;/p&gt;

&lt;p&gt;D&amp;#39;oh! We were working on a &lt;em&gt;branch&lt;/em&gt; of &lt;code&gt;tacokit&lt;/code&gt; but we reference it in our app&amp;rsquo;s &lt;code&gt;Gemfile&lt;/code&gt;.&lt;/p&gt;

&lt;h2&gt;Taking a step back&lt;/h2&gt;

&lt;p&gt;Good thing we weren&amp;rsquo;t pushing that app feature to production. We would have been wise to run the tests on our CI server first where we would have seen the same errors (assuming we had the right tests&amp;hellip; and a CI server).&lt;/p&gt;

&lt;p&gt;Using the &lt;code&gt;:path&lt;/code&gt; often means pointing to a location that only exists on our local machine. Every time we want to develop against the local &lt;code&gt;tacokit&lt;/code&gt; gem, we have to remember to edit the &lt;code&gt;Gemfile&lt;/code&gt; to remove the option so we don&amp;rsquo;t screw up our teammates or break the build. We also can&amp;rsquo;t forget to point to correct branch.&lt;/p&gt;

&lt;p&gt;This workflow is no good because we&amp;rsquo;re human and humans tend to forget to do things.&lt;/p&gt;

&lt;h2&gt;&amp;ldquo;bundle config local&amp;rdquo; to the rescue&lt;/h2&gt;

&lt;p&gt;Buried deep in the Bundler docs is a better solution for &lt;a href="http://bundler.io/git.html#local"&gt;working with local git repo&lt;/a&gt;: the &lt;code&gt;bundle config local&lt;/code&gt; command. Instead of specifying the &lt;code&gt;:path&lt;/code&gt; option, we can run the following on command line:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ bundle config local.tacokit /path/to/tacokit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we instruct Bundler to look in a local resource by modifying our local Bundler configuration. That&amp;rsquo;s the one that lives in
&lt;code&gt;.bundle/config&lt;/code&gt; outside of version control.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;No more editing shared code for local development settings.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We can confirm the link with &lt;code&gt;bundle config&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ bundle config
Settings are listed in order of priority. The top value will be used.
local.tacokit
Set for your local app (/Users/rossta/.bundle/config): &amp;quot;/Users/rossta/path/to/tacokit&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can scope the configuration to a specific folder with the &lt;code&gt;--local&lt;/code&gt; flag:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ bundle config --local local.tacokit /path/to/tacokit
$ bundle config
Settings are listed in order of priority. The top value will be used.
local.tacokit
Set for your local app (/Users/rossta/path/to/app/.bundle/config): &amp;quot;/Users/rossta/path/to/tacokit&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To take advantage of this local override in the app, we have to specify the remote repo and branch in the &lt;code&gt;Gemfile&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;gem &amp;quot;tacokit&amp;quot;, github: &amp;quot;rossta/tacokit&amp;quot;, branch: &amp;quot;master&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bundler will abort if the local gem branch doesn&amp;rsquo;t match the one in the &lt;code&gt;Gemfile&lt;/code&gt; and checks that the sha in Gemfile.lock exists in the local repository.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;This way we ensure our Gemfile.lock contains a valid reference to our local gem.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We don&amp;rsquo;t get these assertions when using the &lt;code&gt;:path&lt;/code&gt; option.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s easy to remove the local config after we don&amp;rsquo;t need it:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bundle config --delete local.YOUR_GEM_NAME&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;Caveats&lt;/h2&gt;

&lt;p&gt;As with the &lt;code&gt;:path&lt;/code&gt; option, we still need to remember to push our
local gem changes to the remote repository when using &lt;code&gt;bundle config local&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I should also mention that a good use case for using &lt;code&gt;:path&lt;/code&gt; instead of &lt;code&gt;bundle
config local&lt;/code&gt; it when the local gem is in a subdirectory relative to your app,
like when using &lt;a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules"&gt;git submodules&lt;/a&gt;.
I don&amp;rsquo;t often see this in practice, but there are valid reasons for doing so.
The main point here is that the Gemfile options work for all systems where the
repository is bundled.&lt;/p&gt;

&lt;p&gt;In general, I&amp;rsquo;d encourage using either approach sparingly for gems that your
team doesn&amp;rsquo;t own as it&amp;rsquo;s typically best to stick the official releases for
active repositories. In my experience, it&amp;rsquo;s most common to develop against local gems for
projects that your team &lt;em&gt;does&lt;/em&gt; own, so &lt;code&gt;bundle config local&lt;/code&gt; will ensure your
co-workers know where to look to verify code dependencies.&lt;/p&gt;

&lt;h2&gt;Don&amp;rsquo;t use :path, use bundle config local instead&lt;/h2&gt;

&lt;p&gt;Though convenient, using the &lt;code&gt;:path&lt;/code&gt; option in our &lt;code&gt;Gemfile&lt;/code&gt; to point to a local
gem elsewhere on our machine sets us up for three potential problems without automated prevention:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Committing a nonexistent lookup path on other machines&lt;/li&gt;
&lt;li&gt;Failing to point to the correct repository branch&lt;/li&gt;
&lt;li&gt;Failing to point to an existing git reference&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Forget the &lt;code&gt;:path&lt;/code&gt; option and you&amp;rsquo;ll never forget ^^this stuff^^ again.&lt;/p&gt;

&lt;p&gt;Just use this command:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;bundle config local.YOUR_GEM_NAME`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And don&amp;rsquo;t believe everything you read on StackOverflow.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Adding Service Worker to a simple website</title>
    <link rel="alternate" href="/blog/adding-serviceworker-to-a-simple-website.html"/>
    <id>/blog/adding-serviceworker-to-a-simple-website.html</id>
    <published>2016-04-20T00:00:00+00:00</published>
    <updated>2016-04-20T00:00:00+00:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;Service Worker is well-suited to enhance a simple website like this blog. The &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API"&gt;Service Worker API&lt;/a&gt; has been designed in such as a way that developers can pick and choose the features they want without reworking their sites or committing to a (or another...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Service Worker is well-suited to enhance a simple website like this blog. The &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API"&gt;Service Worker API&lt;/a&gt; has been designed in such as a way that developers can pick and choose the features they want without reworking their sites or committing to a (or another) JavaScript framework.&lt;/p&gt;

&lt;p&gt;I recently added a service worker to rossta.net. You can read
the &lt;a href="https://github.com/rossta/rossta.github.com/blob/efbb4d41697a64543f5d4870c9915e633dda962d/source/assets/javascripts/serviceworker.js"&gt;full source of my serviceworker.js implementation&lt;/a&gt; here.&lt;/p&gt;

&lt;h3&gt;Requirements&lt;/h3&gt;

&lt;p&gt;To get my first service worker running, I did the following:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HTTPS everywhere&lt;/strong&gt; I moved rossta.net to &lt;a href="https://en.wikipedia.org/wiki/HTTPS_Everywhere"&gt;&amp;ldquo;HTTPS everywhere&amp;rdquo;&lt;/a&gt; with &lt;a href="https://www.cloudflare.com/"&gt;Cloudflare&lt;/a&gt;. Service workers will only run on sites served over HTTPS (or &lt;code&gt;localhost&lt;/code&gt; for development). If you&amp;rsquo;re considering Cloudflare for SSL, &lt;a href="https://scotthelme.co.uk/tls-conundrum-and-leaving-cloudflare/"&gt;be aware of the drawbacks&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Registration&lt;/strong&gt; Though the Service Worker runs in its own thread outside the context of a webpage, we need to initiate its use from the webpage we&amp;rsquo;re on. So when you hit a page on rossta.net, there&amp;rsquo;s a snippet of JavaScript that checks for browser support and registers a service worker script for the root scope of the website.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// index.js
if(&amp;#39;serviceWorker&amp;#39; in navigator) {
  navigator.serviceWorker.register(&amp;#39;/serviceworker.js&amp;#39;, {
    scope: &amp;#39;/&amp;#39;
  });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Service Worker Script&lt;/strong&gt; The service worker script gets deployed to &lt;a href="https://rossta.net/serviceworker.js"&gt;https://rossta.net/serviceworker.js&lt;/a&gt; separately from
the concatenated, versioned JavaScript bundles used on the main site.&lt;/p&gt;

&lt;h3&gt;The script&lt;/h3&gt;

&lt;p&gt;For the code in my first service worker script, I followed the strategy outlined by Jeremy Keith&amp;rsquo;s excellent
&lt;a href="https://adactio.com/journal/9775"&gt;My first Service Worker&lt;/a&gt;. He also provided a
generalized version of his script in a &lt;a href="https://gist.github.com/adactio/fbaa3a5952774553f5e7"&gt;service worker gist&lt;/a&gt; that&amp;rsquo;s definitely worth a look.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a general summary of the Service Worker&amp;rsquo;s responsibilities at various stages in its life cycle:&lt;/p&gt;

&lt;p&gt;On &lt;code&gt;install&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Pre-cache&amp;rdquo; any desired resource, primarily for rendering in an offline context&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On &lt;code&gt;activate&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Clean up old cache when activating an update to the Service Worker&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On &lt;code&gt;fetch&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Render HTML from the network while adding it to the local cache for use when offline&lt;/li&gt;
&lt;li&gt;Render JavaScript and CSS assets immediately from cache while updating the cache from the network when possible&lt;/li&gt;
&lt;li&gt;Render an offline page when a visitor can&amp;rsquo;t connect to rossta.net&lt;/li&gt;
&lt;li&gt;Allow normal pass-through network request of non-GET and white-listed resources like Twitter embeds and analytics tracking&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Deploying the service worker&lt;/h3&gt;

&lt;p&gt;Below I describe how I deployed my service worker, but your mileage may vary depending on your own production needs. &lt;a href="https://rossta.net/blog/why-i-ditched-wordpress-for-github.html"&gt;As I&amp;rsquo;ve said before&lt;/a&gt;, this is a static site hosted on Github pages, &lt;a href="/blog/using-webpack-with-middleman.html"&gt;built with Webpack and Middleman&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Setting up Github pages to use Cloudflare was relatively straightforward and has been &lt;a href="https://www.benburwell.com/posts/configuring-cloudflare-universal-ssl/"&gt;well-documented&lt;/a&gt;. I also wanted to make sure &lt;code&gt;serviceworker.js&lt;/code&gt; is always served over HTTPS and that it would not be cached. Since I don&amp;rsquo;t have any control on Github pages over related concerns like redirects and response headers. However, with Cloudflare, I set up Page Rules on Cloudflare to mitigate this issue.&lt;/p&gt;

&lt;p&gt;To ensure content on rossta.net is always loaded over HTTPS, I added a redirect page rule:&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/blog/cloud-flare-page-rules-https-7d097ad2.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m using Webpack to create &lt;a href="https://github.com/rossta/rossta.github.com/blob/09131d3adeb161747fa0cfc624db3ae12ab211fd/webpack.config.js#L12"&gt;separate bundles&lt;/a&gt; and Middleman&amp;rsquo;s &lt;a href="https://middlemanapp.com/advanced/improving_cacheability/"&gt;&lt;code&gt;:asset_hash&lt;/code&gt; extension&lt;/a&gt; to add a digest to each file, similar to the &lt;a href="http://guides.rubyonrails.org/asset_pipeline.html#in-production"&gt;Rails asset pipeline production behavior&lt;/a&gt; to improve the cacheability of CSS and JavaScript assets on rossta.net.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t want either for serviceworker.js: it must be served separately from the main asset bundles and it should not be cached.&lt;/p&gt;

&lt;p&gt;Webpack supports &lt;a href="https://webpack.github.io/docs/configuration.html#multiple-configurations"&gt;multiple configurations&lt;/a&gt;, so I set up my &lt;a href="https://github.com/rossta/rossta.github.com/blob/09131d3adeb161747fa0cfc624db3ae12ab211fd/webpack.config.js#L80"&gt;&lt;code&gt;webpack.config.js&lt;/code&gt;&lt;/a&gt; to use ES2015 transpilation for &lt;code&gt;serviceworker.js&lt;/code&gt; but output to a different destination from the other concatenated script files.&lt;/p&gt;

&lt;p&gt;To make sure Cloudflare does not cache &lt;code&gt;serviceworker.js&lt;/code&gt;, as it would by default for the CDN, I instructed Cloudflare to bypass the cache.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/blog/cloud-flare-page-rules-serviceworker-9f251642.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;Github pages currently adds 10-minute &lt;code&gt;Expires&lt;/code&gt; and &lt;code&gt;Cache-Control&lt;/code&gt; headers to resource requests meaning browsers and proxies may choose to cache &lt;code&gt;serviceworker.js&lt;/code&gt; past an update I&amp;rsquo;ve just deployed. This is a tradeoff I&amp;rsquo;ll have to live with until I move rossta.net to another host.&lt;/p&gt;

&lt;h3&gt;Caching considerations&lt;/h3&gt;

&lt;p&gt;There are some key considerations regarding the browser cache when setting up your first service worker with
an approach like the one &lt;a href="https://adactio.com/journal/9775"&gt;Jeremy Keith&lt;/a&gt; outlines and that I&amp;rsquo;ve used here in
rossta.net. Jeff Posnick, maintainer of Google Chrome&amp;rsquo;s &lt;a href="https://github.com/GoogleChrome/sw-precache"&gt;sw-precache&lt;/a&gt;, highlights some of these points &lt;a href="https://remysharp.com/2016/03/22/the-copy--paste-guide-to-your-first-service-worker"&gt;in a recent comment&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Any of the following would be safe, though they each have certain drawbacks:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Serving all of the local assets with browser caching disabled.&lt;/li&gt;
&lt;li&gt;Cache-busting the requests that are used to populate the SW cache, using the non-cache-busted URL as the SW cache key.&lt;/li&gt;
&lt;li&gt;Explicitly versioning all of your local assets using something like gulp-rev, and then using long-lived browser caching headers.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Some drawbacks of each:&lt;/p&gt;

&lt;p&gt;Approach 1. Means that all requests, even those coming from browsers without SW support, will bypass the browser cache, and that&amp;rsquo;s can be a lot of wasteful traffic.&lt;/p&gt;

&lt;p&gt;Approach 2. Can mean some extra code that makes the simple copy and paste example look a bit more complicated.&lt;/p&gt;

&lt;p&gt;Approach 3. Is a good practice to follow in general, but there&amp;rsquo;s an extra build-time step that you need to introduce, and it only applies to subresources, not URLs used as navigation targets (you&amp;rsquo;d likely just have to serve those bypassing the browser cache completely).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Realize that the browser cache is separate from the local cache used by the
service worker. So, when caching resources in your service worker, you may need
to consider the &amp;ldquo;cache busting&amp;rdquo; strategy for both your service worker and the
browser and &lt;a href="https://github.com/GoogleChrome/css-triggers/issues/14"&gt;how users may be affected when pushing updates to the site&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If browser cache is disabled, then you can happily use your service worker to
cache resources without conflict, albeit, without the obvious benefits of a browser cache.&lt;/p&gt;

&lt;p&gt;In other words, take a moment to consider how your assets may (or may not) be cached by
browsers before &lt;a href="https://remysharp.com/2016/03/22/the-copy--paste-guide-to-your-first-service-worker"&gt;copying and pasting your first service worker&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Onward&lt;/h3&gt;

&lt;p&gt;There&amp;rsquo;s a lot more that can be done with the Service Worker API, but this was a
good start to see some impressive perceived performance improvements, especially when
reloading pages with images and special fonts.&lt;/p&gt;
</content>
  </entry>
</feed>
