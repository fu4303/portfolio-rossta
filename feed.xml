<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rossta.net</title>
  <subtitle>Ross Kaffenberger</subtitle>
  <id>https://rossta.net/</id>
  <link href="https://rossta.net/"/>
  <link href="https://rossta.net/feed.xml" rel="self"/>
  <updated>2018-07-15T00:00:00+00:00</updated>
  <author>
    <name>Ross Kaffenberger</name>
  </author>
  <entry>
    <title>Extracting a data component in Vue</title>
    <link rel="alternate" href="/blog/extracting-a-data-component-in-vue.html"/>
    <id>/blog/extracting-a-data-component-in-vue.html</id>
    <published>2018-07-15T00:00:00+00:00</published>
    <updated>2018-07-15T00:00:00+00:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;Vue components don't have to just be about displaying information and user interaction. In this post, we'll show how to build a component whose main job is to simply fetch data for other components. We'll use props, events, and scoped-slots to tie...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Vue components don&amp;#39;t have to just be about displaying information and user interaction. In this post, we&amp;#39;ll show how to build a component whose main job is to simply fetch data for other components. We&amp;#39;ll use props, events, and scoped-slots to tie the pieces together.&lt;/p&gt;

      &lt;h3 id="the-project" class="title"&gt;
        &lt;a name="the-project" class="anchor" href="#the-project"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        The project
      &lt;/h3&gt;
    
&lt;p&gt;This post is part of ongoing series, &lt;a href="/blog/series/pdf-viewer.html"&gt;Building a PDF Viewer with Vue.js&lt;/a&gt;. The source code for this project is on Github at &lt;a href="https://github.com/rossta/vue-pdfjs-demo"&gt;rossta/vue-pdfjs-demo&lt;/a&gt;. To see the source described in this post, &lt;a href="https://github.com/rossta/vue-pdfjs-demo/tree/tutorial/part-3-renderless-components"&gt;checkout the branch&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here&amp;#39;s the latest &lt;a href="https://rossta.net/vue-pdfjs-demo/"&gt;project demo&lt;/a&gt;.&lt;/p&gt;

      &lt;h3 id="catching-up-from-last-time" class="title"&gt;
        &lt;a name="catching-up-from-last-time" class="anchor" href="#catching-up-from-last-time"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Catching up from last time
      &lt;/h3&gt;
    
&lt;p&gt;So far in &lt;a href="/blog/series/pdf-viewer.html"&gt;this series&lt;/a&gt;, we have built a simple PDF viewer to render the pages of PDF document to &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; elements with Vue. We have also updated our components to fetch and render PDF pages lazily as they are scrolled into the viewport. For the next feature, we want to build a preview pane into the left-hand side of the viewer.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/screenshots/screenshot-pdf-viewer-part-3-28bad22b.jpg" alt="Preview of the preview" /&gt;&lt;/p&gt;

&lt;p&gt;This preview pane will display the entire document (as smaller, clickable thumbnails), be independently-scrollable, and render PDF pages lazily—in other words. In other words, it will behave a lot like our current &lt;code&gt;&amp;lt;PDFDocument&amp;gt;&lt;/code&gt;. First, we&amp;#39;d like to make some of our current code reusable.&lt;/p&gt;

      &lt;h3 id="the-why" class="title"&gt;
        &lt;a name="the-why" class="anchor" href="#the-why"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        The why
      &lt;/h3&gt;
    
&lt;p&gt;The Vue docs provide helpful examples for using &lt;a href="https://vuejs.org/v2/guide/mixins.html"&gt;mixins&lt;/a&gt;, &lt;a href="https://vuejs.org/v2/guide/custom-directive.html"&gt;custom directives&lt;/a&gt;, and more. My preferred approach for sharing component functionality is &lt;em&gt;composition&lt;/em&gt;, which means extracting shared code into separate components. In this post, we&amp;#39;ll be using composition to reuse data fetching.&lt;/p&gt;

&lt;p&gt;Why composition? This topic deserves a separate post. For one, it&amp;#39;s my preference, along the lines of general object-oriented programming advice, for &amp;quot;composition over inheritance&amp;quot;. Practically, in Vue, this means I&amp;#39;d like to think &amp;quot;component-first&amp;quot;, before reaching for mixins or &lt;code&gt;extends&lt;/code&gt; (these are basically forms of inheritance). I also agree with the drawbacks Dan Abramov enumerates in &lt;a href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html"&gt;Mixins Considered Harmful&lt;/a&gt;; though the context for his post is React, most of his points are relevant to Vue as well.&lt;/p&gt;

&lt;p&gt;It&amp;#39;s also worth noting that we&amp;#39;re not currently using &lt;a href="https://vuex.vuejs.org"&gt;Vuex&lt;/a&gt; to manage application state in the project. It may be wise, as an alternative to what&amp;#39;s described in this post, to introduce Vuex to fetch data by dispatching actions and triggering state mutations at the appropriate times. However, at this point, our data flow is fairly straightforward, top-to-bottom, which, in my opinion, favors the component-first approach. It&amp;#39;s also simply a worthy exercise to consider data components.&lt;/p&gt;

      &lt;h3 id="bird-39-s-eye-view" class="title"&gt;
        &lt;a name="bird-39-s-eye-view" class="anchor" href="#bird-39-s-eye-view"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Bird&amp;#39;s eye view
      &lt;/h3&gt;
    
&lt;p&gt;Let&amp;#39;s take a look at where we are and where we want to go. Prior to adding our feature, our component hierarchy looks like the following pseudcode:&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;PDFDocument&amp;gt;
  &amp;lt;PDFPage /&amp;gt;
  &amp;lt;PDFPage /&amp;gt;
  &amp;lt;PDFPage /&amp;gt;
  ...
&amp;lt;/PDFDocument&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For our new preview feature, our preview and document components will live side-by-side.&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;PDFPreview&amp;gt;
  &amp;lt;PDFThumbnail /&amp;gt;
  &amp;lt;PDFThumbnail /&amp;gt;
  &amp;lt;PDFThumbnail /&amp;gt;
  ...
&amp;lt;/PDFPreview&amp;gt;
&amp;lt;PDFDocument&amp;gt;
  &amp;lt;PDFPage /&amp;gt;
  &amp;lt;PDFPage /&amp;gt;
  &amp;lt;PDFPage /&amp;gt;
  ...
&amp;lt;/PDFDocument&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our &lt;code&gt;&amp;lt;PDFPreview&amp;gt;&lt;/code&gt; needs access to the same PDF data as our &lt;code&gt;&amp;lt;PDFDocument&amp;gt;&lt;/code&gt;. While we could reuse the data fetching code we wrote previously as a mixin, there&amp;#39;s a clear problem with that approach. It would mean the components would fetch the same data independently—which is potentially some wasted work.&lt;/p&gt;

&lt;p&gt;While this may be desired for some applications, we&amp;#39;d prefer to only fetch the PDF page data once. To achieve this, we&amp;#39;re going to wrap both the &lt;code&gt;&amp;lt;PDFPreview&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;PDFThumbnail&amp;gt;&lt;/code&gt; in another component, whose only responsibility will be to respond to events to request page data, which it will pass to its children as props. With this approach, there is only one data source shared by the two display components.&lt;/p&gt;

&lt;p&gt;That means our heirarchy will eventually look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;PDFData&amp;gt;
  &amp;lt;PDFPreview&amp;gt;
    ...
  &amp;lt;/PDFPreview&amp;gt;
  &amp;lt;PDFDocument&amp;gt;
    ...
  &amp;lt;/PDFDocument&amp;gt;
&amp;lt;/PDFData&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we&amp;#39;ll take a look at how this data component is constructed and how it will pass data to the child components.&lt;/p&gt;

      &lt;h3 id="extracting-the-data-component" class="title"&gt;
        &lt;a name="extracting-the-data-component" class="anchor" href="#extracting-the-data-component"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Extracting the data component
      &lt;/h3&gt;
    
&lt;p&gt;Currently, the data fetching logic resides in our &lt;code&gt;&amp;lt;PDFDocument&amp;gt;&lt;/code&gt; component. There is a method that encapsulates the logic for &lt;a href="https://github.com/rossta/vue-pdfjs-demo/blob/4be84574ce6837379dd90b4d68194ea19b172734/src/components/PDFDocument.vue#L145"&gt;fetching pages in batches&lt;/a&gt;, &lt;a href="https://github.com/rossta/vue-pdfjs-demo/blob/4be84574ce6837379dd90b4d68194ea19b172734/src/components/PDFDocument.vue#L177"&gt;watchers&lt;/a&gt; for responding to changes in the given &lt;code&gt;url&lt;/code&gt; prop and &lt;code&gt;pdf&lt;/code&gt; proxy object, and relevant &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;computed&lt;/code&gt; properties for maintaining the state of PDF data. You can see &lt;a href="https://rossta.net/blog/building-a-pdf-viewer-with-vue-part-2.html"&gt;the previous post&lt;/a&gt; for more info on the implementation details. We&amp;#39;ll move this functionality to a new &lt;code&gt;&amp;lt;PDFData&amp;gt;&lt;/code&gt; component:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFData.vue

props: {
  url: {
    type: String,
    required: true,
  },
},

data() {
  return {
    pages: undefined,
    pages: [],
    cursor: 0,
    // ...
  };
},

methods: {
  fetchPages() {
    // fetches next batch and appends to this.pages
  },
},

computed: {
  pageCount() {
    return this.pdf ? this.pdf.numPages : 0;
  },
},

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This component will be &amp;quot;renderless&amp;quot;* (almost), meaning it will delegate rendering to its children. We&amp;#39;ll use scoped slots to pass the &lt;code&gt;this.pages&lt;/code&gt; data to the preview and document components. The &lt;code&gt;&amp;lt;PDFData&amp;gt;&lt;/code&gt; needs to nothing about its children, only that it will pass data to its named children, &lt;code&gt;preview&lt;/code&gt; and &lt;code&gt;document&lt;/code&gt;, in its own render function:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFData.vue

render(h) {
  return h(&amp;#39;div&amp;#39;, [
    this.$scopedSlots.preview({
      pages: this.pages,
    }),
    this.$scopedSlots.document({
      pages: this.pages,
    }),
  ]);
},

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*Technically, this component isn&amp;#39;t &amp;quot;renderless&amp;quot;—it inserts an additional &lt;code&gt;div&lt;/code&gt; as a root to its scoped slots children. Otherwise, the error &lt;code&gt;Multiple root nodes returned from render function. Render function should return a single root node.&lt;/code&gt; is raised in the current version of Vue I&amp;#39;m using (&lt;code&gt;2.5.16&lt;/code&gt;). The main point is that we can use components in our component hierarchy that add functionality but handoff display responsibility to its children.&lt;/p&gt;

      &lt;h3 id="communicating-with-the-children" class="title"&gt;
        &lt;a name="communicating-with-the-children" class="anchor" href="#communicating-with-the-children"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Communicating with the children
      &lt;/h3&gt;
    
&lt;p&gt;In the &lt;code&gt;&amp;lt;PDFViewer&amp;gt;&lt;/code&gt; we can use the &lt;code&gt;slot&lt;/code&gt; attribute to render the children in the correct place and &lt;code&gt;slot-scope&lt;/code&gt; to receive the &lt;code&gt;pages&lt;/code&gt; property from the &lt;code&gt;&amp;lt;PDFData&amp;gt;&lt;/code&gt; component. Though we haven&amp;#39;t created the &lt;code&gt;&amp;lt;PDFPreview&amp;gt;&lt;/code&gt; components, here&amp;#39;s our template for the &lt;code&gt;&amp;lt;PDFViewer&amp;gt;&lt;/code&gt; responsible for gluing everything together.&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;!-- src/components/PDFViewer.vue --&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;PDFData&amp;gt;
    &amp;lt;!-- At this point in the tutorial, PDFPreview
    doesn&amp;#39;t exist, but this is where it will go. --&amp;gt;
    &amp;lt;PDFPreview
      slot=&amp;quot;preview&amp;quot;
      slot-scope=&amp;quot;{pages}&amp;quot;
      v-bind=&amp;quot;{pages}&amp;quot;
      /&amp;gt;

    &amp;lt;PDFDocument
      slot=&amp;quot;document&amp;quot;
      slot-scope=&amp;quot;{pages}&amp;quot;
      v-bind=&amp;quot;{pages}&amp;quot;
      /&amp;gt;
  &amp;lt;/PDFData&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To trigger data fetching, the &lt;code&gt;&amp;lt;PDFData&amp;gt;&lt;/code&gt; component will listen for the &lt;code&gt;pages-fetch&lt;/code&gt; event. Since we&amp;#39;re using a render function, we won&amp;#39;t be able to use the template syntax for binding to events. Instead, we&amp;#39;ll attach the event listener using &lt;code&gt;this.$on&lt;/code&gt; in the &lt;code&gt;created&lt;/code&gt; hook:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFData.vue

created() {
  this.$on(&amp;#39;pages-fetch&amp;#39;, this.fetchPages);
},

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need to set up our &lt;code&gt;&amp;lt;PDFDocument&amp;gt;&lt;/code&gt; to communicate with the &lt;code&gt;&amp;lt;PDFData&amp;gt;&lt;/code&gt; component. We update &lt;code&gt;&amp;lt;PDFDocument&lt;/code&gt; to accept &lt;code&gt;pages&lt;/code&gt; as props now that it is now longer responsible for fetching this data. Its &lt;code&gt;fetchPages&lt;/code&gt; method, called when the component mounts or during scrolling, we&amp;#39;ll leave in place but change its implementation (now owned by its parent &lt;code&gt;&amp;lt;PDFData&amp;gt;&lt;/code&gt; component) to simply emit the &lt;code&gt;pages-fetch&lt;/code&gt; event, for which &lt;code&gt;&amp;lt;PDFData&amp;gt;&lt;/code&gt; is listening.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue

props: {
  pages: {
    type: Array,
    required: true,
  },
},

data() {
  return {
    // removed pages and pdf properties
    // ...
  };
},

methods: {
  fetchPages() {
    this.$emit(&amp;#39;pages-fetch&amp;#39;);
  },

  // ...
}
&lt;/code&gt;&lt;/pre&gt;

      &lt;h3 id="wrapping-up" class="title"&gt;
        &lt;a name="wrapping-up" class="anchor" href="#wrapping-up"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Wrapping up
      &lt;/h3&gt;
    
&lt;p&gt;That does it! We&amp;#39;ve extracted data fetching logic completely out of the &lt;code&gt;&amp;lt;PDFDocument&amp;gt;&lt;/code&gt; into the &lt;code&gt;&amp;lt;PDFData&amp;gt;&lt;/code&gt;. Though we have more components now, we&amp;#39;ve avoided the drawbacks of introducing mixins to share behavior. Our new data component will show up separately in the Vue dev tools extensio so our application will be easier to debug if we have issues. The app is also easier to extend so we can now add new functionality, like the preview pane. We also have a nice alternative for the time being to introducing a new depenendency, Vuex, to managing poart of application state.&lt;/p&gt;

&lt;p&gt;In the next post, we&amp;#39;ll look at extracting shared behavior so that both our preview and document components can be independently scrollable and either can trigger additional data-fetching when the scrolled to the bottom.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Displaying PDFs lazily with Vue</title>
    <link rel="alternate" href="/blog/building-a-pdf-viewer-with-vue-part-2.html"/>
    <id>/blog/building-a-pdf-viewer-with-vue-part-2.html</id>
    <published>2018-07-07T00:00:00+00:00</published>
    <updated>2018-07-07T00:00:00+00:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;As we demonstrated in the &lt;a href="/blog/building-a-pdf-viewer-with-vue-part-1.html"&gt;previous post&lt;/a&gt;, we can render pages of a PDF to &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; elements using PDF.js and Vue. We were able to use a simple Vue component hierarchy to separate the responsibilities of data fetching and page rendering. We used the...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;As we demonstrated in the &lt;a href="/blog/building-a-pdf-viewer-with-vue-part-1.html"&gt;previous post&lt;/a&gt;, we can render pages of a PDF to &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; elements using PDF.js and Vue. We were able to use a simple Vue component hierarchy to separate the responsibilities of data fetching and page rendering. We used the PDF.js library to fetch the page data and hand off the work of drawing the data onto &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; elements.&lt;/p&gt;

&lt;p&gt;In this post, we&amp;#39;ll add a new requirement: we should only render pages when they are visible, i.e., as they are scrolled into the viewport. Previously, we were rendering all pages eagerly, regardless of whether they were appearing in the client browser. For a large PDF, this could mean valuable resources are used to render many pages offscreen and may never be viewed. Let&amp;#39;s see how we can fix that using Vue.&lt;/p&gt;

&lt;p&gt;The latest source code for this project is on Github at &lt;a href="https://github.com/rossta/vue-pdfjs-demo"&gt;rossta/vue-pdfjs-demo&lt;/a&gt;. To see the version of the project described in this post, &lt;a href="https://github.com/rossta/vue-pdfjs-demo/tree/tutorial/part-2-scrolling"&gt;checkout the &lt;code&gt;part-2-scrolling&lt;/code&gt; branch&lt;/a&gt;. Here&amp;#39;s the &lt;a href="https://rossta.net/vue-pdfjs-demo/"&gt;project demo&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;a href="https://rossta.net/vue-pdfjs-demo/"&gt;&lt;img src="/assets/images/screenshots/screenshot-pdf-viewer-61e237fc.png" alt="Demo" /&gt;&lt;/a&gt;&lt;/p&gt;

      &lt;h3 id="adding-scroll-behavior" class="title"&gt;
        &lt;a name="adding-scroll-behavior" class="anchor" href="#adding-scroll-behavior"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Adding scroll behavior
      &lt;/h3&gt;
    
&lt;p&gt;To review, once a &lt;code&gt;&amp;lt;PDFPage&amp;gt;&lt;/code&gt; component mounts, it calls the &lt;code&gt;page.render&lt;/code&gt; method to draw the PDF data to the &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; element. To defer page rendering, this method should only be called once the &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; element has become visible in the scroll window of the document. We&amp;#39;ll detect visibility of the page by inferring from the scroll boundaries or the parent component, &lt;code&gt;&amp;lt;PDFDocument&amp;gt;&lt;/code&gt; along with the position and dimensions of the child &lt;code&gt;&amp;lt;PDFPage&amp;gt;&lt;/code&gt; components.&lt;/p&gt;

&lt;p&gt;First, a CSS change to make our document scrollable within a relatively positioned parent element.&lt;/p&gt;

&lt;pre&gt;&lt;code class="css"&gt;.pdf-document {
  position: absolute;
  overflow: auto;
  width: 100%;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;&amp;lt;PDFDocument&amp;gt;&lt;/code&gt; will track its visible boundaries using the &lt;code&gt;scrollTop&lt;/code&gt; and &lt;code&gt;clientHeight&lt;/code&gt; properties of its element. We&amp;#39;ll record these boundaries when the component mounts.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue

  data() {
    return {
      scrollTop: 0,
      clientHeight: 0,
      // ...
    };
  },

  methods: {
    updateScrollBounds() {
      const {scrollTop, clientHeight} = this.$el;
      this.scrollTop = scrollTop;
      this.clientHeight = clientHeight;
    },

    // ...
  },

  mounted() {
    this.updateScrollBounds();
  },

  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;scrollTop&lt;/code&gt; according to &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop"&gt;MDN&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An element&amp;#39;s &lt;code&gt;scrollTop&lt;/code&gt; value is a measurement of the distance from the element&amp;#39;s top to its topmost &lt;em&gt;visible&lt;/em&gt; content.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The &lt;code&gt;clientHeight&lt;/code&gt; according to &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight"&gt;MDN&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;clientHeight&lt;/code&gt; read-only property is zero for elements with no CSS or inline layout boxes, otherwise it&amp;#39;s the inner height of an element in pixels, including padding but not the horizontal scrollbar height, border, or margin.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Used together, we can determine what portion of the document is visible to the user.&lt;/p&gt;

      &lt;h3 id="detecting-page-visibility" class="title"&gt;
        &lt;a name="detecting-page-visibility" class="anchor" href="#detecting-page-visibility"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Detecting page visibility
      &lt;/h3&gt;
    
&lt;p&gt;The &lt;code&gt;&amp;lt;PDFPage&amp;gt;&lt;/code&gt; component will track the boundaries of its underlying canvas element, whose dimensions we demonstrated how to calculate in the previous post. As with the document component, we&amp;#39;ll trigger the update of this data property when the page component mounts:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFPage.vue

  data() {
    return {
      elementTop: 0,
      elementHeight: 0,
      // ...
    };
  },

  methods: {
    updateElementBounds() {
      const {offsetTop, offsetHeight} = this.$el;
      this.elementTop = offsetTop;
      this.elementHeight = offsetHeight;
    },

    // ...
  },

  mounted() {
    this.updateElementBounds();
  },

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The element&amp;#39;s &lt;code&gt;offsetTop&lt;/code&gt; property will represent the distance from its top boundary to that of the containing document element &lt;code&gt;div&lt;/code&gt;. Recording its &lt;code&gt;offsetHeight&lt;/code&gt; enables us to determine how far the bottom of the element is from the top of the container.&lt;/p&gt;

&lt;p&gt;Note that the &lt;code&gt;updateElementBounds&lt;/code&gt; and &lt;code&gt;updateScrollBounds&lt;/code&gt; methods are necessary because properties of DOM elements are outside of Vue&amp;#39;s control, i.e., they are not reactive. These methods exist to maintain reactive copies of these properties in Vue and we must trigger them somehow when scrolling or resizing the window so that the changes will propagate.&lt;/p&gt;

&lt;p&gt;Since we can pass the scroll data of the parent component to the child page components as props, we now have what we need to determine if a given page is visible in the scroll area of the document.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFPage.vue

  props: {
    scrollTop: {
      type: Number,
      default: 0
    },
    clientHeight: {
      type: Number,
      default: 0
    },

    // ...
  },

  computed: {
    isElementVisible() {
      const {elementTop, elementBottom, scrollTop, scrollBottom} = this;
      if (!elementBottom) return;

      return elementTop &amp;lt; scrollBottom &amp;amp;&amp;amp; elementBottom &amp;gt; scrollTop;
    },

    elementBottom() {
      return this.elementTop + this.elementHeight;
    },

    scrollBottom() {
      return this.scrollTop + this.clientHeight;
    },
    // ...
  },

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;#39;ll use a computed property &lt;code&gt;isElementVisible&lt;/code&gt; which will update whenever either the &lt;code&gt;scrollBounds&lt;/code&gt; or &lt;code&gt;elementBounds&lt;/code&gt; change. It will simply check if the top of the element is above the bottom of the scroll area (&lt;code&gt;top &amp;lt; scrollBottom&lt;/code&gt;) and the bottom of the element is below the top of the scroll area (&lt;code&gt;bottom &amp;gt; scrollTop&lt;/code&gt;). Note that the &lt;code&gt;y&lt;/code&gt; dimension increases moving down the screen.&lt;/p&gt;

&lt;p&gt;For another approach to detecting visibility in Vue, checkout the &lt;a href="https://github.com/Akryum/vue-observe-visibility"&gt;Akryum/vue-observe-visibility&lt;/a&gt; on Github, which is also available as an NPM package.&lt;/p&gt;

      &lt;h3 id="lazy-rendering-pages" class="title"&gt;
        &lt;a name="lazy-rendering-pages" class="anchor" href="#lazy-rendering-pages"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Lazy rendering pages
      &lt;/h3&gt;
    
&lt;p&gt;Previously, we called the &lt;code&gt;drawPage&lt;/code&gt; method (described in the &lt;a href="https://rossta.net/blog/building-a-pdf-viewer-with-vue-part-1.html#rendering-the-page"&gt;previous post&lt;/a&gt;) when the page component mounted. To make the page render lazily, now we call the method only when the element becomes visible, using a watcher.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFPage.vue

  watch: {
    isElementVisible(isElementVisible) {
      if (isElementVisible) this.drawPage();
    },
  },

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;#39;ve defined &lt;code&gt;drawPage&lt;/code&gt; such that it will only render once if called multiple times.&lt;/p&gt;

&lt;p&gt;In the page components, we can simply watch for changes in scroll boundaries and scale—changes to these props may cause a previously &amp;quot;hidden&amp;quot; page to become visible in the browser.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFPage.vue

  watch: {
    scale: &amp;#39;updateElementBounds&amp;#39;,
    scrollTop: &amp;#39;updateElementBounds&amp;#39;,
    clientHeight: &amp;#39;updateElementBounds&amp;#39;,
    // ...
  },

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the document component, we add listeners to DOM events to trigger the &lt;code&gt;updateScrollBounds&lt;/code&gt; method within the &lt;code&gt;mounted&lt;/code&gt; hook.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue
import throttle from &amp;#39;lodash/throttle&amp;#39;;

export default {
  // ...

  mounted() {
    this.updateScrollBounds();
    const throttledCallback = throttle(this.updateScrollBounds, 300);

    this.$el.addEventListener(&amp;#39;scroll&amp;#39;, throttledCallback, true);
    window.addEventListener(&amp;#39;resize&amp;#39;, throttledCallback, true);

    this.throttledOnResize = throttledCallback;
  },

  beforeDestroy() {
    window.removeEventListener(&amp;#39;resize&amp;#39;, this.throttledOnResize, true);
  },

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A few notes about the implementation above: we use lodash&amp;#39;s &lt;code&gt;throttle&lt;/code&gt; function to ensure our callback is only triggered once every 300ms; otherwise, we&amp;#39;d be making this update potentially dozens of times a second, which for our purposes is unnecessary and could potentially be a performance bottleneck. Since we can attach our &lt;code&gt;throttledCallback&lt;/code&gt; to the &lt;code&gt;&amp;#39;scroll&amp;#39;&lt;/code&gt; event listener of &lt;code&gt;this.$el&lt;/code&gt;, we will also be cleaned up nicely during Vue teardown phase. However, since the &lt;code&gt;&amp;#39;resize&amp;#39;&lt;/code&gt; event will currently only work on the &lt;code&gt;window&lt;/code&gt;, we&amp;#39;ll need to store a reference to the throttled callback as &lt;code&gt;this.throttledOnResize&lt;/code&gt; so we can remove the event listener in Vue&amp;#39;s &lt;code&gt;beforeDestroy&lt;/code&gt; hook.&lt;/p&gt;

&lt;p&gt;For a great explanation of throttling (and its cousin, debouncing) event callbacks, check out &lt;a href="https://css-tricks.com/debouncing-throttling-explained-examples/"&gt;this post on CSS tricks&lt;/a&gt;.&lt;/p&gt;

      &lt;h3 id="adding-quot-infinite-quot-scrolling" class="title"&gt;
        &lt;a name="adding-quot-infinite-quot-scrolling" class="anchor" href="#adding-quot-infinite-quot-scrolling"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Adding &amp;quot;infinite&amp;quot; scrolling
      &lt;/h3&gt;
    
&lt;p&gt;So far we have deferred rendering individual pages to mounted canvas elements until scrolled into view. This allows us to spare CPU cycles at the cost of the brief visual delay as newly visible pages are drawn. However, we are still creating the &lt;code&gt;&amp;lt;PDFPage&amp;gt;&lt;/code&gt; components for every PDF page, regardless of whether they are visible. This results in &lt;code&gt;n - visible&lt;/code&gt; blank &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; elements below the fold.&lt;/p&gt;

&lt;p&gt;We can go one step further. Instead of fetching all the pages up front, we&amp;#39;ll fetch pages in batches as the user scrolls to the bottom of the document. In other words, we&amp;#39;ll implement &amp;quot;infinite scrolling&amp;quot; for PDF pages (though most PDFs of which I&amp;#39;m aware are finite in length). Fetching in batches is a compromise between eagerly loading all pages and fetching one at a time.&lt;/p&gt;

&lt;p&gt;To keep things simple for this tutorial, we&amp;#39;ll add batching directly to the &lt;code&gt;&amp;lt;PDFDocument&amp;gt;&lt;/code&gt; component; in a future post, we&amp;#39;ll extract this information to other parts of our application.&lt;/p&gt;

      &lt;h3 id="batched-fetching" class="title"&gt;
        &lt;a name="batched-fetching" class="anchor" href="#batched-fetching"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Batched fetching
      &lt;/h3&gt;
    
&lt;p&gt;Recall in our document component, we&amp;#39;re tracking a &lt;code&gt;pdf&lt;/code&gt; property and an array of &lt;code&gt;pages&lt;/code&gt;. We now add a &lt;code&gt;cursor&lt;/code&gt; to represent the highest page number in the document we&amp;#39;ve attempted to fetch. We also will track the expected &lt;code&gt;pageCount&lt;/code&gt; using a property provided by the &lt;code&gt;pdf&lt;/code&gt; object.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue
  data() {
    return {
      pdf: undefined,
      pages: [],
      cursor: 0,
      // ...
    };
  },

  computed: {
    pageCount() {
      return this.pdf ? this.pdf.numPages : 0;
    },

    // ...
  },

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also previously added a watcher for the &lt;code&gt;pdf&lt;/code&gt; property to fetch all pages:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue

  watch: {
    pdf(pdf) {
      this.pages = [];
      const promises = range(1, pdf.numPages).
        map(number =&amp;gt; pdf.getPage(number));

      Promise.all(promises).
        then(pages =&amp;gt; (this.pages = pages));
    },
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;#39;ll modify this watcher by extracting a method to fetch pages in batches:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue

  watch: {
    pdf(pdf) {
      this.pages = [];
      this.fetchPages();
    },
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is our new &lt;code&gt;fetchPages&lt;/code&gt; implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue

const BATCH_COUNT = 10;

export default {
  // ...

  methods: {
    fetchPages() {
      if (!this.pdf) return;

      const currentCount = this.pages.length;
      if (this.pageCount &amp;gt; 0 &amp;amp;&amp;amp; currentCount === this.pageCount) return;
      if (this.cursor &amp;gt; currentCount) return;

      const startPage = currentCount + 1; // PDF page numbering starts at 1
      const endPage = Math.min(currentCount + BATCH_COUNT, this.pageCount);
      this.cursor = endPage;

      getPages(this.pdf, startPage, endPage)
        .then((pages) =&amp;gt; {
          this.pages.splice(currentCount, 0, ...pages);
          return this.pages;
        })
        .catch((response) =&amp;gt; {
          this.$emit(&amp;#39;document-errored&amp;#39;);
        });
    },

    // ...
  }

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The added complexity in &lt;code&gt;fetchPages&lt;/code&gt; allows us to request small batches of pages with each subsequent call. The &lt;code&gt;currentCount&lt;/code&gt; represents the total number of pages that have already been fetched. The &lt;code&gt;startPage&lt;/code&gt; is simply the next page number of the next would-be page in the array, and the &lt;code&gt;endPage&lt;/code&gt; of the batch is the lesser of an arbitrarily small batch of pages (&lt;code&gt;BATCH_COUNT&lt;/code&gt;) and the remaining pages. We&amp;#39;re able to insert these pages in the correct location in the tracked pages array with &lt;code&gt;this.pages.splice(currentCount, 0, ...pages)&lt;/code&gt;. We also use the &lt;code&gt;this.cursor&lt;/code&gt; property to track the most recently request &lt;code&gt;endPage&lt;/code&gt; to ensure the same batch is only requested once.&lt;/p&gt;

      &lt;h3 id="why-splice-" class="title"&gt;
        &lt;a name="why-splice-" class="anchor" href="#why-splice-"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Why splice?
      &lt;/h3&gt;
    
&lt;p&gt;You may ask, why not simply add the new pages on to the end of the &lt;code&gt;this.pages&lt;/code&gt; array instead? You could imagine using an expression like &lt;code&gt;this.pages.push.apply(this.pages, pages)&lt;/code&gt; to modify the array in place or replacing the array altogether with &lt;code&gt;this.pages = [...this.pages, ...pages]&lt;/code&gt; or &lt;code&gt;concat&lt;/code&gt;. The reason is that &lt;code&gt;getPages&lt;/code&gt; is asynchronous—it returns a promise that fulfills when all pages in the batch have been fetched. It is safer to assume this method can be called in rapid succession where multiple batch requests may be in flight simultaneously. Using &lt;code&gt;splice&lt;/code&gt; to add new pages at the expected position will ensure our batches are inserted into the &lt;code&gt;this.pages&lt;/code&gt; array in the correct order.&lt;/p&gt;

      &lt;h3 id="finding-the-bottom" class="title"&gt;
        &lt;a name="finding-the-bottom" class="anchor" href="#finding-the-bottom"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Finding the bottom
      &lt;/h3&gt;
    
&lt;p&gt;To determine whether the user has scrolled to the bottom of the last of the fetched pages, we will again lean on properties of &lt;code&gt;this.$el&lt;/code&gt;. We can ask if the sum of the &lt;code&gt;scrollTop&lt;/code&gt; of the document and its visible height, &lt;code&gt;clientHeight&lt;/code&gt;, has equalled its total &lt;code&gt;scrollHeight&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue

  methods: {
    isBottomVisible() {
      const {scrollTop, clientHeight, scrollHeight} = this.$el;
      return scrollTop + clientHeight &amp;gt;= scrollHeight;
    },

    // ...
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;#39;ll call this method during &lt;code&gt;updateScrollBounds&lt;/code&gt; method and record a tracked a true/false property, &lt;code&gt;didReachBottom&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue

  data() {
    return {
      didReachBottom: false,
      // ...
    };
  },

  methods: {
    updateScrollBounds() {
      const {scrollTop, clientHeight} = this.$el;
      this.scrollTop = scrollTop;
      this.clientHeight = clientHeight;
      this.didReachBottom = this.isBottomVisible();
    },

    // ...
  },

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then use a watcher to call &lt;code&gt;fetchPages&lt;/code&gt; if this property flips from &lt;code&gt;false&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;. This watcher would fire continuously in a cycle as the user scrolls to the bottom and more pages are fetched.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue

  watch: {
    didReachBottom(didReachBottom) {
      if (didReachBottom) this.fetchPages();
    },

    // ...
  },

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For another in-depth look at adding infinite scrolling for Vue, check out Chris Nwamba&amp;#39;s &lt;a href="https://scotch.io/tutorials/simple-asynchronous-infinite-scroll-with-vue-watchers"&gt;post on Scotch.io&lt;/a&gt;. There are also a number of packages that abstract infinite scrolling if you&amp;#39;d prefer to lean on open source, including &lt;a href="https://github.com/Akryum/vue-virtual-scroller"&gt;Akryum/vue-virtual-scroller&lt;/a&gt; and &lt;a href="https://github.com/ElemeFE/vue-infinite-scroll"&gt;ElemeFE/vue-infinite-scroll&lt;/a&gt;.&lt;/p&gt;

      &lt;h3 id="wrapping-up" class="title"&gt;
        &lt;a name="wrapping-up" class="anchor" href="#wrapping-up"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Wrapping up
      &lt;/h3&gt;
    
&lt;p&gt;We&amp;#39;ve succeeded in making our documents more lazy; now we can defer both data fetching and page rendering until necessary, potentially improving performance of the initial page load and avoiding waste, especially for large documents.&lt;/p&gt;

&lt;p&gt;We&amp;#39;ve been adding quite a bit of complexity though to our existing &lt;code&gt;&amp;lt;PDFDocument&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;PDFPage&amp;gt;&lt;/code&gt; components; they now both are responsible for making API requests, calculating element boundaries, lazy behavior, etc. Ideally, we&amp;#39;ll want to limit the responsibility of a given component to make our application less resistant to change. In the next post, we&amp;#39;ll refactor our PDF viewer to to separate out data fetching and scrolling behavior into separate &amp;quot;renderless components&amp;quot;. These changes will subsequently allow us to share code and add a new feature: a preview pane.&lt;/p&gt;

&lt;p&gt;And now you&amp;#39;ve reached the bottom of this post!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Rendering PDF pages with PDF.js and Vue</title>
    <link rel="alternate" href="/blog/building-a-pdf-viewer-with-vue-part-1.html"/>
    <id>/blog/building-a-pdf-viewer-with-vue-part-1.html</id>
    <published>2018-06-28T00:00:00+00:00</published>
    <updated>2018-06-28T00:00:00+00:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;I remember a time not too long ago when the possibility of rendering PDFs inline on a web page would have sounded crazy. Then &lt;a href="https://mozilla.github.io/pdf.js/"&gt;PDF.js&lt;/a&gt; came along and changed all that.&lt;/p&gt;

&lt;p&gt;I was recently tasked with just this sort of project and I leveraged PDF.js, &lt;a href="https://vuejs.org/"&gt;Vue&lt;/a&gt;&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;I remember a time not too long ago when the possibility of rendering PDFs inline on a web page would have sounded crazy. Then &lt;a href="https://mozilla.github.io/pdf.js/"&gt;PDF.js&lt;/a&gt; came along and changed all that.&lt;/p&gt;

&lt;p&gt;I was recently tasked with just this sort of project and I leveraged PDF.js, &lt;a href="https://vuejs.org/"&gt;Vue&lt;/a&gt; and &lt;a href="https://webpack.js.org"&gt;Webpack&lt;/a&gt; to put it all together. This post is the first in a series which will demonstrate how I used Vue to render PDF pages to &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; elements. Later we&amp;#39;ll explore conditional rendering and adding paging and zoom controls.&lt;/p&gt;

&lt;p&gt;The latest source code for this project is on Github at &lt;a href="https://github.com/rossta/vue-pdfjs-demo"&gt;rossta/vue-pdfjs-demo&lt;/a&gt;. To see the version of the project described in this post, checkout the &lt;a href="https://github.com/rossta/vue-pdfjs-demo/tree/tutorial/part-1-simple-document"&gt;&lt;code&gt;part-1-simple-document&lt;/code&gt; branch&lt;/a&gt;. Finally, here&amp;#39;s a link to the &lt;a href="https://rossta.net/vue-pdfjs-demo/"&gt;project demo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://rossta.net/vue-pdfjs-demo/"&gt;&lt;img src="/assets/images/screenshots/screenshot-pdf-viewer-61e237fc.png" alt="Demo" /&gt;&lt;/a&gt;&lt;/p&gt;

      &lt;h3 id="similar-projects" class="title"&gt;
        &lt;a name="similar-projects" class="anchor" href="#similar-projects"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Similar projects
      &lt;/h3&gt;
    
&lt;p&gt;Mozilla&amp;#39;s PDF.js package ships with its own web viewer (&lt;a href="https://mozilla.github.io/pdf.js/web/viewer.html"&gt;demo&lt;/a&gt;) For an alternative approach to PDF rendering with Vue, check out the &lt;a href="https://github.com/FranckFreiburger/vue-pdf"&gt;vue-pdf&lt;/a&gt; package.&lt;/p&gt;

      &lt;h3 id="an-incomplete-intro-to-pdf-js" class="title"&gt;
        &lt;a name="an-incomplete-intro-to-pdf-js" class="anchor" href="#an-incomplete-intro-to-pdf-js"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        An incomplete intro to PDF.js
      &lt;/h3&gt;
    
&lt;p&gt;PDF.js is a JavaScript project by Mozilla that makes it easier to parse and render PDFs in HTML. It is comprised of three key pieces: Core, Display, and Viewer.&lt;/p&gt;

&lt;p&gt;The Core layer is the lower level piece that parses and interprets PDFs for use by the other layers. This code is split out into a separate file, &lt;code&gt;pdf.worker.js&lt;/code&gt;, which will run in its own web worker thread in the browser. Since we&amp;#39;re using Webpack, it will handle bundling, fetching, and configuration of the worker script behind the scenes.&lt;/p&gt;

&lt;p&gt;The Viewer layer, as I mentioned earlier, provides a basic user interface for viewing and paging through PDFs in Firefox (or other browsers with included extensions). We won&amp;#39;t be using this piece; in fact, this tutorial could be used as the basis for a Vue.js implementation of alternative viewer.&lt;/p&gt;

&lt;p&gt;Most of our interaction with the PDF.js library will be at the Display layer, which provides the JavaScript API for retrieving and manipulating PDF document and page data. The API relies heavily on Promises, which we&amp;#39;ll be incorporating into our Vue.js components. We&amp;#39;ll also take advantage of dynamic imports to code split our use of PDF.js, since, at least for my purposes, I only want to load the PDF.js library on demand. Keeping it out of the main application Webpack bundle will help keep the initial page load time small.&lt;/p&gt;

      &lt;h3 id="using-pdf-js" class="title"&gt;
        &lt;a name="using-pdf-js" class="anchor" href="#using-pdf-js"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Using PDF.js
      &lt;/h3&gt;
    
&lt;p&gt;Here&amp;#39;s a basic ES6 example of dynamically loading PDF.js to render an entire PDF document (without Vue):&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;import range from &amp;#39;lodash/range&amp;#39;

import(&amp;#39;pdfjs-dist/webpack&amp;#39;).then(pdfjs =&amp;gt; {
  pdfjs
    .getDocument(&amp;#39;wibble.pdf&amp;#39;)
    .then(pdf =&amp;gt; {
      const pagePromises = range(1, pdf.numPages).map(number =&amp;gt; pdf.getPage(number))
      return Promise.all(pagePromises)
    })
    .then(pages =&amp;gt; {
        const scale = 2

        const canvases = pages.forEach(page =&amp;gt; {
          const viewport = page.getViewport(scale)

          // Prepare canvas using PDF page dimensions
          const canvas = document.createElement(&amp;#39;canvas&amp;#39;)
          canvas.height = viewport.height
          canvas.width = viewport.width

          // Render PDF page into canvas context
          const canvasContext = canvas.getContext(&amp;#39;2d&amp;#39;)
          const renderContext = { canvasContext, viewport }
          page.render(renderContext).then(() =&amp;gt; console.log(&amp;#39;Page rendered&amp;#39;))

          document.body.appendChild(canvas)
        })
      },
      error =&amp;gt; console.log(&amp;#39;Error&amp;#39;, error),
    )
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above dynamically imports the PDF.js distribution with &lt;code&gt;import(&amp;#39;pdfjs/dist&amp;#39;)&lt;/code&gt;. Webpack will split the PDF.js code out into its own bundle and load it asynchronously only when that line is executed in the browser. This expression returns a promise that resolves with the PDF.js module when the bundle is successfully loaded and evaluated. With a reference to the modules, &lt;code&gt;pdfjs&lt;/code&gt; we can now exercise the PDF.js document API.&lt;/p&gt;

&lt;p&gt;The expression &lt;code&gt;pdjs.getDocument(&amp;#39;url-to-pdf&amp;#39;)&lt;/code&gt; also returns a promise which resolves when the the document is loaded and parsed by the PDF.js core layer. This promise resolves to an instance of &lt;a href="https://mozilla.github.io/pdf.js/api/draft/PDFDocumentProxy.html"&gt;&lt;code&gt;PDFDocumentProxy&lt;/code&gt;&lt;/a&gt;, which we can use to retrieve additional data from the PDF document. We used the &lt;code&gt;PDFDocumentProxy#numPages&lt;/code&gt; attribute to build a number range of all the pages (using lodash &lt;code&gt;range&lt;/code&gt;) and build an array of promises representing requests for each of the documents pages returned by &lt;code&gt;PDFDocumentProxy#getPage(pageNumber)&lt;/code&gt;. The key here to loading all pages at once is using &lt;code&gt;Promise.all&lt;/code&gt; to resolve when all pages are retrieved as &lt;a href="https://mozilla.github.io/pdf.js/api/draft/PDFPageProxy.html"&gt;PDFPageProxy&lt;/a&gt; objects.&lt;/p&gt;

&lt;p&gt;Finally, for each page object, we create a separate &lt;code&gt;canvas&lt;/code&gt; element and trigger the &lt;code&gt;PDFPageProxy#render&lt;/code&gt; method, which returns another promise and accepts options for a canvas context and viewport. This render method is responsible for drawing the PDF data into the canvas element asynchronously while we append the canvas elements to &lt;code&gt;document.body&lt;/code&gt;.&lt;/p&gt;

      &lt;h3 id="refactoring-to-vue" class="title"&gt;
        &lt;a name="refactoring-to-vue" class="anchor" href="#refactoring-to-vue"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Refactoring to Vue
      &lt;/h3&gt;
    
&lt;p&gt;Our little script works, and for some applications, this may implementaiton may be sufficient. But let&amp;#39;s say we need some interaction, like paging controls, zoom buttons, conditional page fetching and rendering while scrolling, etc. Adding complexity could get unwieldy quickly. For this next stage, we&amp;#39;ll refactor to Vue components, so we can get the benefit of reactivity and make our code more declarative and easier to extend.&lt;/p&gt;

&lt;p&gt;In pseudocode, our component architecture will resemble this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;PDFDocument&amp;gt;
  &amp;lt;PDFPage :number=&amp;quot;1&amp;quot; /&amp;gt;
  &amp;lt;PDFPage :number=&amp;quot;2&amp;quot; /&amp;gt;
  &amp;lt;PDFPage :number=&amp;quot;3&amp;quot; /&amp;gt;
  ...
&amp;lt;/PDFDocument&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

      &lt;h3 id="requirements" class="title"&gt;
        &lt;a name="requirements" class="anchor" href="#requirements"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Requirements
      &lt;/h3&gt;
    
&lt;p&gt;For my project, I used the following npm packages (installed using &lt;code&gt;yarn&lt;/code&gt;).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@vue/cli&lt;/code&gt;: &lt;code&gt;^3.0.0-beta.15&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vue&lt;/code&gt;: &lt;code&gt;^2.5.16&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pdfjs-dist&lt;/code&gt;: &lt;code&gt;^2.0.489&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I would expect it to be straightforward to adapt the code for other relatively recent versions of these packages.&lt;/p&gt;

&lt;aside class="callout panel"&gt;&lt;p&gt;
Since PDF.js will request data via an XMLHTTPRequest in JavaScript, typical crossdomain restrictions apply. For the purposes of this tutorial, we'll assume we have a URL to a PDF that can be retrieved either from our development server or from a server that allows Cross-Origin Resource Sharing (CORS) from our host.
&lt;/p&gt;&lt;/aside&gt;

      &lt;h3 id="fetching-the-pdf" class="title"&gt;
        &lt;a name="fetching-the-pdf" class="anchor" href="#fetching-the-pdf"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Fetching the PDF
      &lt;/h3&gt;
    
&lt;p&gt;Our &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt; component will hard-code default values for a PDF url and a rendering scale which will be passed to a &lt;code&gt;&amp;lt;PDFDocument&amp;gt;&lt;/code&gt; component.&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;!-- src/App.vue --&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;
    &amp;lt;PDFDocument v-bind=&amp;quot;{url, scale}&amp;quot; /&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
  // ...
  data() {
    return {
      url: &amp;#39;https://cdn.filestackcontent.com/5qOCEpKzQldoRsVatUPS&amp;#39;, // a PDF
      scale: 2,
    }
  },
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The document component is responsible for fetching the PDF data through PDF.js and rendering  a &lt;code&gt;&amp;lt;PDFPage&amp;gt;&lt;/code&gt; component for each &lt;code&gt;page&lt;/code&gt; object returned by the API.&lt;/p&gt;

&lt;p&gt;Its &lt;code&gt;data&lt;/code&gt; will track the &lt;code&gt;pdf&lt;/code&gt; object and a list of &lt;code&gt;page&lt;/code&gt; object in &lt;code&gt;pages&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue

export default {
  props: [&amp;#39;url&amp;#39;, &amp;#39;scale&amp;#39;],

  data() {
    return {
      pdf: undefined,
      pages: [],
    };
  },
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the component is mounted, it will fetch the PDF data using the &lt;code&gt;pdfjs.getDocument&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue

export default {
  //...

  created() {
    this.fetchPDF();
  },

  methods: {
    fetchPDF() {
      import(&amp;#39;pdfjs-dist/webpack&amp;#39;).
        then(pdfjs =&amp;gt; pdfjs.getDocument(this.url)).
        then(pdf =&amp;gt; (this.pdf = pdf));
    },
  },
  //...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;#39;ll use a watch callback for the &lt;code&gt;pdf&lt;/code&gt; attribute to fetch all the pages via the &lt;code&gt;pdf.getPage&lt;/code&gt; function provided by PDF.js. Since the return value of &lt;code&gt;getPage&lt;/code&gt; behaves like a promise, we can use &lt;code&gt;Promise.all&lt;/code&gt; to determine when all the &lt;code&gt;page&lt;/code&gt; objects have been fetched and set the resolved collection as the &lt;code&gt;pages&lt;/code&gt; data:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue

import range from &amp;#39;lodash/range&amp;#39;;

export default {
  // ...
  watch: {
    pdf(pdf) {
      this.pages = [];
      const promises = range(1, pdf.numPages).
        map(number =&amp;gt; pdf.getPage(number));

      Promise.all(promises).
        then(pages =&amp;gt; (this.pages = pages));
    },
  },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The template simply renders a &lt;code&gt;&amp;lt;PDFPage&amp;gt;&lt;/code&gt; child component for each &lt;code&gt;page&lt;/code&gt; object. Each page component also needs the &lt;code&gt;scale&lt;/code&gt; prop for rendering the page data to &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;!-- src/components/PDFDocument.vue --&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;pdf-document&amp;quot;&amp;gt;
    &amp;lt;PDFPage
      v-for=&amp;quot;page in pages&amp;quot;
      v-bind=&amp;quot;{page, scale}&amp;quot;
      :key=&amp;quot;page.pageNumber&amp;quot;
    /&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

      &lt;h3 id="setting-up-the-canvas" class="title"&gt;
        &lt;a name="setting-up-the-canvas" class="anchor" href="#setting-up-the-canvas"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Setting up the canvas
      &lt;/h3&gt;
    
&lt;p&gt;Now we can build out the &lt;code&gt;&amp;lt;PDFPage&amp;gt;&lt;/code&gt; element. We&amp;#39;ll simply will use a Vue &lt;code&gt;render&lt;/code&gt; function to create a &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; element with computed attributes, &lt;code&gt;canvasAttrs&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFPage.vue

export default {
  props: [&amp;#39;page&amp;#39;, &amp;#39;scale&amp;#39;],

  render(h) {
    const {canvasAttrs: attrs} = this;
    return h(&amp;#39;canvas&amp;#39;, {attrs});
  },

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To render a PDF to &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; with an acceptable resolution, we can take advantage of a browser property called &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio"&gt;&lt;code&gt;window.devicePixelRatio&lt;/code&gt;&lt;/a&gt;. This value represents the ratio of screen pixels to CSS pixels. Given a hi-resolution display with a &lt;code&gt;devicePixelRatio&lt;/code&gt; of &lt;code&gt;2&lt;/code&gt;, we&amp;#39;d want to give the canvas initial width and height attributes that are two times greater than its corresponding width and height in CSS. Otherwise, rendering our PDF pixels to canvas may appear blurry.&lt;/p&gt;

&lt;p&gt;When the &lt;code&gt;&amp;lt;PDFPage&amp;gt;&lt;/code&gt; component is created, we can access the &lt;code&gt;viewport&lt;/code&gt; property of the &lt;code&gt;page&lt;/code&gt; object, via &lt;code&gt;PDFPageProxy#getViewport&lt;/code&gt;, to obtain the pixel width and height of the PDF. These are the width and height attributes of the &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; element. For the actual size of the &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;, we&amp;#39;ll use CSS attributes.&lt;/p&gt;

&lt;p&gt;Since the &lt;code&gt;scale&lt;/code&gt; prop is reactive and our &lt;code&gt;render&lt;/code&gt; function depends on &lt;code&gt;canvasAttrs&lt;/code&gt;, defining &lt;code&gt;canvasAttrs&lt;/code&gt; as a computed property based off the scale means our PDF pages will automatically re-render when the scale changes. Future iterations will allow to the change &lt;code&gt;scale&lt;/code&gt; prop (using future zoom controls, for example). We&amp;#39;ll simply calculate the width and height via CSS to update the rendered size of the canvas to avoid redrawing the canvas data from the &lt;code&gt;page&lt;/code&gt; object each time. For this, we use a clone of the original viewport, given via the &lt;code&gt;actualSizeViewport&lt;/code&gt; computed property, and the &lt;code&gt;devicePixelRatio&lt;/code&gt; to calculate the target width and height style attributes for the &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here&amp;#39;s the code that puts all that together:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFPage.vue

export default {
  created() {
    // PDFPageProxy#getViewport
    // https://mozilla.github.io/pdf.js/api/draft/PDFPageProxy.html
    this.viewport = this.page.getViewport(this.scale);
  },

  computed: {
    canvasAttrs() {
      let {width, height} = this.viewport;
      [width, height] = [width, height].map(dim =&amp;gt; Math.ceil(dim));

      const style = this.canvasStyle;

      return {
        width,
        height,
        style,
        class: &amp;#39;pdf-page&amp;#39;,
      };
    },

    canvasStyle() {
      const {width: actualSizeWidth, height: actualSizeHeight} = this.actualSizeViewport;
      const pixelRatio = window.devicePixelRatio || 1;
      const [pixelWidth, pixelHeight] = [actualSizeWidth, actualSizeHeight]
        .map(dim =&amp;gt; Math.ceil(dim / pixelRatio));
      return `width: ${pixelWidth}px; height: ${pixelHeight}px;`
    },

    actualSizeViewport() {
      return this.viewport.clone({scale: this.scale});
    },
    //...
  },

  // ...
&lt;/code&gt;&lt;/pre&gt;

      &lt;h3 id="rendering-the-page" class="title"&gt;
        &lt;a name="rendering-the-page" class="anchor" href="#rendering-the-page"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Rendering the page
      &lt;/h3&gt;
    
&lt;p&gt;When the &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; element mounts, we can draw the PDF page data to it using the &lt;code&gt;PDFPageProxy#render&lt;/code&gt; method. It needs context from the &lt;code&gt;viewport&lt;/code&gt; and &lt;code&gt;canvasContext&lt;/code&gt; as arguments. Since that returns a promise, we can be notified when it&amp;#39;s complete.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFPage.vue

export default {
  mounted() {
    this.drawPage();
  },

  methods: {
    drawPage() {
      if (this.renderTask) return;

      const {viewport} = this;
      const canvasContext = this.$el.getContext(&amp;#39;2d&amp;#39;);
      const renderContext = {canvasContext, viewport};

      // PDFPageProxy#render
      // https://mozilla.github.io/pdf.js/api/draft/PDFPageProxy.html
      this.renderTask = this.page.render(renderContext);
      this.renderTask.
        then(() =&amp;gt; this.$emit(&amp;#39;rendered&amp;#39;, this.page));
    },
    // ...
  },
  // ...
&lt;/code&gt;&lt;/pre&gt;

      &lt;h3 id="cleaning-up-after-ourselves" class="title"&gt;
        &lt;a name="cleaning-up-after-ourselves" class="anchor" href="#cleaning-up-after-ourselves"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Cleaning up after ourselves
      &lt;/h3&gt;
    
&lt;p&gt;As we&amp;#39;re working with JavaScript objects that keep state outside of Vue&amp;#39;s control, we should be mindful to call provided teardown methods. The PDF document and page objects provide &lt;code&gt;destroy&lt;/code&gt; methods to be called on teardown, such as, when our render promise fails, the &lt;code&gt;page&lt;/code&gt; object is replaced, or the Vue component itself is destroyed.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFPage.vue

export default {
  beforeDestroy() {
    this.destroyPage(this.page);
  },

  methods: {
    drawPage() {
      // ...
      this.renderTask.
        then(/* */).
        catch(this.destroyRenderTask);
    },

    destroyPage(page) {
      if (!page) return;

      // PDFPageProxy#_destroy
      // https://mozilla.github.io/pdf.js/api/draft/PDFPageProxy.html
      page._destroy();

      // RenderTask#cancel
      // https://mozilla.github.io/pdf.js/api/draft/RenderTask.html
      if (this.renderTask) this.renderTask.cancel();
    },

    destroyRenderTask() {
      if (!this.renderTask) return;

      // RenderTask#cancel
      // https://mozilla.github.io/pdf.js/api/draft/RenderTask.html
      this.renderTask.cancel();
      delete this.renderTask;
    },
  },

  watch: {
    page(page, oldPage) {
      this.destroyPage(oldPage);
    },
  },
};
&lt;/code&gt;&lt;/pre&gt;

      &lt;h3 id="wrapping-up" class="title"&gt;
        &lt;a name="wrapping-up" class="anchor" href="#wrapping-up"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Wrapping up
      &lt;/h3&gt;
    
&lt;p&gt;We&amp;#39;ve now converted our original, imperative PDF rendering script with a declarative Vue component hierarchy. We&amp;#39;ve certainly added a lot of code to make this work, but with working knowledge of Vue, we&amp;#39;ve made it easier to reason about, easier to extend, and easier to add features to give our PDF viewer more functionality.&lt;/p&gt;

&lt;p&gt;In the next post, we&amp;#39;ll look at adding some conditional rendering; since all pages aren&amp;#39;t visible when the document is initially loaded, Vue can help us design a system that only fetches and renders PDF pages when scrolled into view.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Deploying Vue with CircleCI 2.0</title>
    <link rel="alternate" href="/blog/deploying-vue-with-circleci-2.html"/>
    <id>/blog/deploying-vue-with-circleci-2.html</id>
    <published>2018-06-07T00:00:00+00:00</published>
    <updated>2018-06-07T00:00:00+00:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;I recently upgraded my &lt;a href="https://github.com/rossta/connect-four-vue"&gt;Connect Four&lt;/a&gt; Vue.js application to build on CircleCI 2.0 . In my &lt;a href="/blog/deploying-vue-to-amazon-s3-with-circleci.html"&gt;previous post&lt;/a&gt;, I showed how I used continuous integration on CircleCI 1.0 to bundle Vue.js assets and upload them to an S3 bucket configured to serve the application...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;I recently upgraded my &lt;a href="https://github.com/rossta/connect-four-vue"&gt;Connect Four&lt;/a&gt; Vue.js application to build on CircleCI 2.0 . In my &lt;a href="/blog/deploying-vue-to-amazon-s3-with-circleci.html"&gt;previous post&lt;/a&gt;, I showed how I used continuous integration on CircleCI 1.0 to bundle Vue.js assets and upload them to an S3 bucket configured to serve the application as a static website. But now that config is only good for another few months: &lt;a href="https://circleci.com/blog/sunsetting-1-0/"&gt;CircleCI is sunsetting 1.0&lt;/a&gt;. Here&amp;#39;s how I upgraded.&lt;/p&gt;

&lt;p&gt;The basic steps of the build are the same: once I push changes to GitHub, CircleCI will detect those changes and trigger a build. It will bundle the app using the &lt;code&gt;vue-cli&lt;/code&gt;. The assets output from that step will then be uploaded to S3 using the &lt;code&gt;s3deploy&lt;/code&gt; golang package only if the build is running against master.&lt;/p&gt;

      &lt;h3 id="the-old-config" class="title"&gt;
        &lt;a name="the-old-config" class="anchor" href="#the-old-config"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        The old config
      &lt;/h3&gt;
    
&lt;p&gt;For reference, here is the old configuration I had been using to deploy the application on CircleCI 1.0.&lt;/p&gt;

&lt;pre&gt;&lt;code class="yaml"&gt;machine:
  environment:
    CIRCLE_BUILD_DIR: $HOME/$CIRCLE_PROJECT_REPONAME
    PATH: $PATH:$CIRCLE_BUILD_DIR/bin:${HOME}/${CIRCLE_PROJECT_REPONAME}/node_modules/.bin&amp;quot;

  post:
    - mkdir -p $CIRCLE_BUILD_DIR/bin
  node:
    version: 8.9.1

dependencies:
  pre:
    - go get -v github.com/bep/s3deploy
  override:
    - yarn
  cache_directories:
    - ~/.cache/yarn
    - bin

test:
  override:
    - yarn build

deployment:
  s3up:
    branch: master
    commands:
      - s3deploy -source=dist/ -region=us-west-2 -bucket=rossta-connect-four
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CircleCI 2.0 offers a number of features to give developers more control and flexibility. This does mean that configuration is more complex than it was in 1.0. A couple of key improvements include &lt;a href="https://circleci.com/blog/introducing-workflows-on-circleci-2-0/"&gt;workflows&lt;/a&gt; and the ability to run builds Docker containers. We&amp;#39;ll take advantage of both to deploy Vue.js to S3.&lt;/p&gt;

&lt;p&gt;Workflows are useful when you need to split a build up into a number of jobs. Those jobs may have different dependencies, or in some cases, may run in parallel. Since I want to bundle assets on all branches, but only deploy from the primary (&lt;code&gt;master&lt;/code&gt;) branch, it makes sense for me to split my CircleCI 2.0 configuration into two jobs, which I&amp;#39;ll call &lt;code&gt;build&lt;/code&gt; and &lt;code&gt;deploy&lt;/code&gt;. It&amp;#39;s worth noting that, even though these jobs must share resources (the bundled assets), I can configure them to run from different Docker containers; this is necessary because the primary language dependency in the build step is node.js and in the deploy phase, it&amp;#39;s golang.&lt;/p&gt;

      &lt;h3 id="the-build-job" class="title"&gt;
        &lt;a name="the-build-job" class="anchor" href="#the-build-job"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        The build job
      &lt;/h3&gt;
    
&lt;p&gt;Here&amp;#39;s what the build step looks like in my new CircleCI 2.0 config:&lt;/p&gt;

&lt;pre&gt;&lt;code class="yaml"&gt;version: 2
jobs:
  build:
    docker:
      - image: circleci/node:8.11.2
    parallelism: 1
    working_directory: ~/rossta/connect-four-vue
    steps:
      - checkout
      - attach_workspace:
          at: ~/rossta/connect-four-vue
      - restore_cache:
          key: v1-yarn-{{ checksum &amp;quot;yarn.lock&amp;quot; }}
      - run: yarn install
      - save_cache:
          key: v1-yarn-{{ checksum &amp;quot;yarn.lock&amp;quot; }}
          paths:
            - ./node_modules
      - run: yarn build
      - persist_to_workspace:
          root: .
          paths: dist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This job will build from the &lt;code&gt;circleci/node:8.11.2&lt;/code&gt; base Docker image. Though any Docker image can be used, CircleCI-supported images are prepared with tools that are typically needed for most builds. (&lt;a href="https://circleci.com/docs/2.0/circleci-images/"&gt;Here&amp;#39;s a list of pre-built CircleCI Docker images&lt;/a&gt;). Useful entries here include &lt;code&gt;restore_cache&lt;/code&gt; and &lt;code&gt;save_cache&lt;/code&gt;, which together ensure the build preserve previously installed node modules when the &lt;code&gt;yarn.lock&lt;/code&gt; file hasn&amp;#39;t changed. Most importantly, the &lt;code&gt;attach_workspace&lt;/code&gt; and &lt;code&gt;persist_to_workspace&lt;/code&gt; entries allow us to share the build output to the &lt;code&gt;dist/&lt;/code&gt; directory across jobs.&lt;/p&gt;

      &lt;h3 id="the-deploy-job" class="title"&gt;
        &lt;a name="the-deploy-job" class="anchor" href="#the-deploy-job"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        The deploy job
      &lt;/h3&gt;
    
&lt;p&gt;Here&amp;#39;s the configuration for the deploy job used to upload assets to S3.&lt;/p&gt;

&lt;pre&gt;&lt;code class="yaml"&gt;version: 2
jobs:
  # ...
  deploy:
    docker:
      - image: circleci/golang:1.9.6
    parallelism: 1
    working_directory: ~/rossta/connect-four-vue
    steps:
      - checkout
      - attach_workspace:
          at: ~/rossta/connect-four-vue
      - restore_cache:
          key: v1-pkg-cache
      - run: go get -v github.com/bep/s3deploy
      - save_cache:
          key: v1-pkg-cache
          paths:
            - /go/pkg
      - run:
          name: Deploy to S3
          command: |
            s3deploy -source=dist/ -region=us-west-2 -bucket=rossta-connect-four
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the deploy, we need a golang base image to run the &lt;code&gt;s3deploy&lt;/code&gt; command. A key step in this job is the &lt;code&gt;attach_workspace&lt;/code&gt; entry, which will contain the &lt;code&gt;dist/&lt;/code&gt; build output we persisted in the build job. That &lt;code&gt;dist/&lt;/code&gt; directory is the source given to the &lt;code&gt;s3deploy&lt;/code&gt; command. The deploy job also specifies &lt;code&gt;restore_cache&lt;/code&gt; and &lt;code&gt;save_cache&lt;/code&gt; for the &lt;code&gt;s3deploy&lt;/code&gt; go package.&lt;/p&gt;

&lt;p&gt;One piece not shown in the config file are the AWS credentials needed to upload the assets to S3. The &lt;code&gt;s3deploy&lt;/code&gt; command will implicitly look for the environment variables &lt;code&gt;AWS_ACCESS_KEY_ID&lt;/code&gt; and &lt;code&gt;AWS_SECRET_ACCESS_KEY&lt;/code&gt;. Since I do not want to publish these credentials to Github, I added them through the CircleCI web interface using &lt;a href="https://circleci.com/docs/2.0/env-vars/#setting-an-environment-variable-in-a-project"&gt;these instructions&lt;/a&gt;.&lt;/p&gt;

      &lt;h3 id="the-workflow" class="title"&gt;
        &lt;a name="the-workflow" class="anchor" href="#the-workflow"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        The workflow
      &lt;/h3&gt;
    
&lt;p&gt;Finally, to tie these jobs together to run the build on all branches and only deploy on &lt;code&gt;master&lt;/code&gt;, I&amp;#39;m using a workflow as shown below:&lt;/p&gt;

&lt;pre&gt;&lt;code class="yaml"&gt;version: 2
# ...
workflows:
  version: 2
  build-and-deploy:
    jobs:
      - build
      - deploy:
          requires:
            - build
          filters:
            branches:
              only: master
&lt;/code&gt;&lt;/pre&gt;

      &lt;h3 id="putting-it-all-together" class="title"&gt;
        &lt;a name="putting-it-all-together" class="anchor" href="#putting-it-all-together"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Putting it all together
      &lt;/h3&gt;
    
&lt;p&gt;Here&amp;#39;s the complete configuration for CircleCI 2.0 at the time of this writing, located at &lt;a href="https://github.com/rossta/connect-four-vue/blob/master/.circleci/config.yml"&gt;&lt;code&gt;.circleci/config.yml&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="yaml"&gt;version: 2
jobs:
  build:
    docker:
      - image: circleci/node:8.11.2
    parallelism: 1
    working_directory: ~/rossta/connect-four-vue
    steps:
      - checkout
      - attach_workspace:
          at: ~/rossta/connect-four-vue
      - restore_cache:
          key: v1-yarn-{{ checksum &amp;quot;yarn.lock&amp;quot; }}
      - run: yarn install
      - save_cache:
          key: v1-yarn-{{ checksum &amp;quot;yarn.lock&amp;quot; }}
          paths:
            - ./node_modules
      - run: yarn build
      - persist_to_workspace:
          root: .
          paths: dist

  deploy:
    docker:
      - image: circleci/golang:1.9.6
    parallelism: 1
    working_directory: ~/rossta/connect-four-vue
    steps:
      - checkout
      - attach_workspace:
          at: ~/rossta/connect-four-vue
      - restore_cache:
          key: v1-pkg-cache
      - run: go get -v github.com/bep/s3deploy
      - save_cache:
          key: v1-pkg-cache
          paths:
            - /go/pkg
      - run:
          name: Deploy to S3
          command: |
            s3deploy -source=dist/ -region=us-west-2 -bucket=rossta-connect-four

workflows:
  version: 2
  build-and-deploy:
    jobs:
      - build
      - deploy:
          requires:
            - build
          filters:
            branches:
              only: master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By the way, this blog is also a static website built and published to Github pages via CircleCI. I recently upgraded to its config to 2.0, which you can &lt;a href="https://github.com/rossta/rossta.github.com/blob/develop/.circleci/config.yml"&gt;check out here&lt;/a&gt; if you&amp;#39;re interested. CircleCI 1.0 goes dark at the end of August, 2018, so upgrade your configurations soon!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Deploying a Vue.js website to AWS S3 with CircleCI 1.0</title>
    <link rel="alternate" href="/blog/deploying-vue-to-amazon-s3-with-circleci.html"/>
    <id>/blog/deploying-vue-to-amazon-s3-with-circleci.html</id>
    <published>2018-02-05T00:00:00+00:00</published>
    <updated>2018-02-05T00:00:00+00:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;em&gt;&lt;strong&gt;Update&lt;/strong&gt;: for configuring CircleCI 2.0 to deploy Vue applications to S3, see &lt;a href="https://rossta.net/blog/deploying-vue-with-circleci-2.html"&gt;my follow up post&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In this post, we'll walkthrough how I set up continuous deployment for my &lt;a href="http://connect-four-vue-abcdefg.s3-website-us-west-2.amazonaws.com/"&gt;Vue.js static website&lt;/a&gt;. Every time I &lt;code&gt;git push&lt;/code&gt; to the primary branch of my repository...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;em&gt;&lt;strong&gt;Update&lt;/strong&gt;: for configuring CircleCI 2.0 to deploy Vue applications to S3, see &lt;a href="https://rossta.net/blog/deploying-vue-with-circleci-2.html"&gt;my follow up post&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In this post, we&amp;#39;ll walkthrough how I set up continuous deployment for my &lt;a href="http://connect-four-vue-abcdefg.s3-website-us-west-2.amazonaws.com/"&gt;Vue.js static website&lt;/a&gt;. Every time I &lt;code&gt;git push&lt;/code&gt; to the primary branch of my repository, an automated process will build the project and upload any new files to Amazon S3 with the appropriate caching headers.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;This post is part of an ongoing series on &lt;a href="/series/connect-four.html"&gt;building Connect Four with Vue.js and Phoenix&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Here&amp;#39;s an overview of the tools involved:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a Github (or similar) account&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vue-cli&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;an AWS account&lt;/li&gt;
&lt;li&gt;an S3 bucket set up to host a static website&lt;/li&gt;
&lt;li&gt;AWS credentials for reading and writing the S3 bucket&lt;/li&gt;
&lt;li&gt;a CircleCI account&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;circle.yml&lt;/code&gt; configured to build and deploy the site&lt;/li&gt;
&lt;/ul&gt;

      &lt;h3 id="from-codepen-to-github" class="title"&gt;
        &lt;a name="from-codepen-to-github" class="anchor" href="#from-codepen-to-github"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        From CodePen to Github
      &lt;/h3&gt;
    
&lt;p&gt;Since my version of Connect Four up to this point has been &lt;a href="https://codepen.io/rossta/pen/VydJKG"&gt;built and hosted entirely on CodePen&lt;/a&gt;, my first step was to move the source code to Github. I initialized a new &lt;code&gt;vue-cli&lt;/code&gt; (version 2) using the Webpack template.&lt;/p&gt;

&lt;pre&gt;&lt;code class="shell"&gt;$ yarn global install vue-cli
$ vue init webpack connect-four-vue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the game working and now backed by version control (&lt;a href="https://github.com/rossta/connect-four-vue"&gt;source code&lt;/a&gt;), I was able to bundle a set of static assets suitable for deployment to a provider like S3:&lt;/p&gt;

&lt;pre&gt;&lt;code class="shell"&gt;$ yarn run build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For &lt;code&gt;vue-cli&lt;/code&gt; version 2, this command builds an index file and its associated assets to the &lt;code&gt;dist/&lt;/code&gt; directory. This will be important when we set up the build for continuous deployment.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;For users of &lt;code&gt;vue-cli&lt;/code&gt; version 3, the above command would be simply &lt;code&gt;yarn build&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;aside class="callout panel"&gt;
&lt;p&gt;
Though there are big changes coming to &lt;i&gt;vue-cli&lt;/i&gt; in version 3, it's still in alpha and the documentation is &lt;a href="https://github.com/vuejs/vue-cli/tree/2c61d236d77dfcb22b4560afe4c957ddf45b4337/docs"&gt;still WIP&lt;/a&gt; as of this writing. Though the commands for initializing and building a Vue project may differ in v3, the workflow described in this post still applies.
&lt;/p&gt;
&lt;/aside&gt;

      &lt;h3 id="the-host-with-the-most" class="title"&gt;
        &lt;a name="the-host-with-the-most" class="anchor" href="#the-host-with-the-most"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        The host with the most
      &lt;/h3&gt;
    
&lt;p&gt;To host on Amazon S3, I needed an S3 bucket with permissions to make its contents available to the public for static website hosting. This can be done from the &lt;a href="https://aws.amazon.com"&gt;AWS console&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/blog/connect-four/s3/aws-create-bucket-767a39de.jpg" alt="Aws create bucket" /&gt;&lt;/p&gt;

&lt;p&gt;On the &lt;strong&gt;Properties&lt;/strong&gt; pane on the bucket management page, I enabled &lt;em&gt;Static Website Hosting&lt;/em&gt; and entered &lt;code&gt;index.html&lt;/code&gt; as the name of the index document to match the output of the Vue build.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/blog/connect-four/s3/aws-static-website-properties-03528fa5.jpg" alt="Aws static website properties" /&gt;&lt;/p&gt;

&lt;p&gt;This screen also reveals the public endpoint for the S3 bucket index page, which is what we&amp;#39;ll need to navigate to our deployed site in the browser. The endpoint may be something like &lt;strong&gt;&lt;a href="http://bucket-name.s3-website-region-name.amazonaws.com"&gt;http://bucket-name.s3-website-region-name.amazonaws.com&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;On the &lt;strong&gt;Permissions&lt;/strong&gt; tab, I added a bucket policy to provide public read permissions to everything in the bucket.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/blog/connect-four/s3/aws-static-website-policy-10243aae.jpg" alt="Aws static website policy" /&gt;&lt;/p&gt;

&lt;p&gt;The  AWS docs recommend the following policy for static website hosting. If setting this up for your own bucket, be sure to replace &lt;code&gt;bucket-name&lt;/code&gt; in the &lt;em&gt;Resource&lt;/em&gt; string with your bucket name:&lt;/p&gt;

&lt;pre&gt;&lt;code class="json"&gt;{
    &amp;quot;Version&amp;quot;: &amp;quot;2012-10-17&amp;quot;,
    &amp;quot;Statement&amp;quot;: [
        {
            &amp;quot;Sid&amp;quot;: &amp;quot;PublicReadForGetBucketObjects&amp;quot;,
            &amp;quot;Effect&amp;quot;: &amp;quot;Allow&amp;quot;,
            &amp;quot;Principal&amp;quot;: &amp;quot;*&amp;quot;,
            &amp;quot;Action&amp;quot;: &amp;quot;s3:GetObject&amp;quot;,
            &amp;quot;Resource&amp;quot;: &amp;quot;arn:aws:s3:::bucket-name/*&amp;quot;
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more information on setting up static websites on Amazon S3, check out Kyle Galbraith&amp;#39;s &lt;a href="https://medium.freecodecamp.org/how-to-host-a-website-on-s3-without-getting-lost-in-the-sea-e2b82aa6cd38"&gt;How to host a website on S3 with getting lost in the sea&lt;/a&gt;, which also touches on costs and custom domain setup. Connor Leech wrote a nice post on &lt;a href="https://medium.com/@connorleech/host-a-vue-js-website-on-amazon-s3-for-the-best-hosting-solution-ever-%EF%B8%8F-eee2a28b2506"&gt;hosting a Vue.js website on Amazon S3&lt;/a&gt; with manual file upload, which I used as my starting point. The AWS documentation provides a &lt;a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html"&gt;general walkthrough&lt;/a&gt; as well.&lt;/p&gt;

      &lt;h3 id="automatic-for-the-people" class="title"&gt;
        &lt;a name="automatic-for-the-people" class="anchor" href="#automatic-for-the-people"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Automatic for the people
      &lt;/h3&gt;
    
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Update&lt;/strong&gt;: for configuring CircleCI 2.0 to deploy Vue applications to S3, see &lt;a href="https://rossta.net/blog/deploying-vue-with-circleci-2.html"&gt;my follow up post&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;For continuous deployment, I chose CircleCI 1.0 since I&amp;#39;m most familiar with its configuration options and it&amp;#39;s currently free for my needs.&lt;/p&gt;

&lt;p&gt;With my Github account linked to my CircleCI, I added my Connect Four Github project to CircleCI from the &lt;em&gt;Projects&lt;/em&gt; tab in the CircleCI dashboard.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/blog/connect-four/s3/circle-add-projects-922272d9.jpg" alt="Circle add projects" /&gt;&lt;/p&gt;

&lt;p&gt;I also added a &lt;code&gt;circle.yml&lt;/code&gt; file to my project similar to the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class="yaml"&gt;machine:
  environment:
    CIRCLE_BUILD_DIR: $HOME/$CIRCLE_PROJECT_REPONAME
    PATH: $PATH:$CIRCLE_BUILD_DIR/bin:${HOME}/${CIRCLE_PROJECT_REPONAME}/node_modules/.bin&amp;quot;

  post:
    - mkdir -p $CIRCLE_BUILD_DIR/bin
  node:
    version: 8.9.1

dependencies:
  pre:
    - go get -v github.com/bep/s3deploy
  override:
    - yarn
  cache_directories:
    - ~/.cache/yarn
    - bin

test:
  override
    - yarn run build

deployment:
  s3up:
    branch: master
    commands:
      - s3deploy -source=dist/ -region=us-west-2 -bucket=connect-four-abcdefg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The configuration above will do several things on each &lt;code&gt;git push&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;install npm dependencies with &lt;code&gt;yarn&lt;/code&gt; and fetch the binary, &lt;code&gt;s3deploy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;build the project with &lt;code&gt;yarn run build&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;sync build files to my S3 bucket with &lt;code&gt;s3deploy&lt;/code&gt; (only on the &lt;code&gt;develop&lt;/code&gt; branch)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that the &lt;code&gt;s3deploy&lt;/code&gt; command receives a &lt;code&gt;-source=dist/&lt;/code&gt; option to indicate that only files output by the build step will be synced with S3.&lt;/p&gt;

&lt;p&gt;I like &lt;code&gt;s3deploy&lt;/code&gt; for its simplicity and speed (it&amp;#39;s written in Go). It will only upload new files or files that have changed. It also provides advanced configuration to fine tune response behavior on sets of files by route through a separate &lt;code&gt;.s3deploy.yml&lt;/code&gt; file. Here&amp;#39;s what I used to add long-term caching and gzipping for static assets in my bucket:&lt;/p&gt;

&lt;pre&gt;&lt;code class="yaml"&gt;routes:
    - route: &amp;quot;^.+\\.(js|css|svg|ttf)$&amp;quot;
      #  cache static assets for 20 years
      headers:
         Cache-Control: &amp;quot;max-age=630720000, no-transform, public&amp;quot;
      gzip: true
    - route: &amp;quot;^.+\\.(png|jpg)$&amp;quot;
      headers:
         Cache-Control: &amp;quot;max-age=630720000, no-transform, public&amp;quot;
      gzip: true
    - route: &amp;quot;^.+\\.(html|xml|json|js)$&amp;quot;
      gzip: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See the &lt;a href="https://github.com/bep/s3deploy"&gt;&lt;code&gt;s3deploy&lt;/code&gt; project page&lt;/a&gt; for more information on configuration options.&lt;/p&gt;

      &lt;h3 id="permissions-please" class="title"&gt;
        &lt;a name="permissions-please" class="anchor" href="#permissions-please"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Permissions please
      &lt;/h3&gt;
    
&lt;p&gt;Almost done! To give the &lt;code&gt;s3deploy&lt;/code&gt; command permissionsto add and modify files in my S3 bucket, I needed a set of AWS credentials linked to another AWS authorization policy. To do this, I created a new Amazon IAM user for programmatic access in the Security Credentials panel on AWS.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/blog/connect-four/s3/aws-add-user-1-2b33e2f3.jpg" alt="Aws add user 1" /&gt;&lt;/p&gt;

&lt;p&gt;I added this user to a security group with the following policy:&lt;/p&gt;

&lt;pre&gt;&lt;code class="json"&gt;{
   &amp;quot;Version&amp;quot;: &amp;quot;2012-10-17&amp;quot;,
   &amp;quot;Statement&amp;quot;:[
      {
         &amp;quot;Effect&amp;quot;:&amp;quot;Allow&amp;quot;,
         &amp;quot;Action&amp;quot;:[
            &amp;quot;s3:ListBucket&amp;quot;,
            &amp;quot;s3:GetBucketLocation&amp;quot;
         ],
         &amp;quot;Resource&amp;quot;:&amp;quot;arn:aws:s3:::&amp;lt;bucketname&amp;gt;&amp;quot;
      },
      {
         &amp;quot;Effect&amp;quot;:&amp;quot;Allow&amp;quot;,
         &amp;quot;Action&amp;quot;:[
            &amp;quot;s3:PutObject&amp;quot;,
            &amp;quot;s3:PutObjectAcl&amp;quot;,
            &amp;quot;s3:DeleteObject&amp;quot;
         ],
         &amp;quot;Resource&amp;quot;:&amp;quot;arn:aws:s3:::&amp;lt;bucketname&amp;gt;/*&amp;quot;
      }
   ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: don&amp;#39;t confuse this policy with your static website hosting policy!&lt;/p&gt;

&lt;p&gt;With my new IAM user, a fresh set of credentials, an AWS access key id and secret access key, are now available to control my S3 bucket programmatically.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/blog/connect-four/s3/aws-add-user-2-5943f1b3.jpg" alt="Aws add user 2" /&gt;&lt;/p&gt;

&lt;p&gt;If you follow these steps, make sure to keep your credentials in a safe place. Anyone with these credentials would be able to modify the contents of your S3 bucket with the permissions we&amp;#39;ve used.&lt;/p&gt;

&lt;aside class="callout panel"&gt;
&lt;p&gt;
Check out &lt;a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_users.html"&gt;the docs&lt;/a&gt; for more information on managing Amazon IAM users.
&lt;/p&gt;
&lt;/aside&gt;

&lt;p&gt;I added these credentials to CircleCI through its project level configuration page in the web UI.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/blog/connect-four/s3/circle-aws-ceee440d.jpg" alt="Circle aws" /&gt;&lt;/p&gt;

&lt;p&gt;This step makes the AWS credentials available to the build environment. It&amp;#39;s a more secure option than adding credentials as plain text in the &lt;code&gt;circle.yml&lt;/code&gt; file.&lt;/p&gt;

      &lt;h3 id="liftoff-" class="title"&gt;
        &lt;a name="liftoff-" class="anchor" href="#liftoff-"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Liftoff!
      &lt;/h3&gt;
    
&lt;p&gt;Now, when we push to Github on our primary branch, the build process on CircleCI will fetch our dependencies, bundle the static assets and compile our Vue codebase to the &lt;code&gt;dist/&lt;/code&gt; directory, which will then be synced to Amazon S3. As long as the build and sync steps succeed, we ensure that the latest code is always in production with minimal fuss from the command line.&lt;/p&gt;

&lt;p&gt;&lt;hr /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Did you like this post?&lt;/em&gt; Please share! Even better, sign up for my newsletter to hear about new posts in my ongoing series on &lt;a href="/blog/basic-connect-four-with-vuejs.html"&gt;building Connect Four with Vue.js and Phoenix&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Finding Four-in-a-Row for the Win</title>
    <link rel="alternate" href="/blog/finding-four-in-a-row-ftw.html"/>
    <id>/blog/finding-four-in-a-row-ftw.html</id>
    <published>2018-01-28T00:00:00+00:00</published>
    <updated>2018-01-28T00:00:00+00:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;With the Connect Four game we created in the &lt;a href="/blog/animating-connect-four-with-vuejs.html"&gt;previous post&lt;/a&gt;, we're able to use &lt;a href="https://vuejs.org/v2/guide/transitions.html"&gt;Vue transitions&lt;/a&gt; to animate checkers dropping into place on the game board. Though we're able to add checkers, we still weren't declaring the winner when four-in-a-row had...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;With the Connect Four game we created in the &lt;a href="/blog/animating-connect-four-with-vuejs.html"&gt;previous post&lt;/a&gt;, we&amp;#39;re able to use &lt;a href="https://vuejs.org/v2/guide/transitions.html"&gt;Vue transitions&lt;/a&gt; to animate checkers dropping into place on the game board. Though we&amp;#39;re able to add checkers, we still weren&amp;#39;t declaring the winner when four-in-a-row had been achieved—kind of the whole point of the game. We&amp;#39;ll tackle that in this post.&lt;/p&gt;

&lt;p&gt;Before we dive in, here&amp;#39;s a pen of the game with the win logic we&amp;#39;ll be describing so you&amp;#39;ll see where we&amp;#39;ll end up:&lt;/p&gt;

&lt;p data-height="529" data-theme-id="light" data-slug-hash="VydJKG" data-default-tab="js,result" data-user="rossta" data-embed-version="2" data-pen-title="Connect Four with Vue.js, SVG: detect winner and animated checkers" class="codepen"&gt;See the Pen &lt;a href="https://codepen.io/rossta/pen/VydJKG/"&gt;Connect Four with Vue.js, SVG: detect winner and animated checkers&lt;/a&gt; by Ross Kaffenberger (&lt;a href="https://codepen.io/rossta"&gt;@rossta&lt;/a&gt;) on &lt;a href="https://codepen.io"&gt;CodePen&lt;/a&gt;.&lt;/p&gt;

&lt;script async src="https://production-assets.codepen.io/assets/embed/ei.js"&gt;&lt;/script&gt;

&lt;p&gt;When a player achieves four-in-a-row, we update the visual elements on the board to indicate the win and provide a &amp;quot;Play again&amp;quot; link to reset the game state.&lt;/p&gt;

      &lt;h2 id="imagining-the-algorithm" class="title"&gt;
        &lt;a name="imagining-the-algorithm" class="anchor" href="#imagining-the-algorithm"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Imagining the algorithm
      &lt;/h2&gt;
    
&lt;p&gt;We want the game logic to evaluate the state of the board after each checker is played and before allowing the next player to drop their checker. If four-in-a-row is found, we&amp;#39;ll want to highlight the winning segment of checkers and declare the winner in the UI. We&amp;#39;ll also want to declare a draw if the board is full and no one has won.&lt;/p&gt;

&lt;p&gt;The basic skeleton of the win algorithm will work as follow:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;check all viable horizonal segments FOR THE WIN. Return the winner OR
check all viable vertical segments FTW. Return the winner OR
check all viable &amp;quot;forward slash&amp;quot; segments FTW. Return the winner OR
check all viable &amp;quot;back slash&amp;quot; segments FTW. Return the winner OR
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We use the word &lt;em&gt;viable&lt;/em&gt; to mean that the segment must contain four &amp;quot;slots&amp;quot; that exist on the game board. In other words, since the game board has seven columns, indexed as 0-6, each row contains only four horizonal segments: 0-3, 1-4, 2-5, 3-6.&lt;/p&gt;

&lt;p&gt;As described, it&amp;#39;s a bit wasteful to check every possible segment in the board. This is especially true at the outset, when few checkers are on the board, or near the end when many segments have already been checked on previous turns. Since we&amp;#39;re checking the board on each drop and we know the position of the last checker played, we can reduce the number of computations by treating the last checker as a focal point. So we update our definition of a &lt;em&gt;viable&lt;/em&gt; segment to mean segments of four on the board that intersect with the last checker played.&lt;/p&gt;

&lt;p&gt;To figure out which segments over lap with the last checker played, we need a few values:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the coordinates of the checker, the &amp;quot;focal point&amp;quot; of our collection of segments&lt;/li&gt;
&lt;li&gt;the minimum viable row value, i.e., the greater of first row value (0) and the value of the farthest numerical segment point to the left (&lt;code&gt;focalRow&lt;/code&gt; - 3)&lt;/li&gt;
&lt;li&gt;the minimum viable column value, i.e., the greater of first col value (0) and the value of the farthest numerical segment ponit from the bottom (&lt;code&gt;focalCol&lt;/code&gt; - 3)&lt;/li&gt;
&lt;li&gt;the maximum viable row value, i.e., the lesser of (&lt;code&gt;focalRow&lt;/code&gt; + 3) and the top row (5)&lt;/li&gt;
&lt;li&gt;the maximum viable column value, i.e., the lesser of (&lt;code&gt;focalCol&lt;/code&gt; + 3) and the last column (6)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given an object &lt;code&gt;lastChecker&lt;/code&gt; of the form &lt;code&gt;{ row, col }&lt;/code&gt;, and the properites &lt;code&gt;rowCount&lt;/code&gt; and &lt;code&gt;colCount&lt;/code&gt; representing the total number of rows and columns respectively, we can determine these values as follows in JavaScript:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;const min = num =&amp;gt; Math.max(num - 3, 0);
const max = (num, max) =&amp;gt; Math.min(num + 3, max);

const { row: focalRow, col: focalCol } = lastChecker;
const minCol = min(focalCol);
const maxCol = max(focalCol, this.colCount-1);
const minRow = min(focalRow);
const maxRow = max(focalRow, this.rowCount-1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The min and max row and column values form the boundaries of the search space, which may be much smaller than the total number of segments on the board, especially when the last checker played is near the edges.&lt;/p&gt;

      &lt;h2 id="checking-the-horizonal-segment" class="title"&gt;
        &lt;a name="checking-the-horizonal-segment" class="anchor" href="#checking-the-horizonal-segment"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Checking the horizonal segment
      &lt;/h2&gt;
    
&lt;p&gt;Using these values, we can select only the segments in the horizontal, vertical, and diagonal intersections with our last played checker. Let&amp;#39;s say the last checker ended up in row 3 and column 2. There are only three horizonal segments we need to check from this position. Here&amp;#39;s a visual:&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/blog/connect-four/check-horizontal-5fa1a3a4.png" alt="Check horizontal" /&gt;&lt;/p&gt;

&lt;p&gt;In the context of our &lt;code&gt;GameContainer&lt;/code&gt; component, here&amp;#39;s one way of iterating through those segments and searching for a winner:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// GameContainer method
checkHorizontalSegments({ focalRow, minCol, maxCol }) {
  for (let row = focalRow, col = minCol; col &amp;lt;= maxCol; col++) {

    // the horizonal segment contains four neighboring coordinates across
    const segment = [[row, col], [row, col+1], [row, col+2], [row, col+3]];

    // this.getChecker returns the checker object { row, col, color } for a given position
    const checkers = segment.map(([row, col]) =&amp;gt; this.getChecker({row, col}));

    // If all colors are valid and match
    if (checkers.reduce((a, b) =&amp;gt; a === b &amp;amp;&amp;amp; a !== EMPTY)) {
      return { color: checkers[0].color, checkers };
    }
  }
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If a win is detected, we&amp;#39;ll record the color and checker positions of the winning segment, which we can later use as data to show the winning state on the game board. Similar functions for checking the vertical and diagonal segments are left as an exercise for the reader... or you may inspect the &lt;a href="https://codepen.io/rossta/pen/VydJKG"&gt;source of the CodePen demo&lt;/a&gt;.&lt;/p&gt;

      &lt;h2 id="updating-the-vue" class="title"&gt;
        &lt;a name="updating-the-vue" class="anchor" href="#updating-the-vue"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Updating the Vue
      &lt;/h2&gt;
    
&lt;p&gt;Putting this altogether, our win algorithm in JavaScript could be as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// GameContainer method
checkForWin(lastChecker) {
  if (!lastChecker) return;

  const min = num =&amp;gt; Math.max(num - 3, 0);
  const max = (num, max) =&amp;gt; Math.min(num + 3, max);

  const { row: focalRow, col: focalCol } = lastChecker;
  const minCol = min(focalCol);
  const maxCol = max(focalCol, this.colCount-1);
  const minRow = min(focalRow);
  const maxRow = max(focalRow, this.rowCount-1);
  const coords = { focalRow, focalCol, minRow, minCol, maxRow, maxCol };

  return this.checkHorizontalSegments(coords) ||
    this.checkVerticalSegments(coords) ||
    this.checkForwardSlashSegments(coords) ||
    this.checkBackwardSlashSegments(coords);
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Recall from the &lt;a href="/blog/animating-connect-four-with-vuejs.html"&gt;previous post&lt;/a&gt;, once a checker is dropped, we emit two custom events, one to create the checker component, &lt;code&gt;&amp;#39;drop&amp;#39;&lt;/code&gt; and a second, &lt;code&gt;&amp;#39;land&amp;#39;&lt;/code&gt;, to indicate the falling checker animation has completed. We&amp;#39;re bubbling these events up to the &lt;code&gt;GameContainer&lt;/code&gt; where we can then check for the win. For the checker drop, we lock the game from additional moves while this processing is carried out and we obtain a reference to the last checker and pass to our &lt;code&gt;checkForWin&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// GameContainer method
drop({ col, row }) {
  if (this.isLocked) return;

  this.isLocked = true;

  const checker = { row, col, color };
  this.checkForWin(checker);

  // update the board
  // switch turns
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the animation completes, the &lt;code&gt;land&lt;/code&gt; callback is triggered on the &lt;code&gt;GameContainer&lt;/code&gt;. Here, we check for the win. If the winner was set by the &lt;code&gt;checkForWin&lt;/code&gt; method, we&amp;#39;ll display the win or unlock the game so the next player can play their turn.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// GameContainer method
land() {
  if (this.winner) {
    this.displayWin(winner);
  } else {
    this.isLocked = false;
  }
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Display win simply sets the game status and sets a flag on each of checkers in the winner segment.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// GameContainer method
displayWin(winner) {
  this.status = &amp;#39;OVER&amp;#39;;
  this.winner.checkers.forEach((checker) =&amp;gt; {
    this.setChecker(checker, {isWinner: true});
  });
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our components can react to this new state by updating various elements of the UI. One approach we&amp;#39;ve taken is to adjust the opacity of the non-winning checkers to accentuate the winners:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// BoardChecker computed
opacity() {
  return (this.status === OVER &amp;amp;&amp;amp; !this.isWinner) ? 0.25 : 1.0;
},
&lt;/code&gt;&lt;/pre&gt;

      &lt;h2 id="checking-for-a-draw" class="title"&gt;
        &lt;a name="checking-for-a-draw" class="anchor" href="#checking-for-a-draw"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Checking for a draw
      &lt;/h2&gt;
    
&lt;p&gt;There&amp;#39;s one case we haven&amp;#39;t yet accounted for—what if no one wins?&lt;/p&gt;

&lt;p&gt;It&amp;#39;s possible for a game to reach a state where all the cells are filled with checkers, but neither player has acheived four-in-a-row. To account for this case, we&amp;#39;ll want to check a draw before checking for the win on each turn. A draw occurs when the number of checkers played equals the number of cells:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// GameContainer method
checkForDraw() {
  this.isDraw = Object.keys(this.checkers).length === this.rowCount * this.colCount;
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;#39;ll update the &lt;code&gt;land&lt;/code&gt; method to short-circuit on a draw:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// GameContainer method
land() {
  if (this.isDraw) return this.displayDraw();

  if (this.winner) {
    this.displayWin(winner);
  } else {
    this.isLocked = false;
  }
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Highlighting the simplicity of our Vue-based reactive system, displaying the draw means simply setting the game state to &lt;code&gt;&amp;#39;OVER&amp;#39;&lt;/code&gt;;&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;displayDraw() {
  this.status = OVER;
},
&lt;/code&gt;&lt;/pre&gt;

      &lt;h2 id="resetting-the-game" class="title"&gt;
        &lt;a name="resetting-the-game" class="anchor" href="#resetting-the-game"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Resetting the game
      &lt;/h2&gt;
    
&lt;p&gt;We can use the game status to display a message to the players and provide a &amp;quot;Play again&amp;quot; link:&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;p v-if=&amp;quot;status === &amp;#39;OVER&amp;#39;&amp;quot;&amp;gt;
  {{ gameOverMessage }}
  &amp;lt;a href=&amp;quot;#&amp;quot; @click=&amp;quot;reset&amp;quot;&amp;gt;Play again&amp;lt;/a&amp;gt;
&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;gameOverMessage&lt;/code&gt; is simply a computed property that switches on the winner state:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// GameContainer computed
gameOverMessage() {
  if (this.winner) {
    return `${titleize(this.winner.color)} wins!`;
  } else {
    return `It&amp;#39;s a draw!`;
  }
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the &amp;quot;Play again&amp;quot; link, we just add a function to reset the game state:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// GameContainer method
reset() {
  this.winner = undefined;
  this.isLocked = false;
  this.status = PLAY;
  this.checkers = {};
},
&lt;/code&gt;&lt;/pre&gt;

      &lt;h2 id="summing-up" class="title"&gt;
        &lt;a name="summing-up" class="anchor" href="#summing-up"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Summing up
      &lt;/h2&gt;
    
&lt;p&gt;We&amp;#39;ve come a long way—we developed a basic algorithm to search the game board for a winner while ensuring we only traverse relevant segments. We also leveraged the simplicity of reactive Vue properties to trigger UI updates. We now have a decent version of Connect Four playable in the browser by individual(s) using the same browser. We&amp;#39;ve also lumped a ton of logic into the game container and have no mechanism to play opponents ver the network. There&amp;#39;s some exciting work to do ahead: we&amp;#39;ll work on introducing additional layers to our frontend design by building on Vue libraries like &lt;code&gt;vue-router&lt;/code&gt; for client-side routing and &lt;code&gt;vuex&lt;/code&gt; for state managment. This will set us up to make the game playable over the network by connecting our game to an Elixir/Phoenix backend.&lt;/p&gt;
</content>
  </entry>
</feed>
