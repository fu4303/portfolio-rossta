<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rossta.net</title>
  <subtitle>Ross Kaffenberger</subtitle>
  <id>https://rossta.net/</id>
  <link href="https://rossta.net/"/>
  <link href="https://rossta.net/feed.xml" rel="self"/>
  <updated>2016-10-21T00:00:00+00:00</updated>
  <author>
    <name>Ross Kaffenberger</name>
  </author>
  <entry>
    <title>Using the Push API with VAPID</title>
    <link rel="alternate" href="/blog/using-the-web-push-api-with-vapid.html"/>
    <id>/blog/using-the-web-push-api-with-vapid.html</id>
    <published>2016-10-21T00:00:00+00:00</published>
    <updated>2016-10-21T00:00:00+00:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;Push messages from mobile and desktop browsers are &lt;a href="http://caniuse.com/#feat=push-api"&gt;now a thing&lt;/a&gt; on the open web.&lt;/p&gt;

&lt;p&gt;Why use the Push API? It allows us to use free, third-party services to notify our users
of events, even when they’re not actively engaged with our site. It’s
not meant...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Push messages from mobile and desktop browsers are &lt;a href="http://caniuse.com/#feat=push-api"&gt;now a thing&lt;/a&gt; on the open web.&lt;/p&gt;

&lt;p&gt;Why use the Push API? It allows us to use free, third-party services to notify our users
of events, even when they&amp;rsquo;re not actively engaged with our site. It&amp;rsquo;s
not meant to replace other methods of pushing data to clients, like
&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API"&gt;WebSockets&lt;/a&gt; or &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events"&gt;Server Sent Events&lt;/a&gt;, but can be useful for sending small, infrequent payloads to keep users engaged. Think: a build has finished successfully, a new post was published, a touchdown was scored.  What&amp;rsquo;s
common place on our smartphones from installed apps is now possible from the browser.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://serviceworker-rails.herokuapp.com/push-simple/"&gt;&lt;img alt="Push message in Chrome" src="/assets/images/screenshots/screenshot-sw-sandbox-push-simple-3-36a167ad.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Though only supportedin Chrome and Firefox on the desktop and in Chrome on Android at the time of this writing, it&amp;rsquo;ll be more widespread soon enough. While I previously &lt;a href="/blog/web-push-notifications-from-rails.html"&gt;wrote about this topic&lt;/a&gt;, there have been recent changes in the Chrome implementation to make the API consistent with Firefox, which we&amp;rsquo;ll describe here.&lt;/p&gt;

&lt;p&gt;In this post, we&amp;rsquo;ll walk through setting up a Ruby or Node.js web application to use the Push API with the &lt;a href="https://tools.ietf.org/html/draft-ietf-webpush-vapid-01"&gt;Voluntary Application server Identification (VAPID)&lt;/a&gt;. Use of VAPID for push requests is optional, but primarily a security benefit. Application servers use VAPID to identify themselves to the push servers so push subscriptions can be properly restricted to their origin app servers. In other words, VAPID could theoretically prevent an attacker from stealing a user &lt;code&gt;PushSubscription&lt;/code&gt; and sending push messages to that recipient from another server. Down the road, push services may be able to provide analytics and debugging assistance for app servers using the VAPID protocol. Another benefit: in Chrome, it is no longer necessary to register our web apps through the Google Developer Console and pass around Google app credentials in web push requests.&lt;/p&gt;

&lt;h2&gt;Overview&lt;/h2&gt;

&lt;p&gt;There are three parties involved in delivering a push message.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Your application server&lt;/li&gt;
&lt;li&gt;Your user&lt;/li&gt;
&lt;li&gt;A push server, e.g., Google or Mozilla&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Before a push message can be delivered with VAPID, a few criteria should be satisfied:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Your application server has generated a set of VAPID keys that will be used to sign Push API requests. This is a one-time step (at least until we decide to reset the keys).&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;manifest.json&lt;/code&gt; file, linked from a page on our website, identifies our app settings.&lt;/li&gt;
&lt;li&gt;In the user&amp;rsquo;s web browser, a service worker script is installed and activated. The &lt;code&gt;pushManager&lt;/code&gt; property of the &lt;code&gt;ServiceWorkerRegistration&lt;/code&gt; is subscribed to push events with our VAPID public key, with creates a &lt;code&gt;subscription&lt;/code&gt; JSON object on the client side.&lt;/li&gt;
&lt;li&gt;Your server makes an API request to a push server (likely using a server-side library) to send a notification with the &lt;code&gt;subscription&lt;/code&gt; obtained from the client and an optional payload (the message).&lt;/li&gt;
&lt;li&gt;Your service worker is set up to receive &lt;code&gt;&amp;#39;push&amp;#39;&lt;/code&gt; events. To trigger a desktop notification, the user has accepted the prompt to receive notifications from our site.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Generating VAPID keys&lt;/h2&gt;

&lt;p&gt;To take advantage of the VAPID protocol, we would generate a public/private VAPID key pair to store on our server to be used for all user subscriptions.&lt;/p&gt;

&lt;p&gt;In Ruby, we can use the &lt;code&gt;webpush&lt;/code&gt; gem to generate a VAPID key that has both a &lt;code&gt;public_key&lt;/code&gt; and &lt;code&gt;private_key&lt;/code&gt; attribute to be saved on the server side.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Gemfile
gem &amp;#39;webpush&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In a Ruby console:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;#39;webpush&amp;#39;

# One-time, on the server
vapid_key = Webpush.generate_key

# Save these in our application server settings
vapid_key.public_key
# =&amp;gt; &amp;quot;BC1mp...HQ=&amp;quot;

vapid_key.private_key
# =&amp;gt; &amp;quot;XhGUr...Kec&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Node.js, we can use the &lt;code&gt;web-push&lt;/code&gt; package:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;npm install web-push --save
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the node REPL:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;const webpush = require(&amp;#39;web-push&amp;#39;);

const vapidKeys = webpush.generateVAPIDKeys()

vapidKeys.publicKey
&amp;#39;BDO0P...eoH&amp;#39;

vapidKeys.privateKey
&amp;#39;3J303..r4I&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The keys returned will both be Base64-encoded byte strings. Only the public key
will be shared, both with the user&amp;rsquo;s browser and the push server as we&amp;rsquo;ll see
later.&lt;/p&gt;

&lt;p&gt;Setting VAPID details is optional in Firefox and appears to be required in Chrome if not using GCM API credentials as &lt;a href="/blog/web-push-notifications-from-rails.html"&gt;described previously&lt;/a&gt;). Since we probably have users from both browsers, we may as well set VAPID details for all.&lt;/p&gt;

&lt;h2&gt;Declaring manifest.json&lt;/h2&gt;

&lt;p&gt;Add a &lt;code&gt;manifest.json&lt;/code&gt; file served at the scope of our app (or above), like at the root to describe our client application for use with the Push API.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;My App&amp;quot;,
    &amp;quot;short_name&amp;quot;: &amp;quot;my-app&amp;quot;,
    &amp;quot;start_url&amp;quot;: &amp;quot;/&amp;quot;,
    &amp;quot;icons&amp;quot;: [
    {
      &amp;quot;src&amp;quot;: &amp;quot;/images/my-push-logo-192x192.png&amp;quot;,
      &amp;quot;sizes&amp;quot;: &amp;quot;192x192&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;image/png&amp;quot;
    }
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Link to it somewhere in the &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; tag:&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;link rel=&amp;quot;manifest&amp;quot; href=&amp;quot;/manifest.json&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Installing a service worker&lt;/h2&gt;

&lt;p&gt;Your application javascript must register a service worker script at an appropriate scope (we&amp;rsquo;re sticking with the root).&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// application.js
// Register the serviceWorker script at /serviceworker.js from our server if supported
if (navigator.serviceWorker) {
  navigator.serviceWorker.register(&amp;#39;/serviceworker.js&amp;#39;)
  .then(function(reg) {
    console.log(&amp;#39;Service worker change, registered the service worker&amp;#39;);
  });
}
// Otherwise, no push notifications :(
else {
  console.error(&amp;#39;Service worker is not supported in this browser&amp;#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For Rails developers, we may want to look at the &lt;a href="https://github.com/rossta/serviceworker-rails"&gt;&lt;code&gt;serviceworker-rails&lt;/code&gt; gem&lt;/a&gt; and this &lt;a href="https://rossta.net/blog/service-worker-on-rails.html"&gt;helpful tutorial&lt;/a&gt; to integrate service worker scripts with the Rails asset pipeline.&lt;/p&gt;

&lt;h2&gt;Subscribing to push notifications&lt;/h2&gt;

&lt;p&gt;The VAPID public key we generated earlier is made available to the client as a &lt;code&gt;Uint8Array&lt;/code&gt;. To do this, one way would be to expose the urlsafe-decoded bytes from Ruby to JavaScript when rendering the HTML template.&lt;/p&gt;

&lt;p&gt;In Ruby, we might embed the key as raw bytes from the application &lt;code&gt;ENV&lt;/code&gt; or some other application settings mechanism into an HTML template with help from the &lt;code&gt;Base64&lt;/code&gt; module in the standard library. Global variables are used here for simplicity.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# server
@decodedVapidPublicKey = Base64.urlsafe_decode64(ENV[&amp;#39;VAPID_PUBLIC_KEY&amp;#39;]).bytes
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;!-- html template --&amp;gt;
&amp;lt;script&amp;gt;
window.vapidPublicKey = new Uint8Array(&amp;lt;%= @decodedVapidPublicKey %&amp;gt;);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Node.js, we could use the &lt;code&gt;urlsafe-base64&lt;/code&gt; package to decode the public key and convert it to raw bytes:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// server
const urlsafeBase64 = require(&amp;#39;urlsafe-base64&amp;#39;);
const decodedVapidPublicKey = urlsafeBase64.decode(process.env.VAPID_PUBLIC_KEY);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;!-- html template --&amp;gt;
&amp;lt;script&amp;gt;
window.vapidPublicKey = new Uint8Array(&amp;lt;%= decodedVapidPublicKey %&amp;gt;);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your application javascript would then use the &lt;code&gt;pushManager&lt;/code&gt; property to subscribe to push notifications, passing the VAPID public key to the subscription settings.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// application.js
// When serviceWorker is supported, installed, and activated,
// subscribe the pushManager property with the vapidPublicKey
navigator.serviceWorker.ready.then((serviceWorkerRegistration) =&amp;gt; {
  serviceWorkerRegistration.pushManager
  .subscribe({
    userVisibleOnly: true,
    applicationServerKey: window.vapidPublicKey
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Triggering a web push notification&lt;/h2&gt;

&lt;p&gt;The web push library we&amp;rsquo;re using on the backend will be responsible for
packaging up the request to the subscription&amp;rsquo;s endpoint and handling encryption, so the user&amp;rsquo;s push subscription must be sent from the client to the application server at some point.&lt;/p&gt;

&lt;p&gt;In the example below, we send the JSON generated subscription object to our backend with a message when a button on the page is clicked.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// application.js
$(&amp;#39;.webpush-button&amp;#39;).on(&amp;#39;click&amp;#39;, (e) =&amp;gt; {
  navigator.serviceWorker.ready
  .then((serviceWorkerRegistration) =&amp;gt; {
    serviceWorkerRegistration.pushManager.getSubscription()
    .then((subscription) =&amp;gt; {
      $.post(&amp;#39;/push&amp;#39;, {
        subscription: subscription.toJSON(),
        message: &amp;#39;You clicked a button!&amp;#39;
      });
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The call to &lt;code&gt;pushManager.getSubscription()&lt;/code&gt; returns a Promise that provides the
&lt;code&gt;PushSubscription&lt;/code&gt; instance with all the information the push service needs to
send a push message to this user&amp;rsquo;s browser. This includes an &lt;code&gt;endpoint&lt;/code&gt;, the URL
on the push server where we&amp;rsquo;ll send the push request, and a pair of &lt;code&gt;keys&lt;/code&gt;
labelled as &lt;code&gt;p256dh&lt;/code&gt; and &lt;code&gt;auth&lt;/code&gt; required to encrypt the push message payload. If interested to learn more about how this encryption works, check out this detailed summary on &lt;a href="https://developers.google.com/web/updates/2016/03/web-push-encryption"&gt;web push payload encryption&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// subscription.toJSON();
{
  endpoint: &amp;quot;https://android.googleapis.com/gcm/send/a-subscription-id&amp;quot;,
  keys: {
    auth: &amp;#39;AEl35...7fG&amp;#39;,
    p256dh: &amp;#39;Fg5t8...2rC&amp;#39;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Imagine a Ruby app endpoint that responds to the request by triggering notification through the &lt;code&gt;webpush&lt;/code&gt; gem. VAPID details include a URL or mailto address for our website and the Base64-encoded public/private VAPID key pair we generated earlier.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# app.rb
post &amp;#39;/push&amp;#39; do
  Webpush.payload_send(
    message: params[:message]
    endpoint: params[:subscription][:endpoint],
    p256dh: params[:subscription][:keys][:p256dh],
    auth: params[:subscription][:keys][:auth],
    ttl: 24 * 60 * 60,
    vapid: {
      subject: &amp;#39;mailto:sender@example.com&amp;#39;,
      public_key: ENV[&amp;#39;VAPID_PUBLIC_KEY&amp;#39;],
      private_key: ENV[&amp;#39;VAPID_PRIVATE_KEY&amp;#39;]
    }
  )
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Node.js, usage of the &lt;code&gt;web-push&lt;/code&gt; package might look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;# index.js
const webpush = require(&amp;#39;web-push&amp;#39;);

// ...

app.post(&amp;#39;/push&amp;#39;, function(request, response) {
  const subscription = request.param(&amp;#39;subscription&amp;#39;);
  const message = request.param(&amp;#39;message&amp;#39;);

  setTimeout(() =&amp;gt; {
    const options = {
      TTL: 24 * 60 * 60,
      vapidDetails: {
        subject: &amp;#39;mailto:sender@example.com&amp;#39;,
        publicKey: process.env.VAPID_PUBLIC_KEY,
        privateKey: process.env.VAPID_PRIVATE_KEY
      },
    }

    webpush.sendNotification(
      subscription,
      message,
      options
    );

  }, 0);

  response.send(&amp;#39;OK&amp;#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Receiving the push event&lt;/h2&gt;

&lt;p&gt;Your &lt;code&gt;/serviceworker.js&lt;/code&gt; script can respond to &lt;code&gt;&amp;#39;push&amp;#39;&lt;/code&gt; events to trigger desktop notifications by calling &lt;code&gt;showNotification&lt;/code&gt; on the &lt;code&gt;registration&lt;/code&gt; property.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// serviceworker.js
// The serviceworker context can respond to &amp;#39;push&amp;#39; events and trigger
// notifications on the registration property
self.addEventListener(&amp;quot;push&amp;quot;, (event) =&amp;gt; {
  let title = (event.data &amp;amp;&amp;amp; event.data.text()) || &amp;quot;Yay a message&amp;quot;;
  let body = &amp;quot;We have received a push message&amp;quot;;
  let tag = &amp;quot;push-simple-demo-notification-tag&amp;quot;;
  let icon = &amp;#39;/assets/my-logo-120x120.png&amp;#39;;

  event.waitUntil(
    self.registration.showNotification(title, { body, icon, tag })
  )
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before the notifications can be displayed, the user must grant permission for &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/notification"&gt;notifications&lt;/a&gt; in a browser prompt, using something like the example below.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// application.js

// Let&amp;#39;s check if the browser supports notifications
if (!(&amp;quot;Notification&amp;quot; in window)) {
  console.error(&amp;quot;This browser does not support desktop notification&amp;quot;);
}

// Let&amp;#39;s check whether notification permissions have already been granted
else if (Notification.permission === &amp;quot;granted&amp;quot;) {
  console.log(&amp;quot;Permission to receive notifications has been granted&amp;quot;);
}

// Otherwise, we need to ask the user for permission
else if (Notification.permission !== &amp;#39;denied&amp;#39;) {
  Notification.requestPermission(function (permission) {
  // If the user accepts, let&amp;#39;s create a notification
    if (permission === &amp;quot;granted&amp;quot;) {
      console.log(&amp;quot;Permission to receive notifications has been granted&amp;quot;);
    }
  });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After all that setup, we should see a browser notification triggered via the Push API.&lt;/p&gt;

&lt;p&gt;As this is still an emerging technology, things are rapidly changing. I&amp;rsquo;d be
interested to hear how things are working out for folks integrating web push
into their web apps.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Fill out Google Forms from the command line</title>
    <link rel="alternate" href="/blog/fill-out-google-forms-from-the-command-line-with-casperjs.html"/>
    <id>/blog/fill-out-google-forms-from-the-command-line-with-casperjs.html</id>
    <published>2016-09-28T00:00:00+00:00</published>
    <updated>2016-09-28T00:00:00+00:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;To give you some idea about what a geek I am, when &lt;a href="https://twitter.com/saronyitbarek"&gt;Saron&lt;/a&gt; asked me to fill out a form to submit blog posts to the &lt;a href="http://www.codenewbie.org/blogs/submit-to-the-codenewbie-newsletter"&gt;CodeNewbie Newsletter&lt;/a&gt;, I thought, “what if I could automate that?” I happen to spend a lot of time in a terminal and thinking about webpage...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;To give you some idea about what a geek I am, when &lt;a href="https://twitter.com/saronyitbarek"&gt;Saron&lt;/a&gt; asked me to fill out a form to submit blog posts to the &lt;a href="http://www.codenewbie.org/blogs/submit-to-the-codenewbie-newsletter"&gt;CodeNewbie Newsletter&lt;/a&gt;, I thought, &amp;ldquo;what if I could automate that?&amp;rdquo; I happen to spend a lot of time in a terminal and thinking about webpage interaction, so&amp;hellip;&lt;/p&gt;

&lt;p&gt;Instead of filling out the form for my last article, I ended up creating a tool to submit a Google Form from the command line. At its core, it&amp;rsquo;s a &lt;a href="http://casperjs.org/"&gt;CasperJS&lt;/a&gt; script available as an npm package. It&amp;rsquo;s called &lt;a href="https://github.com/rossta/form-to-terminal"&gt;&lt;code&gt;form-to-terminal&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To use &lt;code&gt;form-to-terminal&lt;/code&gt;, install it via npm and use the executable &lt;code&gt;ftt&lt;/code&gt; along with a url to a Google Form url:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;# Open a terminal and enter the following commands after the prompt ($):
$ npm install -g form-to-terminal
$ ftt [Google Form Url]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This assumes that you&amp;rsquo;ve already installed &lt;a href="https://nodejs.org/en/download/package-manager/"&gt;nodejs&lt;/a&gt;,  &lt;a href="http://docs.casperjs.org/en/latest/installation.html"&gt;CasperJS&lt;/a&gt;, and its pre-requisites.&lt;/p&gt;

&lt;h2&gt;Casper, the friendly ghost&lt;/h2&gt;

&lt;p&gt;CasperJS is actually just a wrapper around &lt;a href="http://phantomjs.org/"&gt;PhantomJS&lt;/a&gt;, which provides
fully-featured API for interacting with webpages from JavaScript.&lt;/p&gt;

&lt;p&gt;CasperJS makes this scripting more pleasant by providing some syntactic sugar for dealing
with multi-stage interactions and waiting for asynchronous actions. In other
words, I could&amp;rsquo;ve done this with just using PhantomJS, but the code I needed to
write got a whole lot easier by using the CasperJS module on top of it.&lt;/p&gt;

&lt;h2&gt;A closer look&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s look at some sample code. What follows are simplified excerpts from the &lt;code&gt;form-to-terminal&lt;/code&gt; CasperJS script.&lt;/p&gt;

&lt;p&gt;Given a &lt;code&gt;url&lt;/code&gt; to a Google Form, first we &lt;code&gt;start&lt;/code&gt; the webpage interaction, which waits to complete
before moving to the next step.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;var casper = require(&amp;quot;casper&amp;quot;).create();

casper.start(url, function() {
  this.waitForSelector(&amp;quot;form&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To provide the command line interface with some context, the script parses the
page for the form title to display back to the command line.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;var formTitle;

casper.then(function() {
  formTitle = this.evaluate(getFormTitle);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we want to allow human interaction with each input one-by-one, so we parse
the form for the text inputs and their labels so we can ask the user to enter answers back into the
terminal using &lt;code&gt;readLine&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;var system = require(&amp;#39;system&amp;#39;);
var answers;

casper.then(function() {
  var page = this;
  page.echo(&amp;quot;Please fill out &amp;quot; + formTitle);
  page.echo(&amp;quot;----------------&amp;quot; + formTitle.length);
  answers = page.evaluate(getFormInputs)

  answers.filter(function(input) {
    return input.type == &amp;quot;text&amp;quot;;
  }).map(function(input, i) {
    page.echo(&amp;quot;&amp;quot;);
    page.echo(&amp;quot;&amp;quot;+(i+1)+&amp;quot;) &amp;quot;+input.label+&amp;quot;:&amp;quot;);

    input.value = system.stdin.readLine();
t
    return input;
  });
});m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome! Now we just need to pass the &lt;code&gt;answers&lt;/code&gt; back to the webpage and submit
the form. CasperJS makes it easy to do this with additional args to
&lt;code&gt;this.evaluate&lt;/code&gt; in the &lt;code&gt;casper&lt;/code&gt; context:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;casper.then(function() {
  this.evaluate(submitAnswers, {answers: answers});
  page.echo(&amp;quot;&amp;quot;);
  this.echo(&amp;quot;Thanks!&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check out the full &lt;a href="https://github.com/rossta/form-to-terminal/blob/96a4dd8be4b071b5bfb5adb50676a6383c685240/index.js"&gt;CasperJS script&lt;/a&gt; to see how &lt;code&gt;form-to-terminal&lt;/code&gt; interacts with Google Forms in more detail.&lt;/p&gt;

&lt;h2&gt;Command line node&lt;/h2&gt;

&lt;p&gt;I wanted to make this work for others on the command line as an npm package. To
get this to work, we have to understand that &lt;code&gt;casperjs&lt;/code&gt; is already its own
process. To make it work from &lt;code&gt;node&lt;/code&gt;, I needed to spawn the &lt;code&gt;casperjs&lt;/code&gt; while
passing arguments from node. I also needed to make sure that the &lt;code&gt;stdin&lt;/code&gt;
stream is piped from parent (node) to the child (casperjs) process so that we our answers
for the form inputs end up on the web page.&lt;/p&gt;

&lt;p&gt;The key pieces of the command line tool are shown below:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;const child = spawn(&amp;#39;casperjs&amp;#39;, [&amp;#39;index.js&amp;#39;].concat(urls));

child.stdin.setEncoding(&amp;#39;utf-8&amp;#39;);
child.stdout.pipe(process.stdout);
process.stdin.pipe(child.stdin);
child.on(&amp;#39;exit&amp;#39;, process.exit);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;urls&lt;/code&gt; represent the set of Google Form urls with which the CasperJS script
will interact. The line &lt;code&gt;process.stdin.pipe(child.stdin);&lt;/code&gt; ensures the text we
enter on the command line is passed to CasperJS.&lt;/p&gt;

&lt;h2&gt;Going further&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;form-to-terminal&lt;/code&gt; (as of version 1.0.2) only supports Google Forms and only
fully those with text inputs. It&amp;rsquo;s likely quite buggy - for example, it doesn&amp;rsquo;t
currently check that you&amp;rsquo;ve filled out all required fields, nor does it check
for validations errors after you&amp;rsquo;ve submitted the form - but, hey, it&amp;rsquo;s a start.
Go ahead and &lt;a href="https://github.com/rossta/form-to-terminal"&gt;check it out on GitHub&lt;/a&gt; and contribute some improvements!&lt;/p&gt;

&lt;p&gt;CasperJS is a fun tool for automating your workflow and worth a look for
automated testing for web developers.&lt;/p&gt;

&lt;p&gt;Of course, I submitted this post to the CodeNewbie Newsletter using
&lt;code&gt;form-to-terminal&lt;/code&gt; - how meta? It comes with a built-in shortcut to the
CodeNewbie Google Form, so you can try it too:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;$ ftt codenewbie
&lt;/code&gt;&lt;/pre&gt;
</content>
  </entry>
  <entry>
    <title>N+1 is a Rails feature</title>
    <link rel="alternate" href="/blog/n+1-is-a-rails-feature.html"/>
    <id>/blog/n+1-is-a-rails-feature.html</id>
    <published>2016-09-17T00:00:00+00:00</published>
    <updated>2016-09-17T00:00:00+00:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;em&gt;To be clear, N+1 queries in your app are bad. That they are a default behavior
  through due to lazy loading in Rails enables developers to take advantage of Russian doll caching to tune performance - a necessary step to scale Ruby apps.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;One of the...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;em&gt;To be clear, N+1 queries in your app are bad. That they are a default behavior
  through due to lazy loading in Rails enables developers to take advantage of Russian doll caching to tune performance - a necessary step to scale Ruby apps.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;One of the many mantras one learns on the path to &amp;ldquo;Rails enlightenment&amp;rdquo; is:&lt;/p&gt;

&lt;p&gt;BEWARE OF THE N+1 QUERY!&lt;/p&gt;

&lt;p&gt;You might be surprised to hear the conventional advice around fixing the N+1
problem may not always be the best option.&lt;/p&gt;

&lt;h3&gt;Everyone&amp;rsquo;s favorite issue&lt;/h3&gt;

&lt;p&gt;To refresh, an N+1 query occurs when an association for a requested resource leads to N additional separate queries. Here&amp;rsquo;s what an N+1 query looks like in the Rails log where a &lt;code&gt;post&lt;/code&gt; request is followed by N requests for their associated &lt;code&gt;authors&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;Started GET &amp;quot;/posts&amp;quot; for ::1 at 2016-09-18 07:26:15 -0400
Processing by PostsController#index as HTML
  Rendering posts/index.html.erb within layouts/application
  Post Load (2.2ms)  SELECT &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot; ORDER BY &amp;quot;posts&amp;quot;.&amp;quot;published_at&amp;quot; DESC
  Author Load (0.2ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT $2  [[&amp;quot;id&amp;quot;, 90], [&amp;quot;LIMIT&amp;quot;, 1]]
  Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT $2  [[&amp;quot;id&amp;quot;, 82], [&amp;quot;LIMIT&amp;quot;, 1]]
  Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT $2  [[&amp;quot;id&amp;quot;, 83], [&amp;quot;LIMIT&amp;quot;, 1]]
  #...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A quick search for &lt;a href="https://www.google.com/search?q=N%2B1+Rails&amp;amp;oq=N%2B1+Rails&amp;amp;aqs=chrome..69i57j69i60l2.2907j0j1&amp;amp;sourceid=chrome&amp;amp;ie=UTF-8"&gt;N+1 Rails&lt;/a&gt; reveals many posts describing &amp;ldquo;eager loading&amp;rdquo; as state that the &lt;em&gt;silver bullet&lt;/em&gt; to this problem.&lt;/p&gt;

&lt;p&gt;There is actually a gem called &lt;a href="https://github.com/flyerhzm/bullet"&gt;&lt;code&gt;bullet&lt;/code&gt;&lt;/a&gt; that will help resolve your N+1 issues with warnings and suggestions right in your logs to use eager loading where appropriate.&lt;/p&gt;

&lt;p&gt;Typically, this means changing a statement like &lt;code&gt;Post.all&lt;/code&gt; to
&lt;code&gt;Post.all.includes(:author)&lt;/code&gt; to ensure the authors records are loaded in a
separate query or through a complex join (depending on the nature of the
association). This a really useful technique to reduce the number of queries you&amp;rsquo;re making in your Rails apps to improve response times. We may have even wondered why Rails doesn&amp;rsquo;t just eager load for us.&lt;/p&gt;

&lt;h3&gt;When gurus chat&lt;/h3&gt;

&lt;p&gt;Now consider this. Back in April, the author of &lt;a href="https://www.railsspeed.com/"&gt;The Complete Guide to Rails Performance&lt;/a&gt; (check it out, it&amp;rsquo;s awesome), &lt;a href="http://nateberkopec.com/"&gt;Nate Berkopec&lt;/a&gt; spoke with &lt;a href="https://twitter.com/dhh"&gt;DHH&lt;/a&gt; about, ahem, Rails performance. &lt;a href="https://youtu.be/ktZLpjCanvg?t=4m27s"&gt;Not 5 minutes in&lt;/a&gt;, DHH says this:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;N+1 is a feature&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;WTF? But all those queries!&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the rest of what he said about it (emphasis mine):&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;N+1 is a feature, which is usually seen as a bug, right?&lt;/p&gt;

&lt;p&gt;If you have N+1 query it means you&amp;rsquo;re executing
one SQL query per element so if you have 50 emails in an inbox, that&amp;rsquo;d be 50
SQL calls, right? That sounds like a bug. Well in a Russian doll caching setup, it&amp;rsquo;s
not a bug, it&amp;rsquo;s a feature. &lt;b&gt;The beauty of those individual calls are that
they&amp;rsquo;re individually cached&lt;/b&gt;, on their own timeline, and that they&amp;rsquo;re super simple.&lt;/p&gt;

&lt;p&gt;Because the whole way you get around doing N+1 queries is you do joins; you do more complicated queries that take longer to compute, and tax the database harder. If you can simplify those queries so that they&amp;rsquo;re super simple, but there&amp;rsquo;s just more of them, well, you win if and only if you have a caching strategy to support that.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now I don&amp;rsquo;t agree with everything DHH says, but it&amp;rsquo;s an interesting take on the issue. When he says N+1 is a feature, I believe what he really means is that &amp;ldquo;lazy loading&amp;rdquo;, which the ActiveRecord query interface uses by default, along with a proper caching strategy &lt;em&gt;can&lt;/em&gt; be a big advantage. It&amp;rsquo;s this aspect of Rails that has enabled his team to squeeze out sub-100 ms response times at Basecamp.&lt;/p&gt;

&lt;p&gt;ActiveRecord will defer the SQL queries for associations until they are accessed, say, while rendering author details on a list of posts in an index template. N+1 gives you the option to tackle complex pages with many separate
queries that can be wrapped in cache blocks meaning the queries can be skipped
altogether on subsequent requests. On the other hand, using
the broadly-recommended strategy of using &lt;code&gt;includes&lt;/code&gt; to eager-load data means we
incur that additional, potentially complex, query on each page request, regardless of caching strategies.&lt;/p&gt;

&lt;h3&gt;Hrm, example please&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s illustrate DHH&amp;rsquo;s point with a simple example where we have a Rails app
that renders an index of &lt;code&gt;Post&lt;/code&gt; models at &lt;code&gt;/posts&lt;/code&gt;. Each &lt;code&gt;Post&lt;/code&gt; belongs to an
&lt;code&gt;Author&lt;/code&gt; whose details are rendered inline on the index page.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# app/models/post.rb
class Post &amp;lt; ApplicationRecord
  belongs_to :author
end

# app/models/author.rb
class Author &amp;lt; ApplicationRecord
  has_many :posts
end

# app/controllers/posts_controller.rb
class PostsController &amp;lt; ApplicationController
  def index
    @posts = Post.all.order(published_at: :desc)
  end
end

# posts/index.html.erb
&amp;lt;% @posts.each do |post| %&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h2&amp;gt;&amp;lt;%= link_to post.title, post %&amp;gt;&amp;lt;h2&amp;gt;
    &amp;lt;%= render post.author %&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rendering this page will reveal the N+1 query in our Rails log, where each
author is queried individually for each post.&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;# log/development.log

Started GET &amp;quot;/posts&amp;quot; for ::1 at 2016-09-18 07:26:15 -0400
Processing by PostsController#index as HTML
  Rendering posts/index.html.erb within layouts/application
  Post Load (2.2ms)  SELECT &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot; ORDER BY &amp;quot;posts&amp;quot;.&amp;quot;published_at&amp;quot; DESC
  Author Load (0.2ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT $2  [[&amp;quot;id&amp;quot;, 90], [&amp;quot;LIMIT&amp;quot;, 1]]
  Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT $2  [[&amp;quot;id&amp;quot;, 82], [&amp;quot;LIMIT&amp;quot;, 1]]
  Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT $2  [[&amp;quot;id&amp;quot;, 83], [&amp;quot;LIMIT&amp;quot;, 1]]
  #...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The common suggestion to fix this N+1 query is to use &lt;code&gt;includes&lt;/code&gt; to eager load
the author records. Now our N+1 query is reduced to two queries: one for all the
posts and one for all the authors.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class PostsController &amp;lt; ApplicationController
  def index
    @posts = Post.all.order(published_at: :desc).includes(:author) # eager loads
authors
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Started GET &amp;quot;/posts&amp;quot; for ::1 at 2016-09-18 07:29:09 -0400
Processing by PostsController#index as HTML
  Rendering posts/index.html.erb within layouts/application
  Post Load (2.2ms)  SELECT &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot; ORDER BY &amp;quot;posts&amp;quot;.&amp;quot;published_at&amp;quot; DESC
  Author Load (0.4ms)  SELECT &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; IN (90, 82, 83, 89, 81, 84, 85, 86, 87, 88)
  # rendering
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s say we later add fragment caching to the view by wrapping each post in a
cache block:&lt;/p&gt;

&lt;pre&gt;&lt;code class="erb"&gt;&amp;lt;% @posts.each do |post| %&amp;gt;
  &amp;lt;% cache post do %&amp;gt;
    &amp;lt;div&amp;gt;
      &amp;lt;h2&amp;gt;&amp;lt;%= link_to post.title, post %&amp;gt;&amp;lt;h2&amp;gt;
      &amp;lt;%= render post.author %&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;% end %&amp;gt;
&amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We need to enable caching in our development environment to test it out locally. In Rails 5, you can run a simple command to instruct your Rails server to turn on caching:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ bin/rails dev:cache
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Rails 4, you&amp;rsquo;ll need to edit your development configuration yourself:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# config/development.rb
config.action_controller.perform_caching = true
config.cache_store = :memory_store
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With caching enabled and while eager loading authors in our controller, we can see
the fragment caching at work in the Rails log. Since the cache is cold on the
first page render, you&amp;rsquo;ll see alternating Reads that miss and subsequence Writes
for posts and authors.&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;Started GET &amp;quot;/posts&amp;quot; for ::1 at 2016-09-18 08:25:17 -0400
Processing by PostsController#index as HTML
  Rendering posts/index.html.erb within layouts/application
  Post Load (1.3ms)  SELECT  &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot; ORDER BY &amp;quot;posts&amp;quot;.&amp;quot;published_at&amp;quot; DESC LIMIT $1  [[&amp;quot;LIMIT&amp;quot;, 20]]
  Author Load (0.3ms)  SELECT &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; IN (90, 82, 83, 89, 81, 84, 85, 86, 87, 88)
  Read fragment views/posts/679-20160918112202701660/e554fd834425697f04b28a155f7cfd0d (0.1ms)
  Read fragment views/authors/90-20160918113201462920/5c4a91f59546eb97daa8693b93d7c376 (0.0ms)
  Write fragment views/authors/90-20160918113201462920/5c4a91f59546eb97daa8693b93d7c376 (0.1ms)
  Rendered authors/_author.html.erb (4.0ms)
  Write fragment views/posts/679-20160918112202701660/e554fd834425697f04b28a155f7cfd0d (0.3ms)
  Read fragment views/posts/725-20160918120741840748/e554fd834425697f04b28a155f7cfd0d (0.0ms)
  # ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the cache now warm, still using &lt;code&gt;includes&lt;/code&gt; in the controller, we see the
two queries and reads for each post:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;Started GET &amp;quot;/posts&amp;quot; for ::1 at 2016-09-18 08:27:36 -0400
Processing by PostsController#index as HTML
  Rendering posts/index.html.erb within layouts/application
  Post Load (1.5ms)  SELECT  &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot; ORDER BY &amp;quot;posts&amp;quot;.&amp;quot;published_at&amp;quot; DESC LIMIT $1  [[&amp;quot;LIMIT&amp;quot;, 20]]
  Author Load (0.8ms)  SELECT &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; IN (90, 82, 83, 89, 81, 84, 85, 86, 87, 88)
  Read fragment views/posts/679-20160918112202701660/e554fd834425697f04b28a155f7cfd0d (0.1ms)
  Read fragment views/posts/725-20160918120741840748/e554fd834425697f04b28a155f7cfd0d (0.0ms)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that the authors are still queried because we&amp;rsquo;re still eager loading even
though this data won&amp;rsquo;t be used in a warm cache. What a waste! In truth, it doesn&amp;rsquo;t matter much for this simplistic example, but we can imagine an eager-loaded complex query creating a problem for us in a real world use case.&lt;/p&gt;

&lt;p&gt;We can eliminate the wasted authors query by removing the &lt;code&gt;includes&lt;/code&gt; method call from our controller. Now our fully-cached page request requires only one query for the posts:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;Started GET &amp;quot;/posts&amp;quot; for ::1 at 2016-09-18 07:41:09 -0400
Processing by PostsController#index as HTML
  Rendering posts/index.html.erb within layouts/application
  Post Load (2.3ms)  SELECT &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot; ORDER BY &amp;quot;posts&amp;quot;.&amp;quot;published_at&amp;quot; DESC
  Read fragment views/posts/679-20160918112202701660/8c2dcb06ead7afb44586a0d022005ef0 (0.0ms)
  Read fragment views/posts/725-20160918112202826113/8c2dcb06ead7afb44586a0d022005ef0 (0.0ms)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In either case, we want to be sure the post cache is expired if the author
details change. To set this up, we&amp;rsquo;ll need to link the updates of an author to
her posts. A basic change could be to &lt;code&gt;touch&lt;/code&gt; each post when an author is
updated.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Author &amp;lt; ApplicationRecord
  has_many :posts

  after_touch :touch_posts

  def touch_posts
    posts.find_each(&amp;amp;:touch)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we&amp;rsquo;re no longer eager loading authors, only the posts and authors
who&amp;rsquo;ve been updated need to be rewritten to cache. In our &lt;code&gt;development.log&lt;/code&gt;,
we&amp;rsquo;ll see only see the additional queries for associations when an author is updated, triggering cache invalidation on the author and associated posts:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;Started GET &amp;quot;/posts&amp;quot; for ::1 at 2016-09-18 08:07:53 -0400
Processing by PostsController#index as HTML
  Rendering posts/index.html.erb within layouts/application
  Post Load (16.1ms)  SELECT  &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot; ORDER BY &amp;quot;posts&amp;quot;.&amp;quot;published_at&amp;quot; DESC LIMIT $1  [[&amp;quot;LIMIT&amp;quot;, 20]]
  Read fragment views/posts/679-20160918112202701660/e554fd834425697f04b28a155f7cfd0d (0.1ms)
  Read fragment views/posts/725-20160918120741840748/e554fd834425697f04b28a155f7cfd0d (0.0ms)
  Author Load (0.2ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT $2  [[&amp;quot;id&amp;quot;, 82], [&amp;quot;LIMIT&amp;quot;, 1]]
  Read fragment views/authors/82-20160918120741822003/5c4a91f59546eb97daa8693b93d7c376 (0.0ms)
  Write fragment views/authors/82-20160918120741822003/5c4a91f59546eb97daa8693b93d7c376 (0.0ms)
  Rendered authors/_author.html.erb (2.4ms)
  Write fragment views/posts/725-20160918120741840748/e554fd834425697f04b28a155f7cfd0d (0.0ms)
  Read fragment views/posts/541-20160918112202120403/e554fd834425697f04b28a155f7cfd0d (0.0ms)
  Read fragment views/posts/634-20160918112202551250/e554fd834425697f04b28a155f7cfd0d (0.0ms)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Assuming authors and posts aren&amp;rsquo;t updated frequently, leaving the N+1 query in
place along with a proper Russian Doll caching scheme might better for overall app performance than triggering complex eager loading queries on every request.&lt;/p&gt;

&lt;h3&gt;Go forth and measure&lt;/h3&gt;

&lt;p&gt;Eager loading may not always be the best the cure for our N+1 ailments.&lt;/p&gt;

&lt;p&gt;The point of this article isn&amp;rsquo;t to 💩 on eager loading - it&amp;rsquo;s an important
tool to have in your toolbox - but to encourage Rails developers to understand
how lazy loading and N+1 queries allow for Russian Doll caching to be a useful alternative to addressing performance bottlenecks in your Rails applications.&lt;/p&gt;

&lt;p&gt;Keep in mind, Russian doll caching may not be the best approach for your app, especially if that cache is frequently cleared or updated. Caching also means you&amp;rsquo;ll need to think about cache expiry which introduces its own set of challenges. As with any discussion of performance, profiling and benchmarking is a required step to before deciding how to tune your app for performance, so it&amp;rsquo;s up to you to determine the best approach.&lt;/p&gt;

&lt;p&gt;Just beware of silver bullets.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Quiet assets in Rails 5</title>
    <link rel="alternate" href="/blog/quiet-assets-in-rails-5.html"/>
    <id>/blog/quiet-assets-in-rails-5.html</id>
    <published>2016-08-26T00:00:00+00:00</published>
    <updated>2016-08-26T00:00:00+00:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;Recent changes to the &lt;a href="https://github.com/rails/sprockets-rails"&gt;&lt;code&gt;sprockets-rails&lt;/code&gt;&lt;/a&gt; gem now include a configuration option
to silence asset request logging in development.&lt;/p&gt;

&lt;h3&gt;The problem&lt;/h3&gt;

&lt;p&gt;I love logs. Whenever someone comes to me with a Rails problem or we need to
debug something, the first question...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Recent changes to the &lt;a href="https://github.com/rails/sprockets-rails"&gt;&lt;code&gt;sprockets-rails&lt;/code&gt;&lt;/a&gt; gem now include a configuration option
to silence asset request logging in development.&lt;/p&gt;

&lt;h3&gt;The problem&lt;/h3&gt;

&lt;p&gt;I love logs. Whenever someone comes to me with a Rails problem or we need to
debug something, the first question I&amp;rsquo;m thinking is, &amp;ldquo;What do the logs say?&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;That said, sometimes Rails logs more info than we need. By default, Rails will record the web requests for each asset in development. Each page load could incur several to many additional requests for JavaScript, CSS, and images, potentially drowning your &lt;code&gt;STDOUT&lt;/code&gt; or &lt;code&gt;development.log&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As &lt;a href="https://eliotsykes.com/quiet-assets"&gt;this great article on Rails debugging with quiet logs points out&lt;/a&gt;, your log may get filled with lines like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;Started GET &amp;quot;/assets/jquery.abcde.js?body=1&amp;quot; for 127.0.0.1 at 2016-08-27 18:38:00 -0400
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unless you&amp;rsquo;re debugging an issue in the asset pipeline, numerous asset requests are not very useful and tend to mask more important info logged in the controller actions.&lt;/p&gt;

&lt;h3&gt;Quieting assets, the old way&lt;/h3&gt;

&lt;p&gt;To disable asset logging behavior, many Rails 4 projects have used the &lt;code&gt;quiet_assets&lt;/code&gt; gem.&lt;/p&gt;

&lt;p&gt;So, why did we need a separate gem in the first place?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Rails::Rack::Logger&lt;/code&gt; is a middleware in the Rails middleware stack that logs all requests coming into your Rails app and implements an &lt;code&gt;ActiveSupport::Notification&lt;/code&gt; for each request you can hook into for additional information. The &lt;code&gt;quiet_assets&lt;/code&gt; gem simply sets the log level to &lt;code&gt;Logger::Error&lt;/code&gt; for any request matching your application&amp;rsquo;s assets path prefix, which means it won&amp;rsquo;t show up in your log file or &lt;code&gt;STDOUT&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;quiet_assets&lt;/code&gt; gem &lt;a href="https://github.com/evrone/quiet_assets/blob/e54ca548f005ca2a93e781c7b583ff4d0b59dd35/lib/quiet_assets.rb#L20"&gt;monkeypatches &lt;code&gt;Rails::Rack::Logger&lt;/code&gt;&lt;/a&gt; to accomplish this. Here&amp;rsquo;s the relevant code provided in the gem:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;Rails::Rack::Logger.class_eval do
  def call_with_quiet_assets(env)
    begin
      if env[&amp;#39;PATH_INFO&amp;#39;] =~ ASSETS_REGEX
        env[KEY] = Rails.logger.level
        Rails.logger.level = Logger::ERROR       # set the log level to silence
      end
      call_without_quiet_assets(env)
    ensure
      Rails.logger.level = env[KEY] if env[KEY]  # resets the previous log level
    end
  end
  alias_method_chain :call, :quiet_assets
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While useful, it would be preferable to avoid monkeypatching the Rails logging
middleware and remove the &lt;code&gt;quiet_assets&lt;/code&gt; dependency if &lt;code&gt;sprockets-rails&lt;/code&gt; could
handle this for us.&lt;/p&gt;

&lt;h3&gt;Replacing the quiet_assets gem&lt;/h3&gt;

&lt;p&gt;Now, as of the most recent version of &lt;code&gt;sprockets-rails&lt;/code&gt; (at the time of this writing, version &lt;code&gt;3.1.1&lt;/code&gt;) provides the ability to silence assets requests. This means the &lt;code&gt;quiet_assets&lt;/code&gt; gem is no longer needed in a fresh Rails 5 application.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how to configure your Rails app to silence asset logging with this most
recent version of &lt;code&gt;sprockets-rails&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# config/environments/development.rb

Rails.application.configure do

  config.assets.quiet = true

  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So how does this work? The &lt;code&gt;sprockets-rails&lt;/code&gt; gem now inserts an additional middleware ahead of &lt;code&gt;Rails::Rack::Logger&lt;/code&gt; in the middleware stack:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ bin/rake middleware
# ...
use Sprockets::Rails::QuietAssets
use Rails::Rack::Logger
# ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code&gt;config.assets.quiet&lt;/code&gt; is enabled in development, the &lt;code&gt;Sprockets::Rails::Middleware&lt;/code&gt; also matches on asset requests, but instead uses the &lt;code&gt;Rails.logger.silence { ... }&lt;/code&gt; block method to change the log level to &lt;code&gt;Logger::ERROR&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a &lt;a href="https://github.com/rails/sprockets-rails/pull/355"&gt;link to the recent pull request&lt;/a&gt; if you&amp;rsquo;re interested to take a closer look at how this functionality works. The entire middleware is &lt;a href="https://github.com/rails/sprockets-rails/blob/df5950017d7f2aa6fcbfa3949edfef85c35c28c7/lib/sprockets/rails/quiet_assets.rb"&gt;currently only 18 lines&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;module Sprockets
  module Rails
    class QuietAssets
      def initialize(app)
        @app = app
        @assets_regex = %r(\A/{0,2}#{::Rails.application.config.assets.prefix})
      end

      def call(env)
        if env[&amp;#39;PATH_INFO&amp;#39;] =~ @assets_regex
          ::Rails.logger.silence { @app.call(env) }  # silences the logs!
        else
          @app.call(env)
        end
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, this feature isn&amp;rsquo;t just for Rails 5; it should also be possible for you to upgrade to this version of &lt;code&gt;sprockets-rails&lt;/code&gt; for existing Rails 4 applications.&lt;/p&gt;

&lt;p&gt;In case you&amp;rsquo;re wondering, the &lt;code&gt;Rails.logger.silence { ... }&lt;/code&gt; call assumes your
Rails logger includes the &lt;a href="http://api.rubyonrails.org/classes/LoggerSilence.html"&gt;&lt;code&gt;LoggerSilence&lt;/code&gt; module&lt;/a&gt;, which adds the &lt;code&gt;#silence&lt;/code&gt; method to the including logger class, which will set the log level to &lt;code&gt;Logger::ERROR&lt;/code&gt; for the duration of the block, similar to how the &lt;code&gt;quiet_assets&lt;/code&gt; gem works, but without monkeypatching.&lt;/p&gt;

&lt;h3&gt;Logging to STDOUT&lt;/h3&gt;

&lt;p&gt;You may be surprised then to see asset requests fail if you&amp;rsquo;re using a non-compliant logger. Unfortunately, this includes the &lt;code&gt;Logger&lt;/code&gt; class from the Ruby standard library, which, of course, does not include the &lt;code&gt;LoggerSilence&lt;/code&gt; module. You might be using Ruby&amp;rsquo;s &lt;code&gt;Logger&lt;/code&gt; if you&amp;rsquo;ve followed common recommendations to change your Rails logger to log to &lt;code&gt;STDOUT&lt;/code&gt;, as in &lt;a href="http://blog.bigbinary.com/2016/04/12/rails-5-allows-to-send-log-to-stdout-via-environment-variable.html"&gt;this tutorial&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;config.logger = ActiveSupport::TaggedLogging.new(Logger.new(STDOUT))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I ran into this issue recently when assets were failing to load after I upgraded
to &lt;code&gt;sprockets-rails 3.1.1&lt;/code&gt; and began seeing &lt;code&gt;NoMethodError: undefined method &amp;#39;silence&amp;#39; for #&amp;lt;Logger:...&amp;gt;&lt;/code&gt; in my development logs.&lt;/p&gt;

&lt;p&gt;The fix is simple: to log to &lt;code&gt;STDOUT&lt;/code&gt; and take advantage of the new
&lt;code&gt;Sprockets::Rails::QuietAssets&lt;/code&gt; middleware, you could use &lt;code&gt;ActiveSupport::Logger&lt;/code&gt; instead, which inherits from Ruby &lt;code&gt;Logger&lt;/code&gt; and includes &lt;code&gt;LoggerSilence&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;config.logger = ActiveSupport::TaggedLogging.new(ActiveSupport::Logger.new(STDOUT))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, we could create our own subclass of &lt;code&gt;Logger&lt;/code&gt; with &lt;code&gt;LoggerSilence&lt;/code&gt;
included. If we just want &lt;code&gt;STDOUT&lt;/code&gt; logging, we could instead use Heroku&amp;rsquo;s
&lt;a href="https://github.com/heroku/rails_stdout_logging"&gt;&lt;code&gt;rails_stdout_logging&lt;/code&gt;&lt;/a&gt; gem,
which will also try to include the &lt;code&gt;LoggerSilence&lt;/code&gt; module in our logger, if available.&lt;/p&gt;

&lt;h3&gt;Resources&lt;/h3&gt;

&lt;p&gt;Be sure to check out the following links if you&amp;rsquo;re interested to learn more
about customizing your Rails logger. Happy logging!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://hawkins.io/2013/08/using-the-ruby-logger/"&gt;Using the Ruby Logger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.bigbinary.com/2016/04/12/rails-5-allows-to-send-log-to-stdout-via-environment-variable.html"&gt;Rails 5 allows to send log to STDOUT via environment variable&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ruby-doc.org/stdlib-2.3.0/libdoc/logger/rdoc/Logger.html"&gt;Ruby Logger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://apidock.com/rails/LoggerSilence/silence"&gt;LoggerSilence&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://eliotsykes.com/quiet-assets"&gt;Debug Rails faster with quiet assets &amp;amp; quieter logs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/evrone/quiet_assets"&gt;Quiet Assets gem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/heroku/rails_stdout_logging"&gt;Rails STDOUT logging gem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/rails/sprockets-rails/pull/355"&gt;PR to introduce quiet assets to &lt;code&gt;sprockets-rails&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Sending Web Push Notifications from Rails</title>
    <link rel="alternate" href="/blog/web-push-notifications-from-rails.html"/>
    <id>/blog/web-push-notifications-from-rails.html</id>
    <published>2016-05-13T00:00:00+00:00</published>
    <updated>2016-05-13T00:00:00+00:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;em&gt;Update: Check out &lt;a href="https://rossta.net/blog/using-the-web-push-api-with-vapid.html"&gt;Using the Push API with VAPID&lt;/a&gt; to use the voluntary server identification protocol in place of GCM app settings for sending push notifications to Chrome&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We’ve had push notifications in our mobile and desktop apps for sometime. It...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;em&gt;Update: Check out &lt;a href="https://rossta.net/blog/using-the-web-push-api-with-vapid.html"&gt;Using the Push API with VAPID&lt;/a&gt; to use the voluntary server identification protocol in place of GCM app settings for sending push notifications to Chrome&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve had push notifications in our mobile and desktop apps for sometime. It&amp;rsquo;s now becoming possible on the open web.&lt;/p&gt;

&lt;p&gt;Web Push notifications are powerful because they allow you to engage with your users &lt;em&gt;even when they&amp;rsquo;re not on your site&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m going to share how to I got a working demo of the new &lt;a href="https://www.w3.org/TR/push-api/"&gt;Web Push API&lt;/a&gt; from a Rails (or any Ruby) web application to push desktop-style notifications through supporting browsers - currently Chrome and Firefox at the time of this writing.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll cover the basics of implementing Push yourself though it&amp;rsquo;s interesting to note that third party services are already stepping in to do some of the technical work for you, like &lt;a href="https://goroost.com/"&gt;Roost&lt;/a&gt;, &lt;a href="https://pushcrew.com/"&gt;PushCrew&lt;/a&gt;, or
&lt;a href="https://onesignal.com/webpush"&gt;OneSignal&lt;/a&gt;.&lt;/p&gt;

&lt;div class="callout panel"&gt;
&lt;p&gt;
  The &lt;a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/ApplePushService.html"&gt;Apple Push Notification Service&lt;/a&gt; has made push notifications available to Safari since 2013. There are some &lt;a href="http://samuli.hakoniemi.net/how-to-implement-safari-push-notifications-on-your-website/"&gt;nice tutorials&lt;/a&gt; for implementing Apple Push on Safari. The status of future support for Web Push in Safari is: &amp;ldquo;maybe?&amp;rdquo;.
&lt;/p&gt;
&lt;/div&gt;

&lt;h2&gt;Why?&lt;/h2&gt;

&lt;p&gt;&amp;ldquo;Yeah, Ross, but Rails 5. Action Cable. Web Sockets. Server Sent Events. &lt;code&gt;$MY_FAVORITE_ALTERNATIVE&lt;/code&gt;!&amp;rdquo;&lt;/p&gt;

&lt;p&gt;You might not want to drop all those alternatives just yet, as &lt;a href="http://caniuse.com/#feat=push-api"&gt;browser support for Web Push&lt;/a&gt; still needs improvement. Web Push could be a good alternative for a subset push features for applications where deploying Rails 5 Action Cable would be overkill. Web push also currently relies on third party web which may or may not be advantage depending on your deployment options.&lt;/p&gt;

&lt;p&gt;But the killer feature of Web Push is that notifications can be displayed even when the user is not on the site, something those other solutions cannot provide.&lt;/p&gt;

&lt;h2&gt;Demo&lt;/h2&gt;

&lt;p&gt;Want to see it in action first?&lt;/p&gt;

&lt;p&gt;I created a demo at the &lt;a href="https://serviceworker-rails.herokuapp.com/push-simple/"&gt;Service Worker Rails
Sandbox&lt;/a&gt; to show how a
simple push message would look like. Try it out in Firefox or Chrome or check
out the &lt;a href="https://github.com/rossta/serviceworker-rails-sandbox"&gt;source code on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://serviceworker-rails.herokuapp.com/push-simple/"&gt;&lt;img src="/assets/images/screenshots/screenshot-sw-sandbox-push-simple-1-2927dd61.png" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;My demo is mostly informed by Mozilla&amp;rsquo;s &lt;a href="https://serviceworke.rs/"&gt;Service Worker
Cookbook&lt;/a&gt;, which I highly recommend if you&amp;rsquo;re looking
to learn more about Service Worker.&lt;/p&gt;

&lt;h2&gt;Bird&amp;rsquo;s eye view&lt;/h2&gt;

&lt;p&gt;Delivering push notifications involve interactions among three parties - the
user (through her browser), your Rails application, and the Web Push server,
which for our purposes is either Google or Firefox.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/blog/push-notification-high-level-9cb4f185.png" /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Diagram courtesy of the &lt;a href="https://wiki.mozilla.org/Firefox/Push_Notifications"&gt;Firefox wiki&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;We&amp;rsquo;ll use JavaScript on the user&amp;rsquo;s current page to &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register"&gt;register a service worker&lt;/a&gt; subscribe to push notifications via the &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/PushManager/subscribe"&gt;&lt;code&gt;pushManager&lt;/code&gt;&lt;/a&gt; interface. The browser will make a request to the Web Push server to a &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription"&gt;&lt;code&gt;PushSubscription&lt;/code&gt;&lt;/a&gt; which will contain a unique endpoint to the Web Push server and authorization keys required for encrypting the push notification request body.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We&amp;rsquo;ll post the subscription info to our Rails app to be persisted on the server side.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;To send a push notification, we&amp;rsquo;ll use the &lt;a href="https://github.com/zaru/webpush"&gt;&lt;code&gt;webpush&lt;/code&gt;&lt;/a&gt; Ruby gem triggered from our Rails app. &lt;code&gt;webpush&lt;/code&gt; is responsible for sending a proper request to the Web Push server, including &lt;a href="https://developers.google.com/web/updates/2016/03/web-push-encryption?hl=en"&gt;encryption of the message payload&lt;/a&gt; for delivery.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If the request is successful, the Web Push server opens a socket to our
registered service worker which can listen for &lt;code&gt;&amp;#39;push&amp;#39;&lt;/code&gt; events to show a
notification to the user. Since service workers have a lifecycle independent of
the web page, they can process events even when the user is not visiting our
website.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Setup&lt;/h2&gt;

&lt;p&gt;At the time of this writing, we&amp;rsquo;ll need to configure our app to use the Google Cloud Messaging platform by registering for application keys. No special authorization is needed to use the Firefox push server as far as I can tell.&lt;/p&gt;

&lt;p&gt;Google provides some decent &lt;a href="https://developers.google.com/web/fundamentals/getting-started/push-notifications/step-04?hl=en"&gt;instructions for registering your app for push
notifications&lt;/a&gt; which involves some clicking around on the &lt;a href="https://console.developers.google.com"&gt;Google developer console&lt;/a&gt;. (I&amp;rsquo;ve heard rumors this may not be necessary in the near future.) You&amp;rsquo;ll want to come away with a project id for your app and an API key to make authorized requests to the push server.&lt;/p&gt;

&lt;p&gt;Both Firefox and Chrome will expect us to link to a &lt;code&gt;manifest&lt;/code&gt; json file to
provide metadata for push subscriptions and notifications. Here&amp;rsquo;s an example:&lt;/p&gt;

&lt;pre&gt;&lt;code class="json"&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;Your app name&amp;quot;,
  &amp;quot;short_name&amp;quot;: &amp;quot;Your app&amp;quot;,
  &amp;quot;icons&amp;quot;: [{
    &amp;quot;src&amp;quot;: &amp;quot;images/icon-192x192.png&amp;quot;,
    &amp;quot;sizes&amp;quot;: &amp;quot;192x192&amp;quot;,
    &amp;quot;type&amp;quot;: &amp;quot;image/png&amp;quot;
  }],
  &amp;quot;start_url&amp;quot;: &amp;quot;/&amp;quot;,
  &amp;quot;display&amp;quot;: &amp;quot;standalone&amp;quot;,
  &amp;quot;gcm_sender_id&amp;quot;: &amp;quot;&amp;lt;Your Project ID&amp;gt;&amp;quot;,
  &amp;quot;gcm_user_visible_only&amp;quot;: true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;div class="callout panel"&gt;
&lt;p&gt;
Update: as of Chrome 52, it is no longer necessary to set the &lt;code&gt;gcm_sender_id&lt;/code&gt;
and &lt;code&gt;gcm_user_visible_only&lt;/code&gt; attributes in your &lt;code&gt;manifest.json&lt;/code&gt; configuration
as long as you use VAPID details as &lt;a href="/blog/using-the-web-push-api-in-ruby.html"&gt;described in my followup post&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;For now, this file can go in &lt;code&gt;public/manifest.json&lt;/code&gt;. In your &lt;code&gt;app/views/layouts/application.html.erb&lt;/code&gt; template, you&amp;rsquo;ll also need to
add a special &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; tag to the manifest:&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;link rel=&amp;quot;manifest&amp;quot; href=&amp;quot;/manifest.json&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s the &lt;a href="https://serviceworker-rails.herokuapp.com/push-simple/manifest.json"&gt;actual manifest.json&lt;/a&gt; for the Service Worker Rails Sandbox &lt;a href="https://serviceworker-rails.herokuapp.com/push-simple/"&gt;push demo&lt;/a&gt; as another point of reference.&lt;/p&gt;

&lt;h2&gt;Subscribe through a service worker&lt;/h2&gt;

&lt;p&gt;Yes, Service Worker time! In case you missed it, I&amp;rsquo;m really &lt;a href="/blog/series/service-worker.html"&gt;excited about
Service Workers&lt;/a&gt;. Service Workers have the
potential to level the playing field of reliability between the web and mobile devices.&lt;/p&gt;

&lt;p&gt;Service workers must be deployed a bit differently than JavaScript evaluated in
the web page context. I&amp;rsquo;ve gone into more detail on how to &lt;a href="/blog/service-worker-on-rails.html"&gt;integrate Service
Worker with Rails&lt;/a&gt; previously but for now, here&amp;rsquo;s the quick setup for push.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;application.js&lt;/code&gt; (or another &lt;code&gt;.js&lt;/code&gt; required by &lt;code&gt;application.js&lt;/code&gt;) we&amp;rsquo;ll use this following snippet to request registration of
a service worker script.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// app/assets/javascripts/application.js

if (&amp;#39;serviceWorker&amp;#39; in navigator) {
  console.log(&amp;#39;Service Worker is supported&amp;#39;);
  navigator.serviceWorker.register(&amp;#39;/serviceworker.js&amp;#39;)
    .then(function(registration) {
      console.log(&amp;#39;Successfully registered!&amp;#39;, &amp;#39;:^)&amp;#39;, registration);
      registration.pushManager.subscribe({ userVisibleOnly: true })
        .then(function(subscription) {
            console.log(&amp;#39;endpoint:&amp;#39;, subscription.endpoint);
        });
  }).catch(function(error) {
    console.log(&amp;#39;Registration failed&amp;#39;, &amp;#39;:^(&amp;#39;, error);
  });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code registers a service worker on the given scope via &lt;code&gt;navigator.serviceWorker.register&lt;/code&gt;. This returns a &lt;a href="#"&gt;Promise&lt;/a&gt; which will resolve to an instance of &lt;code&gt;ServiceWorkerRegistration&lt;/code&gt;. This registration object has a &lt;code&gt;pushManager&lt;/code&gt; property which we use to &lt;code&gt;subscribe&lt;/code&gt; to the Web Push server. The &lt;code&gt;{ userVisibleOnly: true }&lt;/code&gt; parameter is required for us to use notifications.&lt;/p&gt;

&lt;h3&gt;Troubleshooting&lt;/h3&gt;

&lt;p&gt;I got an error at this stage in Google Chrome the first time: &lt;code&gt;Unable to subscribe to push DOMException: Registration failed - push service error&lt;/code&gt;. Turns out, the &lt;code&gt;pushmanage.subscribe&lt;/code&gt; request can fail if you haven&amp;rsquo;t properly configured your &lt;code&gt;manifest.json&lt;/code&gt; with a valid Google Cloud Message sender id.&lt;/p&gt;

&lt;p&gt;Also, if the &lt;code&gt;pushManager&lt;/code&gt; can&amp;rsquo;t find the &lt;code&gt;manifest.json&lt;/code&gt; via the link tag, or
if it&amp;rsquo;s not included in the page altogether, you may see another error: &lt;code&gt;Unable to subscribe to push DOMException: Registration failed - manifest empty or missing&lt;/code&gt;, so you&amp;rsquo;ll need to get that working to proceed.&lt;/p&gt;

&lt;h3&gt;The Service Worker&lt;/h3&gt;

&lt;p&gt;In a separate file, &lt;code&gt;app/assets/javascripts/serviceworker.js&lt;/code&gt;, we&amp;rsquo;ll have our service worker show notifications when the &lt;code&gt;&amp;#39;push&amp;#39;&lt;/code&gt; event is received:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;function onPush(event) {
  var title = (event.data &amp;amp;&amp;amp; event.data.text()) || &amp;quot;Yay a message&amp;quot;;

  event.waitUntil(
    self.registration.showNotification(title, {
      body: &amp;quot;We have received a push message&amp;quot;,
      icon: &amp;quot;/assets/path/to/icon.png&amp;quot;,
      tag:  &amp;quot;push-simple-demo-notification-tag&amp;quot;
    });
  )
}

self.addEventListener(&amp;quot;push&amp;quot;, onPush);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because &lt;code&gt;serviceworker.js&lt;/code&gt; needs to be a separate script available on the root
path, we either need to copy it to our &lt;code&gt;public/&lt;/code&gt; directory , or, even better, we
can use the &lt;a href="https://github.com/rossta/serviceworker-rails"&gt;&lt;code&gt;serviceworker-rails&lt;/code&gt; (Star it on GitHub!)&lt;/a&gt; gem which will allow us to make use of both the asset pipeline and custom routing features we need.&lt;/p&gt;

&lt;h3&gt;Rails setup&lt;/h3&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Gemfile

gem &amp;#39;serviceworker-rails&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To routes requests from &lt;code&gt;/serviceworker.js&lt;/code&gt; to our JavaScript file in the asset pipeline, we&amp;rsquo;ll configure the service worker rails middleware as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# config/initializers/serviceworker.rb

Rails.application.configure do
  config.serviceworker.routes do
    match &amp;quot;serviceworker.js&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With these settings, we should be able to see our service worker register with the logging we put in place and be able to accept the browser prompt to receive notifications.&lt;/p&gt;

&lt;p&gt;As a side note, we can also use the &lt;code&gt;serviceworker-rails&lt;/code&gt; routing to move our
&lt;code&gt;manifest.json&lt;/code&gt; file to &lt;code&gt;app/assets/javascripts&amp;#39;/&lt;/code&gt; from the &lt;code&gt;public/&lt;/code&gt; directory so we can take advantage for the asset pipeline, say for calculating image paths, for this file as well:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# config/initializers/serviceworker.rb

Rails.application.configure do
  config.serviceworker.routes do
    # ...

    match &amp;quot;manifest.json&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Persist the subscription&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s set up a controller action to serialize the subscription into the visitor&amp;rsquo;s session though any persistence method that will allow us to retrieve the subscription(s) for a given user will do.&lt;/p&gt;

&lt;p&gt;The push subscription has important pieces of data: the endpoint and a set of keys: p256dh and auth. We need use this data in requests from our rails app to the push server.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// subscription.toJSON();

{
  endpoint: &amp;quot;https://android.googleapis.com/gcm/send/a-subscription-id&amp;quot;,
  keys: {
    auth: &amp;quot;16ByteString&amp;quot;,
    p256dh: &amp;quot;65ByteString&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When our visitor subscribes, we can post the subscription to our Rails app:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;reg.pushManager.subscribe({ userVisibleOnly: true })
  .then(function(subscription) {
    $.post(&amp;quot;/subscribe&amp;quot;, { subscription: subscription.toJSON() });
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The route:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# config/routes.rb

post &amp;quot;/subscribe&amp;quot; =&amp;gt; &amp;quot;subscriptions#create&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our controller - of course, greatly simplified for the purposes of the this demo:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# app/controllers/subscriptions_controller.rb

class SubscriptionsController &amp;lt; ApplicationController
  def create
    session[:subscription] = JSON.dump(params.fetch(:subscription, {}))

    head :ok
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Push it&lt;/h2&gt;

&lt;p&gt;Now that we have a subscription, we can send a push notification. For this, we&amp;rsquo;ll use the &lt;code&gt;webpush&lt;/code&gt; gem:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Gemfile

gem &amp;quot;webpush&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the subscription info, we have what we need to send a message to a specific
user that will get encrypted in passing over the wire.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a typical usage:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;Webpush.payload_send(
  message: &amp;quot;Hello World!&amp;quot;,
  endpoint: &amp;quot;https://android.googleapis.com/gcm/send/a-subscription-id&amp;quot;,
  auth: &amp;quot;16ByteString&amp;quot;,
  p256dh: &amp;quot;65ByteString&amp;quot;
  api_key: &amp;quot;google_api_key&amp;quot; # omit for Firefox, required for Google
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a proof of concept, we&amp;rsquo;ll create an endpoint to trigger a push notification directly from a user interaction in the browser.&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;!-- a view --&amp;gt;
&amp;lt;button class=&amp;quot;js-push-button&amp;quot;&amp;gt;Send a message&amp;lt;/button&amp;gt;

&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
  (function() {
    $(&amp;#39;.js-push-button&amp;#39;).on(&amp;quot;click&amp;quot;, function onClick() {
      $.post(&amp;quot;/push&amp;quot;);
    });
  })();
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Start with a button to trigger a &lt;code&gt;POST&lt;/code&gt; to a new &lt;code&gt;/push&lt;/code&gt; endpoint in our app. In a real Rails app, you&amp;rsquo;d probably deliver push notifications from background jobs in response to other events in the system.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# config/routes.rb

post &amp;quot;/push&amp;quot; =&amp;gt; &amp;quot;push_notifications#create&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Route the request to a new controller.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# app/controllers/push_notifications_controller.rb

class PushNotificationsController &amp;lt; ApplicationController
  def create
    Webpush.payload_send webpush_params

    head :ok
  end

  private

  def webpush_params
    subscription_params = fetch_subscription
    message = &amp;quot;Hello world, the time is #{Time.zone.now}&amp;quot;
    endpoint = subscription_params[:endpoint],
    p256dh = subscription_params.dig(:keys, :p256dh)
    auth = subscription_params.dig(:keys, :auth)
    api_key = enpoint =~ /\.google.com\// = ENV.fetch(&amp;#39;GOOGLE_CLOUD_MESSAGE_API_KEY&amp;#39;) || &amp;quot;&amp;quot;

    { message: message, endpoint: endpoint, p256dh: p256dh, auth: auth, api_key: api_key }
  end

  def fetch_subscription
    encoded_subscription = session.fetch(:subscription) do
      raise &amp;quot;Cannot create notification: no :subscription in params or session&amp;quot;
    end

    JSON.parse(Base64.urlsafe_decode64(encoded_subscription)).with_indifferent_access
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The controller deserializes the subscription from the session and builds up the
necessary parameters to send to the &lt;code&gt;Webpush&lt;/code&gt; Ruby client. Only the &lt;code&gt;:endpoint&lt;/code&gt; is
required to send a notification in theory. The &lt;code&gt;:p256dh&lt;/code&gt; and &lt;code&gt;:auth&lt;/code&gt; keys are also required if providing a &lt;code&gt;:message&lt;/code&gt; parameter, which must be encrypted to deliver over the wire. Google requires the Google Cloud Message API key we grabbed from th developer console, so we test the endpoint to
decide whether to include it in the request.&lt;/p&gt;

&lt;p&gt;If everything worked, we get a push notification!&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/screenshots/screenshot-sw-sandbox-push-simple-2-b270f8bc.jpg" /&gt;&lt;/p&gt;

&lt;h2&gt;Unsubscribing&lt;/h2&gt;

&lt;p&gt;We can programmatically turn off notifications by calling
&lt;code&gt;PushSubscription#unsubscribe&lt;/code&gt;. This could be done in a callback to a click handler, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;function unsubscribe() {
  navigator.serviceWorker.ready
    .then((serviceWorkerRegistration) =&amp;gt; {
      serviceWorkerRegistration.pushManager.getSubscription()
        .then((subscription) =&amp;gt; {
          if (!subscription) {
            console.log(&amp;quot;Not subscribed, nothing to do.&amp;quot;);
            return;
          }

          subscription.unsubscribe()
            then(function() {
              console.log(&amp;quot;Successfully unsubscribed!.&amp;quot;);
            })
            .catch((e) =&amp;gt; {
              logger.error(&amp;#39;Error thrown while unsubscribing from push messaging&amp;#39;, e);
            });
        });
    });
}

$(&amp;quot;.js-unsubscribe-button&amp;quot;).on(&amp;quot;click&amp;quot;, unsubscribe)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;d also want to send a request to your Rails app to delete the persisted
subscription data from the backend which will no longer be valid on the Web Push
server. That exercise is left up to you!&lt;/p&gt;

&lt;h2&gt;Wrap up&lt;/h2&gt;

&lt;p&gt;This took quite a bit of setup though not nearly as much as getting &lt;a href="https://developer.apple.com/notifications/safari-push-notifications/"&gt;Apple
Push Notifications to work in Safari&lt;/a&gt;. Overall, the Web Push API is an interesting step for the web in terms of feature parity with mobile.&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>An offline page for your Rails application</title>
    <link rel="alternate" href="/blog/offline-page-for-your-rails-application.html"/>
    <id>/blog/offline-page-for-your-rails-application.html</id>
    <published>2016-05-09T00:00:00+00:00</published>
    <updated>2016-05-09T00:00:00+00:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;When you visit a website without an internet connection in Chrome, you see the
offline dinosaur.&lt;/p&gt;

&lt;p&gt;No wonder we tend to think of websites as less reliable than mobile applications - we can’t use them without the network.&lt;/p&gt;

&lt;p&gt;At least, not typically. We...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;When you visit a website without an internet connection in Chrome, you see the
offline dinosaur.&lt;/p&gt;

&lt;p&gt;No wonder we tend to think of websites as less reliable than mobile applications - we can&amp;rsquo;t use them without the network.&lt;/p&gt;

&lt;p&gt;At least, not typically. We could use &lt;a href="http://diveintohtml5.info/offline.html"&gt;App Cache&lt;/a&gt; and the Cache Manifest to create an offline experience. For &lt;a href="http://alistapart.com/article/application-cache-is-a-douchebag"&gt;a number of reasons&lt;/a&gt;, developers have found App Cache difficult to work with.&lt;/p&gt;

&lt;p&gt;Luckily, there&amp;rsquo;s a new web standard, &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API"&gt;Service Worker&lt;/a&gt;, that potentially supplants App Cache by providing more granular control over networking in JavaScript, as opposed to manifest files.&lt;/p&gt;

&lt;p&gt;For now, we use a service worker to render a simple error page with our own branding
when a user attempts to come back to our site without a connection. Keep in
mind, the techniques used here are building blocks that can be taken further to enhance functionality.&lt;/p&gt;

&lt;aside class="callout panel"&gt;
  &lt;p&gt;
Sidebar: I&amp;rsquo;ve wondered: should the offline response be associated with an HTTP status code? I don&amp;rsquo;t believe one exists for &amp;ldquo;No network connection&amp;rdquo;. If the potential for service workers is fully realized, then in theory, web developers will be able to create rich experiences for users regardless of connectivity - so perhaps question won&amp;rsquo;t be relevant. But our use case for a singular offline response - one in which we give visitors feedback about why their request cannot be fulfilled - correlates with statuses like &amp;ldquo;Not found&amp;rdquo;, &amp;ldquo;Moved permanently&amp;rdquo;, and &amp;ldquo;Site offline for maintenance&amp;rdquo;. Philosophically, is a request that never reaches the server a request at all?
&lt;/p&gt;
&lt;/aside&gt;

&lt;p&gt;To do this, we&amp;rsquo;re going to use a service worker to precache the offline
assets on the first visit to the site. Later, during a return visit without a
network connection, we can use our service worker to render the offline page.&lt;/p&gt;

&lt;p&gt;This is possible because Service Worker acts as a liason between your
visitor&amp;rsquo;s browser and your servers &lt;em&gt;outside the lifecycle of a page&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Keep in mind also, will be a &lt;em&gt;progressive enhancement&lt;/em&gt;. Since service workers are &lt;a href="https://jakearchibald.github.io/isserviceworkerready/"&gt;not available in all browsers&lt;/a&gt;, this approach won&amp;rsquo;t work for everyone, but the experience won&amp;rsquo;t degrade for those visitors either.&lt;/p&gt;

&lt;h3&gt;Produce the assets&lt;/h3&gt;

&lt;p&gt;First we need an offline page. We could simply use an HTML page in the public directory with embedded styles like the generated Rails 404 and 500 pages.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://gist.github.com/rossta/c4f6de214a138a355a9993c7cdadbdc0"&gt;Source: /offline.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alternatively, set up a route to a controller action as a &lt;a href="https://mattbrictson.com/dynamic-rails-error-pages"&gt;dynamic Rails error page&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Add a service worker file&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;re going to cache this offline HTML on the client side during their first
visit so that it&amp;rsquo;s available later. We can of course add links
to external CSS, JavaScript, and images in our offline pages - we just need to
remember to cache those resources as well.&lt;/p&gt;

&lt;p&gt;(The following assumes Sprockets, so if using something else, we&amp;rsquo;ll need to adjust accordingly where the asset pipeline is concerned.)&lt;/p&gt;

&lt;p&gt;The service worker script file must live outside our &lt;code&gt;application.js&lt;/code&gt; or other
bundled assets. It can live in any path from which Sprockets can load assets,
but for now, we&amp;rsquo;ll add a new JavaScript file in &lt;code&gt;app/assets/javascripts/serviceworker.js&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Since it won&amp;rsquo;t be bundled with &lt;code&gt;application.js&lt;/code&gt;, we&amp;rsquo;ll need to let our Rails
configuration know to precompile our serviceworker separately:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# config/initializers/assets.rb

Rails.application.config.assets.precompile += %w[serviceworker.js]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Declare an &amp;lsquo;install&amp;rsquo; event&lt;/h3&gt;

&lt;p&gt;Since service workers are event driven, we&amp;rsquo;ll provide callbacks to three key events in the servive worker lifecycle: &lt;code&gt;install&lt;/code&gt;, &lt;code&gt;activate&lt;/code&gt;, and &lt;code&gt;fetch&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;install&lt;/code&gt; event will be invoked just the first time the service worker is
requested or any time it is updated and redeployed prior to being activated. Here, we&amp;rsquo;ll precache our offline assets:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;var version = &amp;#39;v1::&amp;#39;;

self.addEventListener(&amp;#39;install&amp;#39;, function onInstall(event) {
  event.waitUntil(
    caches.open(version + &amp;#39;offline&amp;#39;).then(function prefill(cache) {
      return cache.addAll([
        &amp;#39;/offline.html&amp;#39;,
        // etc
      ]);
    })
  );
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;event.waitUntil&lt;/code&gt; accepts &lt;a href="http://www.html5rocks.com/en/tutorials/es6/promises/"&gt;a promise&lt;/a&gt; which must succeed for the &lt;code&gt;install&lt;/code&gt; event to install the service worker successfully. We use &lt;code&gt;caches.open&lt;/code&gt; to return a promise that adds our static offline assets to a named cache associated with our site and the user&amp;rsquo;s browser. The &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache"&gt;Cache API&lt;/a&gt; provides client-side storage for request/response pairs, a lot like a built in HTTP cache.&lt;/p&gt;

&lt;p&gt;We can also cache precompiled assets by renaming our &lt;code&gt;serviceworker.js&lt;/code&gt; to &lt;code&gt;serviceworker.js.erb&lt;/code&gt; and embedding helper methods:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;return cache.addAll([
  &amp;#39;/offline.html&amp;#39;,
  &amp;#39;&amp;lt;%= asset_path &amp;quot;application.css&amp;quot; %&amp;gt;&amp;#39;,
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&amp;#39;fetch&amp;rsquo; or fallback&lt;/h3&gt;

&lt;p&gt;Our service worker can intercept any external network request from our visitor&amp;rsquo;s
browser - even to cross-origin hosts - within the fetch event.&lt;/p&gt;

&lt;p&gt;There are &lt;a href="https://jakearchibald.com/2014/offline-cookbook/"&gt;a ton of strategies we can
employ&lt;/a&gt; to give the service
worker power to respond to various requests, for our simple offline page&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;self.addEventListener(&amp;#39;fetch&amp;#39;, function onFetch(event) {
  var request = event.request;

  if (!request.url.match(/^https?:\/\/example.com/) ) { return; }
  if (request.method !== &amp;#39;GET&amp;#39;) { return; }

  event.respondWith(
    fetch(request).                                      // first, the network
      .catch(function fallback() {
        caches.match(request).then(function(response) {  // then, the cache
          response || caches.match(&amp;quot;/offline.html&amp;quot;);     // then, /offline cache
        })
      })
  );
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code will filter for GET requests to our host. Ignored &lt;code&gt;fetch&lt;/code&gt; events will simply proceed to the network. When we may want to provide the offline fallback, we&amp;rsquo;ll then ask then network to &lt;code&gt;fetch&lt;/code&gt; the
request. If that doesn&amp;rsquo;t resolve, our &lt;code&gt;catch&lt;/code&gt; handler will be invoked and
attempt to match the request in the cache or simply return our cached offline
page.&lt;/p&gt;

&lt;h3&gt;Clean up during &amp;#39;activate&amp;rsquo;&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;activate&lt;/code&gt; event is useful to clean up old caches, say when the offline page
or any of the linked static resources changes.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// var version = &amp;quot;v2::&amp;quot;;

self.addEventListener(&amp;#39;activate&amp;#39;, function onActivate(event) {
  event.waitUntil(
    caches.keys().then(function deleteOldCache(cacheNames) {
      return Promise.all(
        cacheNames.filter(function(cacheName) {
          return key.indexOf(version) !== 0;
        }).map(function(cacheName) {
          return caches.delete(cacheName);
        })
      );
    })
  );
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we deploy a service worker with a new version number, the &lt;code&gt;install&lt;/code&gt; event
will be invoked again to re-cache the static resources for the offline page.
During &lt;code&gt;activate&lt;/code&gt;, any cache names that don&amp;rsquo;t match the new version number will
be removed.&lt;/p&gt;

&lt;h3&gt;Register that worker&lt;/h3&gt;

&lt;p&gt;With our service worker event handling in place, we must register the script
from the main page. In any file included in &lt;code&gt;application.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// app/assets/application.js

if (&amp;#39;serviceWorker&amp;#39; in navigator) {
  navigator.serviceWorker.register(&amp;#39;/serviceworker.js&amp;#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s important for this script to be available at the scope for which we want
the service worker to be active. In other words, registering the service worker
at its precompiled path &lt;code&gt;/assets/serviceworker.js&lt;/code&gt;, won&amp;rsquo;t be helpful since we
won&amp;rsquo;t be able to intercept requests to the root path.&lt;/p&gt;

&lt;h3&gt;Sprinkle in some middleware&lt;/h3&gt;

&lt;p&gt;To make this work with the Rails asset pipeline, we can use the
&lt;a href="https://github.com/rossta/serviceworker-rails"&gt;&lt;code&gt;serviceworker-rails&lt;/code&gt;&lt;/a&gt; gem.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Gemfile

gem &amp;quot;serviceworker-rails&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ServiceWorker::Rails&lt;/code&gt; will insert middleware into the Rails stack that we can
configure to route requests to bundled assets.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# config/initializers/serviceworker.rb

Rails.application.configure do
  config.serviceworker.routes.draw do
    match &amp;quot;/serviceworker.js&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, any request to the path &lt;code&gt;/serviceworker.js&lt;/code&gt; will match an asset of that
name. If your service worker script is in a nested directory, you&amp;rsquo;d use this
instead:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;match &amp;quot;/serviceworker.js&amp;quot; =&amp;gt; &amp;quot;nested/directory/serviceworker.js&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See the project &lt;a href="https://github.com/rossta/serviceworker-rails/blob/master/README.md"&gt;README&lt;/a&gt; for more info on how to configure the middleware.&lt;/p&gt;

&lt;p&gt;While you&amp;rsquo;re at it, &lt;a href="https://github.com/rossta/serviceworker-rails"&gt;star the project on GitHub&lt;/a&gt;!&lt;/p&gt;

&lt;h3&gt;Moment of truth&lt;/h3&gt;

&lt;p&gt;Phew! That took some setup. Our offline page should now be ready for consumption. Try disabling your
network connection to test it out. You can use the &lt;em&gt;Network&lt;/em&gt; tab in Chrome and
Chrome Canary to take your browser offline while Firefox has the &lt;em&gt;Work Offline&lt;/em&gt; mode under the File menu.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/screenshots/screenshot-dev-tools-network-offline-fc2a31d1.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;To see a working demo of an offline page, check out the &lt;a href="https://serviceworker-rails.herokuapp.com/offline-fallback/"&gt;Service Worker Rails
Sandbox app&lt;/a&gt;. You
can find its &lt;a href="https://github.com/rossta/serviceworker-rails-sandbox"&gt;source code on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/screenshots/screenshot-offline-custom-4e1f1089.jpg" /&gt;&lt;/p&gt;

&lt;h3&gt;Debugging&lt;/h3&gt;

&lt;p&gt;Chrome also provides some useful debugging tools for service workers under the
&lt;em&gt;Resources&lt;/em&gt;. It&amp;rsquo;s helpful to read up on the Service Worker life cycle since it is treated
differently than other JavaScript resources. For example, a hard refresh isn&amp;rsquo;t
enough to get your browser to install an updated service worker &amp;ndash; the browser
will keep the current worker active while any tab to your browser is currently
open.&lt;/p&gt;

&lt;p&gt;You can navigate to a different host and back or close and reopen
the tab(s). The &lt;code&gt;self.skipWaiting&lt;/code&gt; function will also instruct the browser to
let a new service worker take control immediately when used during &lt;code&gt;install&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;self.addEventListener(&amp;#39;install&amp;#39;, function(event) {
  event.waitUntil(self.skipWaiting());
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Final word&lt;/h3&gt;

&lt;p&gt;I believe it&amp;rsquo;s important for web developers to start thinking about ways to make
our application more reliable in the eyes of consumers. While rendering an
offline page isn&amp;rsquo;t a game changer by itself, it is a low-risk way to begin
experimenting with the Service Worker API which has the potential for &lt;a href="http://serviceworke.rs/"&gt;many more
advanced use cases&lt;/a&gt; and can help the web get
closer to an even playing field with mobile apps.&lt;/p&gt;
</content>
  </entry>
</feed>
