<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rossta.net</title>
  <subtitle>Ross Kaffenberger</subtitle>
  <id>https://rossta.net/</id>
  <link href="https://rossta.net/"/>
  <link href="https://rossta.net/feed.xml" rel="self"/>
  <updated>2018-12-21T00:00:00+00:00</updated>
  <author>
    <name>Ross Kaffenberger</name>
  </author>
  <entry>
    <title>Everything is Enumerated</title>
    <link rel="alternate" href="/blog/everything-is-enumerated.html"/>
    <id>/blog/everything-is-enumerated.html</id>
    <published>2018-12-21T00:00:00+00:00</published>
    <updated>2018-12-21T00:00:00+00:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;In Ruby, some methods expect a block as a callback yielding elements of some internal data structure.&lt;/p&gt;

&lt;p&gt;Imagine a method &lt;code&gt;paginated_results&lt;/code&gt; on some &lt;code&gt;client&lt;/code&gt; object that yields individual pages.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;client.paginated_results(params) { |page| puts page.contents...&lt;/code&gt;&lt;/pre&gt;</summary>
    <content type="html">&lt;p&gt;In Ruby, some methods expect a block as a callback yielding elements of some internal data structure.&lt;/p&gt;

&lt;p&gt;Imagine a method &lt;code&gt;paginated_results&lt;/code&gt; on some &lt;code&gt;client&lt;/code&gt; object that yields individual pages.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;client.paginated_results(params) { |page| puts page.contents }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The method may hide away some complexity in retrieving pages.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def paginated_results(params = {})
  before  = nil
  max     = 1000
  limit   = 50
  results = []

  loop do
    page = fetch_page(params.merge(before: before, limit: limit)) # imaginary request

    results += page

    yield page

    break if results.length &amp;gt;= max

    before = page.last[&amp;quot;id&amp;quot;]
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To callers of this method, there is an implicit data structure. Being Ruby, we may expect to be able to call &lt;code&gt;Enumerable&lt;/code&gt; methods on this data to inspect, slice, or augment the contents in a convenient way.&lt;/p&gt;

&lt;p&gt;But we may not have access to method&amp;#39;s internals and the underlying data structure, especially if we&amp;#39;re using a method from an external library. This is the case with our &lt;code&gt;paginated_results&lt;/code&gt; example; the &lt;code&gt;results&lt;/code&gt; array is not exposed to the method caller.&lt;/p&gt;

&lt;p&gt;Callers of the method are forced to build up state from the outside. Here&amp;#39;s a contrived example:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;table_of_contents = []
index = 0

client.paginated_results(order: :asc) do |p|
  table_of_contents &amp;lt;&amp;lt; [index+1, p.title] if p.title_page?
end

puts table_of_contents
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;#39;s another way in Ruby! We can &amp;quot;enumeratorize&amp;quot; it!&lt;/p&gt;

&lt;p&gt;Ruby&amp;#39;s &lt;code&gt;to_enum&lt;/code&gt; method is defined on all objects. Quite simply, it can convert a method into &lt;code&gt;Enumerator&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;client.to_enum(:paginated_results, params)
# =&amp;gt; &amp;lt;Enumerator ...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What this gives us is an enumerable object that behaves as if we built up that array ourselves, which means we can call methods from the &lt;code&gt;Enumerable&lt;/code&gt; module, chain other enumerators to augment the block arguments, use &lt;code&gt;lazy&lt;/code&gt;, etc.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;client.to_enum(:paginated_results, params).
  filter(:title_page?).
  map.with_index { |p, i| [i+i, p.title] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I love this type of expression because it&amp;#39;s more direct, flexible, and intention revealing. Authors need be less concerned with building up state with local variables.&lt;/p&gt;

&lt;p&gt;In fact, this pattern is so useful that many authors have started building in &lt;code&gt;to_enum&lt;/code&gt; to such methods for when the caller omits the block. The implementation for &lt;code&gt;paginated_results&lt;/code&gt; might look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def paginated_results(params = {})
  return to_enum(__method__, params) unless block_given?

  # rest unchanged
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While you are free to stick with the imperative approach, I hope this post demonstrates how &lt;code&gt;to_enum&lt;/code&gt; offers Rubyists a more declarative and functionally-flavored alternative.&lt;/p&gt;

      &lt;h3 id="wrapping-up" class="title"&gt;
        &lt;a name="wrapping-up" class="anchor" href="#wrapping-up"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Wrapping up
      &lt;/h3&gt;
    
&lt;p&gt;When you&amp;#39;re in a punch, you can use &lt;code&gt;to_enum&lt;/code&gt; to wrap iterative methods to add otherwise missing &lt;code&gt;Enumerable&lt;/code&gt; properties. And, when designing your classes, consider adopting the &lt;code&gt;return to_enum(__method__) unless block_given?&lt;/code&gt; pattern in method definitions to enhance iterative methods.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Local SSL for Rails 5 development and tests</title>
    <link rel="alternate" href="/blog/local-ssl-for-rails-5.html"/>
    <id>/blog/local-ssl-for-rails-5.html</id>
    <published>2018-09-05T00:00:00+00:00</published>
    <updated>2018-09-05T00:00:00+00:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;Is your Rails app on SSL in production? It may be a good idea to use SSL locally too. It's just that it's typically been a pain to set up for development. Using SSL with Capybara for acceptance tests has traditionally been even more challenging— until...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Is your Rails app on SSL in production? It may be a good idea to use SSL locally too. It&amp;#39;s just that it&amp;#39;s typically been a pain to set up for development. Using SSL with Capybara for acceptance tests has traditionally been even more challenging— until now.&lt;/p&gt;

&lt;p&gt;In this post I&amp;#39;ll demonstrate how I set up my Rails 5 app for local development and system tests over SSL with wildcard domains.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/rossta/local-ssl-demo-rails"&gt;&lt;img src="/assets/images/screenshots/screenshot-local-ssl-demo-4e7a7ffe.png" alt="Local Rails SSL Demo" /&gt;&lt;/a&gt;&lt;/p&gt;

      &lt;h3 id="why-local-ssl-" class="title"&gt;
        &lt;a name="why-local-ssl-" class="anchor" href="#why-local-ssl-"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Why local SSL?
      &lt;/h3&gt;
    
&lt;p&gt;First, a tweet.&lt;/p&gt;

&lt;blockquote class="twitter-tweet" data-lang="en"&gt;&lt;p lang="en" dir="ltr"&gt;I so often get re-explaining from others that &amp;quot;localhost doesn&amp;#39;t need local https&amp;quot;. eyeroll.&lt;br&gt;&lt;br&gt;this is not universally true. this tweet thread is the last time i&amp;#39;m gonna explain. henceforth it will just be linked to.&lt;/p&gt;&amp;mdash; getify (@getify) &lt;a href="https://twitter.com/getify/status/1023202051902373888?ref_src=twsrc%5Etfw"&gt;July 28, 2018&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;p&gt;&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;To summarize Kyle Simpson&amp;#39;s Twitter rant, if your production app is on SSL, you want to develop on local SSL as well to test:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;URL logic (routing, history, redirects, enforcing https)&lt;/li&gt;
&lt;li&gt;No mixed content warnings&lt;/li&gt;
&lt;li&gt;CORS across http or https boundaries&lt;/li&gt;
&lt;li&gt;Web platform features (e.g., geolocation) that require SSL (or will eventually)&lt;/li&gt;
&lt;li&gt;Secure websockets (wss) as the upgrade from https&lt;/li&gt;
&lt;li&gt;Secure cookies, which behave very differently across http vs https boundaries&lt;/li&gt;
&lt;li&gt;Https-specific headers like HSTS or CORS &lt;code&gt;allow-*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Third-party integrations, possibly OAuth-based, that require SSL&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;One knock against local SSL is that it has been considered a pain to set up. This post and the companion gitub repo, &lt;a href="https://github.com/rossta/local-ssl-demo-rails"&gt;rossta/local-ssl-demo-rails&lt;/a&gt;, is intended to help make that task a little easier for Rails apps.&lt;/p&gt;

      &lt;h3 id="how-does-it-work-" class="title"&gt;
        &lt;a name="how-does-it-work-" class="anchor" href="#how-does-it-work-"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        How does it work?
      &lt;/h3&gt;
    
&lt;p&gt;The general workflow I use for setting up my Rails applications for local SSL is as follows:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="#resolve-a-domain-name-to-localhost"&gt;Resolve a domain to localhost&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#create-a-self-signed-certificate"&gt;Create a self-signed SSL certificate&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#trust-the-certificate"&gt;Instruct browsers to trust the certificate&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#configure-the-local-server"&gt;Configure the local server to use the cerficate&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There are plenty of reasonable alternatives to this workflow.&lt;/p&gt;

&lt;p&gt;Jed Schmidt&amp;#39;s excellent &lt;a href="https://gist.github.com/jed/6147872"&gt;How to set up stress-free SSL on an OSX development machine&lt;/a&gt; is also worth checking out; it walks through a similar setup for a Node.js server.&lt;/p&gt;

&lt;p&gt;You could, instead of trusting certificates for each app you develop, create your own &lt;a href="https://deliciousbrains.com/ssl-certificate-authority-for-local-https-development/"&gt;SSL certificate authority&lt;/a&gt;. The setup steps are more invovled, but once your local CA is trusted by browsers, you can skip the process of manually trusting each cert.&lt;/p&gt;

&lt;p&gt;Or, use &lt;a href="https://ngrok.com"&gt;ngrok&lt;/a&gt;, a zero-configuration service for running your localhost server over a secure URL. While this approach may work well for local development, I currently don&amp;#39;t know of anyone using it for tests or CI environments. Learn more on setting up ngrok from &lt;a href="https://www.remotesynthesis.com/blog/running-ssl-localhost"&gt;this post by Brian Rinaldi&lt;/a&gt;.&lt;/p&gt;

      &lt;h3 id="resolve-a-domain-name-to-localhost" class="title"&gt;
        &lt;a name="resolve-a-domain-name-to-localhost" class="anchor" href="#resolve-a-domain-name-to-localhost"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Resolve a domain name to localhost
      &lt;/h3&gt;
    
&lt;p&gt;To use SSL locally for a custom domain, i.e., something besides &lt;code&gt;localhost&lt;/code&gt;, you&amp;#39;ll need to find a way to route requests for that domain back to your local IP; for this post we&amp;#39;ll assume the IP is &lt;code&gt;127.0.0.1&lt;/code&gt;. It may be something else if you&amp;#39;re developing on a separate VM such as through Vagrant.&lt;/p&gt;

&lt;p&gt;Here are a few alternatives for using a custom domain name for local development and tests.&lt;/p&gt;

      &lt;h4 id="manual-configuration" class="title"&gt;
        &lt;a name="manual-configuration" class="anchor" href="#manual-configuration"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Manual configuration
      &lt;/h4&gt;
    
&lt;p&gt;The simplest approach is to add an entry for each domain you want to use to your &lt;code&gt;/etc/hosts&lt;/code&gt; file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# /etc/hosts

127.0.0.1     localhost.ross
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The disadvantage is that &lt;code&gt;/etc/hosts&lt;/code&gt; does not support wildcard domains, so you would need to add an entry for every unique domain you plan to use.&lt;/p&gt;

      &lt;h4 id="dynamic-local-domains" class="title"&gt;
        &lt;a name="dynamic-local-domains" class="anchor" href="#dynamic-local-domains"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Dynamic local domains
      &lt;/h4&gt;
    
&lt;p&gt;For more flexible approach, you may want to use &lt;code&gt;dnsmasq&lt;/code&gt; to route arbitrary domain names wherever you want. In our case, we can use it to send all traffic on a custom tld back to our local machine.&lt;/p&gt;

&lt;p&gt;The following script (adapted from Jed) will install and configure dnsmasq. The dnsmasq server will resolve all requests to the top level domain &lt;code&gt;.ross&lt;/code&gt; on my local machine back to &lt;code&gt;127.0.0.1&lt;/code&gt;. (Replace &lt;code&gt;$(whoami)&lt;/code&gt; with your preferred top-level domain):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;local_tld=$(whoami)
brew install dnsmasq
mkdir -pv $(brew --prefix)/etc
sudo cp -v $(brew --prefix dnsmasq)/homebrew.mxcl.dnsmasq.plist /Library/LaunchDaemons
sudo launchctl load -w /Library/LaunchDaemons/homebrew.mxcl.dnsmasq.plist
sudo mkdir -pv /etc/resolver
echo &amp;quot;address=/.$local_tld/127.0.0.1&amp;quot; | sudo tee -a $(brew --prefix)/etc/dnsmasq.conf
echo &amp;quot;nameserver 127.0.0.1&amp;quot; | sudo tee /etc/resolver/$local_tld
&lt;/code&gt;&lt;/pre&gt;

      &lt;h4 id="use-a-registered-domain-name" class="title"&gt;
        &lt;a name="use-a-registered-domain-name" class="anchor" href="#use-a-registered-domain-name"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Use a registered domain name
      &lt;/h4&gt;
    
&lt;p&gt;Or, purchase a domain and add A records to resolve the appex and wildcard subdomains to &lt;code&gt;127.0.0.1&lt;/code&gt;. This is the approach used by known &amp;quot;localhost&amp;quot; domains like &lt;code&gt;lvh.me&lt;/code&gt; or &lt;code&gt;xip.io&lt;/code&gt;.&lt;/p&gt;

      &lt;h3 id="create-a-self-signed-certificate" class="title"&gt;
        &lt;a name="create-a-self-signed-certificate" class="anchor" href="#create-a-self-signed-certificate"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Create a self-signed certificate
      &lt;/h3&gt;
    
&lt;p&gt;The following script (adapted from Jed) will generate a self-signed certificate and private key for &lt;code&gt;localhost.ross&lt;/code&gt; on my machine.&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;name=localhost.$(whoami)
openssl req \
  -new \
  -newkey rsa:2048 \
  -sha256 \
  -days 3650 \
  -nodes \
  -x509 \
  -keyout $name.key \
  -out $name.crt \
  -config &amp;lt;(cat &amp;lt;&amp;lt;-EOF
  [req]
  distinguished_name = req_distinguished_name
  x509_extensions = v3_req
  prompt = no
  [req_distinguished_name]
  CN = $name
  [v3_req]
  keyUsage = keyEncipherment, dataEncipherment
  extendedKeyUsage = serverAuth
  subjectAltName = @alt_names
  [alt_names]
  DNS.1 = $name
  DNS.2 = *.$name
EOF
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The key/certificate files generated on my machine would be named &lt;code&gt;localhost.ross.key&lt;/code&gt; and &lt;code&gt;localhost.ross.crt&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To generate a tld for a different domain, change &lt;code&gt;localhost.$(whoami)&lt;/code&gt; to your own desired domain name. You can omit the line &lt;code&gt;DNS.2 = *.$name&lt;/code&gt; if you don&amp;#39;t need wildcard subdomains or if you&amp;#39;re simply setting up SSL for &lt;code&gt;localhost&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For Rails projects, I typically generate separate key/pairs using different domain names for each project and move  each file pair to my Rails &lt;code&gt;config&lt;/code&gt; directory:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;mkdir -p config/ssl
mv localhost.ross.key localhost.ross.crt config/ssl
&lt;/code&gt;&lt;/pre&gt;

      &lt;h3 id="trust-the-certificate" class="title"&gt;
        &lt;a name="trust-the-certificate" class="anchor" href="#trust-the-certificate"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Trust the certificate
      &lt;/h3&gt;
    
&lt;p&gt;On macOS, we can trust the certificate in the System Keychain with this one-liner.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain config/ssl/localhost.ross.crt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a variety of blog posts out there that demonstrate how to do this manually through the Keychain application; that should work too.&lt;/p&gt;

      &lt;h3 id="configure-the-local-server" class="title"&gt;
        &lt;a name="configure-the-local-server" class="anchor" href="#configure-the-local-server"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Configure the local server
      &lt;/h3&gt;
    
&lt;p&gt;Now that we have a trusted certificate, we can configure Puma with our key/certificate pair to serve local SSL requests for both &lt;code&gt;development&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; on our custom domain. (You could also use Nginx to proxy local requests and &lt;a href="http://nginx.org/en/docs/http/configuring_https_servers.html"&gt;set up your Nginx config with your SSL certificate&lt;/a&gt;).&lt;/p&gt;

      &lt;h4 id="in-development" class="title"&gt;
        &lt;a name="in-development" class="anchor" href="#in-development"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        In development
      &lt;/h4&gt;
    
&lt;p&gt;First, I&amp;#39;ll typically move my self-signed key and certificate into the Rails project directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;cd path/to/my/rails/app
mkdir config/ssl
mv path/to/localhost.ross.{key,crt} config.ssl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With puma, we can bind the server to an SSL url on startup by providing paths to the key/certificate pair generated in the previous step.&lt;/p&gt;

&lt;p&gt;Now, when starting the rails server from the root of the project for local development, I&amp;#39;ll specify the ssl binding as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;rails s -b &amp;#39;ssl://127.0.0.1:3000?key=config/ssl/localhost.ross.key&amp;amp;cert=config/ssl/localhost.ross.crt&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since I use &lt;code&gt;foreman&lt;/code&gt; to run my application locally, I&amp;#39;ll place the command in the &lt;code&gt;Procfile.dev&lt;/code&gt; file and substitute the port number with the &lt;code&gt;$PORT&lt;/code&gt; variable:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;rails s -b &amp;#39;ssl://127.0.0.1:$PORT?key=config/ssl/localhost.ross.key&amp;amp;cert=config/ssl/localhost.ross.crt&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Puma also provides a hook to &lt;a href="https://github.com/puma/puma/blob/395337df4a3b27cc14eeab048016fb1ee85d2f83/examples/config.rb#L79"&gt;set this binding in the config file&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you&amp;#39;re using Webpack with the &lt;code&gt;webpacker&lt;/code&gt; gem to bundle javascript and other static assets, you will want to connect to the &lt;code&gt;webpack-dev-server&lt;/code&gt; in development over SSL. This can be done in the &lt;code&gt;config/webpacker.yml&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class="yml"&gt;# config/webpacker.yml
development:
  &amp;lt;&amp;lt;: *default
  # ...
  dev_server:
    https: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In recent versions of &lt;code&gt;webpacker-dev-server&lt;/code&gt;, the SSL certificate is generated on your behalf; you may have to trust this certificate manually in Keychain separately to avoid invalid certificate errors in the browser.&lt;/p&gt;

      &lt;h4 id="in-tests" class="title"&gt;
        &lt;a name="in-tests" class="anchor" href="#in-tests"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        In tests
      &lt;/h4&gt;
    
&lt;p&gt;Using our SSL certificates for local Rails testing is mostly relevant for system tests (aka acceptance or feature tests) where we would typically use Capybara to launch a real app server. Setting up Capybara to handle SSL requests has been painful, possibly involving some &lt;a href="https://gist.github.com/Papierkorb/1787d28874443ec760d1"&gt;server monkeypatching&lt;/a&gt; to wire everything up.&lt;/p&gt;

&lt;p&gt;As of Capybara &lt;code&gt;&amp;gt;= 3.1.0&lt;/code&gt;, it&amp;#39;s much easier to pass configuration to the underlying Puma server to include our SSL certificates (&lt;a href="https://github.com/teamcapybara/capybara/pull/2028"&gt;commit&lt;/a&gt;) using a binding similar to our startup command in development:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;Capybara.server = :puma, server: {
  Host: &amp;quot;ssl://#{Capybara.server_host}?key=config/ssl/localhost.ross.key&amp;amp;cert=config/ssl/localhost.ross.crt&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;System tests also rely on a web driver to control the browser; in most cases, these web drivers will ignore the invalid certificate warnings. To get the newer headless versions of Chrome and Firefox to play nicely with SSL, I&amp;#39;ve found that some extra configuration is required.&lt;/p&gt;

&lt;p&gt;First, let&amp;#39;s use the &lt;code&gt;webdrivers&lt;/code&gt; gem to make sure we have the latest binaries for &lt;code&gt;chromedriver&lt;/code&gt; and &lt;code&gt;geckodriver&lt;/code&gt; to test against Chrome and Firefox respectively.&lt;/p&gt;

&lt;p&gt;Previously invalid SSL certificates could not work in headless Chrome so system tests under SSL were not possible in this mode. But with the recent release of Chrome 65, this changed. We can now set up headless Chrome driver with capabilities to accept invalid SSL certificates like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;Capybara.register_driver(:headless_chrome_ssl) do |app|
  options = Selenium::WebDriver::Chrome::Options.new(
    args: %w[--headless --disable-gpu --no-sandbox --disable-web-security],
  )
  capabilities = Selenium::WebDriver::Remote::Capabilities.chrome(
    acceptInsecureCerts: true,
  )
  Capybara::Selenium::Driver.new(
    app,
    browser: :chrome,
    options: options,
    desired_capabilities: capabilities
  )
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can switch to our new driver in RSpec with a hook like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;RSpec.configure do |config|
  config.before(:each, type: :system, js: true) do
    driven_by :headless_chrome_ssl
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For Firefox, the driver configuration is similar:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;Capybara.register_driver(:headless_firefox_ssl) do |app|
  options = Selenium::WebDriver::Firefox::Options.new(args: %w[--headless])

  capabilities = Selenium::WebDriver::Remote::Capabilities.firefox(
    acceptInsecureCerts: true,
  )
  Capybara::Selenium::Driver.new(
    app,
    browser: :firefox,
    options: options,
    desired_capabilities: capabilities
  )
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With our server and drivers configured, we set our default Capybara app host with our custom domain on https:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;Capybara.app_host = &amp;quot;https://www.localhost.ross&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;#39;re set up to run system tests over SSL!&lt;/p&gt;

      &lt;h3 id="requirements" class="title"&gt;
        &lt;a name="requirements" class="anchor" href="#requirements"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Requirements
      &lt;/h3&gt;
    
&lt;p&gt;Below is a list of binaries and gems with the versions used in for the &lt;a href="https://github.com/rossta/local-ssl-demo-rails"&gt;demo app&lt;/a&gt;. It may be possible to make this work with other relatively recent versions of these tools, though your mileage may vary.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ openssl version
LibreSSL 2.2.7

$ ruby -v
ruby 2.4.1p111 (2017-03-22 revision 58053) [x86_64-darwin16]

$ /Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --version
Google Chrome 68.0.3440.106

$ /Applications/Firefox.app/Contents/MacOS/firefox --version
Mozilla Firefox 60.0.1

$ ~/.webdrivers/chromedriver -v
ChromeDriver 2.41.578706 (5f725d1b4f0a4acbf5259df887244095596231db)

$ ~/.webdrivers/geckodriver --version
geckodriver 0.21.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And selected Ruby gems in the &lt;code&gt;Gemfile&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;gem &amp;#39;rails&amp;#39;, &amp;#39;~&amp;gt; 5.2.1&amp;#39;
gem &amp;#39;puma&amp;#39;, &amp;#39;~&amp;gt; 3.12&amp;#39;
gem &amp;#39;webpacker&amp;#39;, &amp;#39;~&amp;gt; 3.5.5&amp;#39; # optional

group :test do
  gem &amp;#39;capybara&amp;#39;, &amp;#39;~&amp;gt; 3.5.1&amp;#39;
  gem &amp;#39;selenium-webdriver&amp;#39;, &amp;#39;~&amp;gt; 3.14.0&amp;#39;
  gem &amp;#39;webdrivers&amp;#39;, &amp;#39;~&amp;gt; 3.3.3&amp;#39;
  gem &amp;#39;rspec-rails&amp;#39;, &amp;#39;~&amp;gt; 3.8.0&amp;#39; # optional
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Other versions of these tools may work fine. For example, Puma server configuration was added to Capybara as of &lt;code&gt;3.1.0&lt;/code&gt; and &lt;code&gt;chromedriver&lt;/code&gt; added support for the &lt;code&gt;acceptInsecureCerts&lt;/code&gt; flag in 2.35/Chrome 65. Just be aware that possible issues may arise otherwise, as &lt;a href="https://stackoverflow.com/questions/51881206/using-acceptinsecurecerts-with-headless-chrome-and-selenium-webdriver-macos-ra"&gt;I found out&lt;/a&gt; by inadvertently using an older version of &lt;code&gt;chromedriver&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I recommend the &lt;code&gt;webdrivers&lt;/code&gt; gem as it will install the lastest driver binaries as needed on your behalf, including &lt;code&gt;chromedriver&lt;/code&gt; for Chrome and &lt;code&gt;geckodriver&lt;/code&gt; for Firefox. Many other posts may instruct you to install &lt;code&gt;chromedriver&lt;/code&gt; with Homebrew or point to the &lt;code&gt;chromedriver-helper&lt;/code&gt; gem; these may work just fine for you, though it will be up to you to keep the drivers updated.&lt;/p&gt;

      &lt;h3 id="wrapping-up" class="title"&gt;
        &lt;a name="wrapping-up" class="anchor" href="#wrapping-up"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Wrapping up
      &lt;/h3&gt;
    
&lt;p&gt;If you&amp;#39;re onboard with &amp;quot;SSL everywhere&amp;quot;, let that include &lt;code&gt;localhost&lt;/code&gt; as well. Getting SSL set up for Rails development and test requires a bit of effort, but it&amp;#39;s easier than ever before with the introduction of Rails system tests and recent improvements to Puma, Capybara, Selenium, and the Chrome and Firefox web drivers.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Extracting a data component in Vue</title>
    <link rel="alternate" href="/blog/extracting-a-data-component-in-vue.html"/>
    <id>/blog/extracting-a-data-component-in-vue.html</id>
    <published>2018-07-15T00:00:00+00:00</published>
    <updated>2018-07-15T00:00:00+00:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;Vue components don't have to just be about displaying information and user interaction. In this post, we'll show how to build a component whose main job is to simply fetch data for other components. We'll use props, events, and scoped-slots to tie...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Vue components don&amp;#39;t have to just be about displaying information and user interaction. In this post, we&amp;#39;ll show how to build a component whose main job is to simply fetch data for other components. We&amp;#39;ll use props, events, and scoped-slots to tie the pieces together.&lt;/p&gt;

      &lt;h3 id="the-project" class="title"&gt;
        &lt;a name="the-project" class="anchor" href="#the-project"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        The project
      &lt;/h3&gt;
    
&lt;p&gt;This post is part of ongoing series, &lt;a href="/blog/series/pdf-viewer.html"&gt;Building a PDF Viewer with Vue.js&lt;/a&gt;. The source code for this project is on Github at &lt;a href="https://github.com/rossta/vue-pdfjs-demo"&gt;rossta/vue-pdfjs-demo&lt;/a&gt;. To see the source described in this post, &lt;a href="https://github.com/rossta/vue-pdfjs-demo/tree/tutorial/part-3-renderless-components"&gt;checkout the branch&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here&amp;#39;s the latest &lt;a href="https://rossta.net/vue-pdfjs-demo/"&gt;project demo&lt;/a&gt;.&lt;/p&gt;

      &lt;h3 id="catching-up-from-last-time" class="title"&gt;
        &lt;a name="catching-up-from-last-time" class="anchor" href="#catching-up-from-last-time"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Catching up from last time
      &lt;/h3&gt;
    
&lt;p&gt;So far in &lt;a href="/blog/series/pdf-viewer.html"&gt;this series&lt;/a&gt;, we have built a simple PDF viewer to render the pages of PDF document to &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; elements with Vue. We have also updated our components to fetch and render PDF pages lazily as they are scrolled into the viewport. For the next feature, we want to build a preview pane into the left-hand side of the viewer.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/screenshots/screenshot-pdf-viewer-part-3-28bad22b.jpg" alt="Preview of the preview" /&gt;&lt;/p&gt;

&lt;p&gt;This preview pane will display the entire document (as smaller, clickable thumbnails), be independently-scrollable, and render PDF pages lazily, i.e., it will behave a lot like our current &lt;code&gt;&amp;lt;PDFDocument&amp;gt;&lt;/code&gt;. First, we&amp;#39;d like to make some of our current code reusable.&lt;/p&gt;

      &lt;h3 id="the-why" class="title"&gt;
        &lt;a name="the-why" class="anchor" href="#the-why"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        The why
      &lt;/h3&gt;
    
&lt;p&gt;The Vue docs provide helpful examples for using &lt;a href="https://vuejs.org/v2/guide/mixins.html"&gt;mixins&lt;/a&gt;, &lt;a href="https://vuejs.org/v2/guide/custom-directive.html"&gt;custom directives&lt;/a&gt;, and more. My preferred approach for sharing component functionality is &lt;em&gt;composition&lt;/em&gt;, which means extracting shared code into separate components. In this post, we&amp;#39;ll be using composition to reuse data fetching.&lt;/p&gt;

&lt;p&gt;Why composition? This topic deserves a separate post, but as a start, it&amp;#39;s my preference. Borrowing from general object-oriented programming advice, I gravitate towards &amp;quot;composition over inheritance&amp;quot;. Practically, in Vue, this means I&amp;#39;d like to think &amp;quot;component-first&amp;quot;, before reaching for mixins or &lt;code&gt;extends&lt;/code&gt; (these are basically forms of inheritance).&lt;/p&gt;

&lt;p&gt;I also happen to agree with the drawbacks Dan Abramov enumerates in &lt;a href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html"&gt;Mixins Considered Harmful&lt;/a&gt;; though the context for his post is React, most of his points are relevant to Vue as well.&lt;/p&gt;

&lt;p&gt;As for this particular use case, we could reuse the data fetching code we wrote previously as a mixin, there&amp;#39;s a clear problem with that approach. It would mean the components that make use of the mixin would fetch the same data independently (without extracting some other mechanism to share the data source)—which is potentially some wasted work. This may be desired for some applications, we&amp;#39;d prefer to only fetch the PDF page data once.&lt;/p&gt;

&lt;p&gt;It&amp;#39;s also worth noting that we&amp;#39;re not currently using &lt;a href="https://vuex.vuejs.org"&gt;Vuex&lt;/a&gt; to manage application state in the project. It may be wise, as an alternative to what&amp;#39;s described in this post, to introduce Vuex to fetch data by dispatching actions and triggering state mutations at the appropriate times. However, at this point, our data flow is fairly straightforward, top-to-bottom, which, in my opinion, favors the component-first approach. It&amp;#39;s also simply a worthy exercise to consider data components.&lt;/p&gt;

      &lt;h3 id="bird-39-s-eye-view" class="title"&gt;
        &lt;a name="bird-39-s-eye-view" class="anchor" href="#bird-39-s-eye-view"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Bird&amp;#39;s eye view
      &lt;/h3&gt;
    
&lt;p&gt;Let&amp;#39;s take a look at where we are and where we want to go. Prior to adding our feature, our component hierarchy looks like the following pseudocode:&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;PDFDocument&amp;gt;
  &amp;lt;PDFPage /&amp;gt;
  &amp;lt;PDFPage /&amp;gt;
  &amp;lt;PDFPage /&amp;gt;
  ...
&amp;lt;/PDFDocument&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For our new preview feature, our preview and document components will live side-by-side.&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;PDFPreview&amp;gt;
  &amp;lt;PDFThumbnail /&amp;gt;
  &amp;lt;PDFThumbnail /&amp;gt;
  &amp;lt;PDFThumbnail /&amp;gt;
  ...
&amp;lt;/PDFPreview&amp;gt;
&amp;lt;PDFDocument&amp;gt;
  &amp;lt;PDFPage /&amp;gt;
  &amp;lt;PDFPage /&amp;gt;
  &amp;lt;PDFPage /&amp;gt;
  ...
&amp;lt;/PDFDocument&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our &lt;code&gt;&amp;lt;PDFPreview&amp;gt;&lt;/code&gt; needs access to the same PDF data as our &lt;code&gt;&amp;lt;PDFDocument&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To achieve this, we&amp;#39;re going to wrap both the &lt;code&gt;&amp;lt;PDFPreview&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;PDFThumbnail&amp;gt;&lt;/code&gt; in another component, whose only responsibility will be to respond to events to request page data, which it will pass to its children as props. With this approach, there is only one data source shared by the two display components.&lt;/p&gt;

&lt;p&gt;So our heirarchy will eventually look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;PDFData&amp;gt; &amp;lt;!-- passes page data to children --&amp;gt;

  &amp;lt;PDFPreview&amp;gt; &amp;lt;!-- emits events to request more pages --&amp;gt;
    ...
  &amp;lt;/PDFPreview&amp;gt;
  &amp;lt;PDFDocument&amp;gt; &amp;lt;!-- emits events to request more pages --&amp;gt;
    ...
  &amp;lt;/PDFDocument&amp;gt;

&amp;lt;/PDFData&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we will have decoupled the logic for batching and requesting page data over the wire from the interactions and events that will trigger that behavior. For our viewer, either our document or future preview components can trigger data fetching. The data component needs to know nothing about the scrolling behavior or the logic that determines when additional pages are needed.&lt;/p&gt;

&lt;p&gt;Next we&amp;#39;ll take a look at how this data component is constructed and how it will pass data to the child components.&lt;/p&gt;

      &lt;h3 id="extracting-the-data-component" class="title"&gt;
        &lt;a name="extracting-the-data-component" class="anchor" href="#extracting-the-data-component"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Extracting the data component
      &lt;/h3&gt;
    
&lt;p&gt;Currently, the data fetching logic resides in our &lt;code&gt;&amp;lt;PDFDocument&amp;gt;&lt;/code&gt; component. There is a method that encapsulates the logic for &lt;a href="https://github.com/rossta/vue-pdfjs-demo/blob/4be84574ce6837379dd90b4d68194ea19b172734/src/components/PDFDocument.vue#L145"&gt;fetching pages in batches&lt;/a&gt;, &lt;a href="https://github.com/rossta/vue-pdfjs-demo/blob/4be84574ce6837379dd90b4d68194ea19b172734/src/components/PDFDocument.vue#L177"&gt;watchers&lt;/a&gt; for responding to changes in the given &lt;code&gt;url&lt;/code&gt; prop and &lt;code&gt;pdf&lt;/code&gt; proxy object, and relevant &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;computed&lt;/code&gt; properties for maintaining the state of PDF data. You can see &lt;a href="https://rossta.net/blog/building-a-pdf-viewer-with-vue-part-2.html"&gt;the previous post&lt;/a&gt; for more info on the implementation details. We&amp;#39;ll move this functionality to a new &lt;code&gt;&amp;lt;PDFData&amp;gt;&lt;/code&gt; component:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFData.vue

props: {
  url: {
    type: String,
    required: true,
  },
},

data() {
  return {
    pages: undefined,
    pages: [],
    cursor: 0,
    // ...
  };
},

methods: {
  fetchPages() {
    // fetches next batch and appends to this.pages
  },
},

computed: {
  pageCount() {
    return this.pdf ? this.pdf.numPages : 0;
  },
},

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This component will be &amp;quot;renderless&amp;quot;* (almost), meaning it will delegate rendering to its children. We&amp;#39;ll use scoped slots to pass the &lt;code&gt;this.pages&lt;/code&gt; data to the preview and document components. The &lt;code&gt;&amp;lt;PDFData&amp;gt;&lt;/code&gt; needs to nothing about its children, only that it will pass data to its named children, &lt;code&gt;preview&lt;/code&gt; and &lt;code&gt;document&lt;/code&gt;, in its own render function:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFData.vue

render(h) {
  return h(&amp;#39;div&amp;#39;, [
    this.$scopedSlots.preview({
      pages: this.pages,
    }),
    this.$scopedSlots.document({
      pages: this.pages,
    }),
  ]);
},

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*Technically, this component isn&amp;#39;t &amp;quot;renderless&amp;quot;—it inserts an additional &lt;code&gt;div&lt;/code&gt; as a root to its scoped slots children. Otherwise, the error &lt;code&gt;Multiple root nodes returned from render function. Render function should return a single root node.&lt;/code&gt; is raised in the current version of Vue I&amp;#39;m using (&lt;code&gt;2.5.16&lt;/code&gt;). The main point is that we can use components in our component hierarchy that add functionality but handoff display responsibility to its children.&lt;/p&gt;

      &lt;h3 id="communicating-with-the-children" class="title"&gt;
        &lt;a name="communicating-with-the-children" class="anchor" href="#communicating-with-the-children"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Communicating with the children
      &lt;/h3&gt;
    
&lt;p&gt;In the &lt;code&gt;&amp;lt;PDFViewer&amp;gt;&lt;/code&gt; we can use the &lt;code&gt;slot&lt;/code&gt; attribute to render the children in the correct place and &lt;code&gt;slot-scope&lt;/code&gt; to receive the &lt;code&gt;pages&lt;/code&gt; property from the &lt;code&gt;&amp;lt;PDFData&amp;gt;&lt;/code&gt; component. Though we haven&amp;#39;t created the &lt;code&gt;&amp;lt;PDFPreview&amp;gt;&lt;/code&gt; components, here&amp;#39;s our template for the &lt;code&gt;&amp;lt;PDFViewer&amp;gt;&lt;/code&gt; responsible for gluing everything together.&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;!-- src/components/PDFViewer.vue --&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;PDFData&amp;gt;
    &amp;lt;!-- At this point in the tutorial, PDFPreview
    doesn&amp;#39;t exist, but this is where it will go. --&amp;gt;
    &amp;lt;PDFPreview
      slot=&amp;quot;preview&amp;quot;
      slot-scope=&amp;quot;{pages}&amp;quot;
      v-bind=&amp;quot;{pages}&amp;quot;
      /&amp;gt;

    &amp;lt;PDFDocument
      slot=&amp;quot;document&amp;quot;
      slot-scope=&amp;quot;{pages}&amp;quot;
      v-bind=&amp;quot;{pages}&amp;quot;
      /&amp;gt;
  &amp;lt;/PDFData&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To trigger data fetching, the &lt;code&gt;&amp;lt;PDFData&amp;gt;&lt;/code&gt; component will listen for the &lt;code&gt;pages-fetch&lt;/code&gt; event. Since we&amp;#39;re using a render function, we won&amp;#39;t be able to use the template syntax for binding to events. Instead, we&amp;#39;ll attach the event listener using &lt;code&gt;this.$on&lt;/code&gt; in the &lt;code&gt;created&lt;/code&gt; hook:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFData.vue

created() {
  this.$on(&amp;#39;pages-fetch&amp;#39;, this.fetchPages);
},

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need to set up our &lt;code&gt;&amp;lt;PDFDocument&amp;gt;&lt;/code&gt; to communicate with the &lt;code&gt;&amp;lt;PDFData&amp;gt;&lt;/code&gt; component. We update &lt;code&gt;&amp;lt;PDFDocument&lt;/code&gt; to accept &lt;code&gt;pages&lt;/code&gt; as props now that it is now longer responsible for fetching this data. Its &lt;code&gt;fetchPages&lt;/code&gt; method, called when the component mounts or during scrolling, we&amp;#39;ll leave in place but change its implementation (now owned by its parent &lt;code&gt;&amp;lt;PDFData&amp;gt;&lt;/code&gt; component) to simply emit the &lt;code&gt;pages-fetch&lt;/code&gt; event, for which &lt;code&gt;&amp;lt;PDFData&amp;gt;&lt;/code&gt; is listening.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue

props: {
  pages: {
    type: Array,
    required: true,
  },
},

data() {
  return {
    // removed pages and pdf properties
    // ...
  };
},

methods: {
  fetchPages() {
    this.$emit(&amp;#39;pages-fetch&amp;#39;);
  },

  // ...
}
&lt;/code&gt;&lt;/pre&gt;

      &lt;h3 id="wrapping-up" class="title"&gt;
        &lt;a name="wrapping-up" class="anchor" href="#wrapping-up"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Wrapping up
      &lt;/h3&gt;
    
&lt;p&gt;That does it! We&amp;#39;ve extracted data fetching logic completely out of the &lt;code&gt;&amp;lt;PDFDocument&amp;gt;&lt;/code&gt; into the &lt;code&gt;&amp;lt;PDFData&amp;gt;&lt;/code&gt;. We&amp;#39;ve avoided the &lt;a href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html"&gt;drawbacks of introducing mixins&lt;/a&gt; to share behavior. Our new data component will show up separately in the Vue dev tools extension for better debugging. The application is also easier to extend so we can now add new functionality, like the preview pane. We also have a nice alternative to Vuex, which would be a new dependency, to managing a portion of our application state.&lt;/p&gt;

&lt;p&gt;In the next post, we&amp;#39;ll look at extracting shared behavior so that both our preview and document components can be independently scrollable and either can trigger additional data-fetching when the scrolled to the bottom.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Displaying PDFs lazily with Vue</title>
    <link rel="alternate" href="/blog/building-a-pdf-viewer-with-vue-part-2.html"/>
    <id>/blog/building-a-pdf-viewer-with-vue-part-2.html</id>
    <published>2018-07-07T00:00:00+00:00</published>
    <updated>2018-07-07T00:00:00+00:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;As we demonstrated in the &lt;a href="/blog/building-a-pdf-viewer-with-vue-part-1.html"&gt;previous post&lt;/a&gt;, we can render pages of a PDF to &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; elements using PDF.js and Vue. We were able to use a simple Vue component hierarchy to separate the responsibilities of data fetching and page rendering. We used the...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;As we demonstrated in the &lt;a href="/blog/building-a-pdf-viewer-with-vue-part-1.html"&gt;previous post&lt;/a&gt;, we can render pages of a PDF to &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; elements using PDF.js and Vue. We were able to use a simple Vue component hierarchy to separate the responsibilities of data fetching and page rendering. We used the PDF.js library to fetch the page data and hand off the work of drawing the data onto &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; elements.&lt;/p&gt;

&lt;p&gt;In this post, we&amp;#39;ll add a new requirement: we should only render pages when they are visible, i.e., as they are scrolled into the viewport. Previously, we were rendering all pages eagerly, regardless of whether they were appearing in the client browser. For a large PDF, this could mean valuable resources are used to render many pages offscreen and may never be viewed. Let&amp;#39;s see how we can fix that using Vue.&lt;/p&gt;

&lt;p&gt;The latest source code for this project is on Github at &lt;a href="https://github.com/rossta/vue-pdfjs-demo"&gt;rossta/vue-pdfjs-demo&lt;/a&gt;. To see the version of the project described in this post, &lt;a href="https://github.com/rossta/vue-pdfjs-demo/tree/tutorial/part-2-scrolling"&gt;checkout the &lt;code&gt;part-2-scrolling&lt;/code&gt; branch&lt;/a&gt;. Here&amp;#39;s the &lt;a href="https://rossta.net/vue-pdfjs-demo/"&gt;project demo&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;a href="https://rossta.net/vue-pdfjs-demo/"&gt;&lt;img src="/assets/images/screenshots/screenshot-pdf-viewer-61e237fc.png" alt="Demo" /&gt;&lt;/a&gt;&lt;/p&gt;

      &lt;h3 id="adding-scroll-behavior" class="title"&gt;
        &lt;a name="adding-scroll-behavior" class="anchor" href="#adding-scroll-behavior"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Adding scroll behavior
      &lt;/h3&gt;
    
&lt;p&gt;To review, once a &lt;code&gt;&amp;lt;PDFPage&amp;gt;&lt;/code&gt; component mounts, it calls the &lt;code&gt;page.render&lt;/code&gt; method to draw the PDF data to the &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; element. To defer page rendering, this method should only be called once the &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; element has become visible in the scroll window of the document. We&amp;#39;ll detect visibility of the page by inferring from the scroll boundaries or the parent component, &lt;code&gt;&amp;lt;PDFDocument&amp;gt;&lt;/code&gt; along with the position and dimensions of the child &lt;code&gt;&amp;lt;PDFPage&amp;gt;&lt;/code&gt; components.&lt;/p&gt;

&lt;p&gt;First, a CSS change to make our document scrollable within a relatively positioned parent element.&lt;/p&gt;

&lt;pre&gt;&lt;code class="css"&gt;.pdf-document {
  position: absolute;
  overflow: auto;
  width: 100%;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;&amp;lt;PDFDocument&amp;gt;&lt;/code&gt; will track its visible boundaries using the &lt;code&gt;scrollTop&lt;/code&gt; and &lt;code&gt;clientHeight&lt;/code&gt; properties of its element. We&amp;#39;ll record these boundaries when the component mounts.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue

data() {
  return {
    scrollTop: 0,
    clientHeight: 0,
    // ...
  };
},

methods: {
  updateScrollBounds() {
    const {scrollTop, clientHeight} = this.$el;
    this.scrollTop = scrollTop;
    this.clientHeight = clientHeight;
  },
  // ...
},

mounted() {
  this.updateScrollBounds();
},
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;scrollTop&lt;/code&gt; according to &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop"&gt;MDN&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An element&amp;#39;s &lt;code&gt;scrollTop&lt;/code&gt; value is a measurement of the distance from the element&amp;#39;s top to its topmost &lt;em&gt;visible&lt;/em&gt; content.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The &lt;code&gt;clientHeight&lt;/code&gt; according to &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight"&gt;MDN&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;clientHeight&lt;/code&gt; read-only property is zero for elements with no CSS or inline layout boxes, otherwise it&amp;#39;s the inner height of an element in pixels, including padding but not the horizontal scrollbar height, border, or margin.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Used together, we can determine what portion of the document is visible to the user.&lt;/p&gt;

      &lt;h3 id="detecting-page-visibility" class="title"&gt;
        &lt;a name="detecting-page-visibility" class="anchor" href="#detecting-page-visibility"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Detecting page visibility
      &lt;/h3&gt;
    
&lt;p&gt;The &lt;code&gt;&amp;lt;PDFPage&amp;gt;&lt;/code&gt; component will track the boundaries of its underlying canvas element, whose dimensions we demonstrated how to calculate in the previous post. As with the document component, we&amp;#39;ll trigger the update of this data property when the page component mounts:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFPage.vue

data() {
  return {
    elementTop: 0,
    elementHeight: 0,
    // ...
  };
},

methods: {
  updateElementBounds() {
    const {offsetTop, offsetHeight} = this.$el;
    this.elementTop = offsetTop;
    this.elementHeight = offsetHeight;
  },
  // ...
},

mounted() {
  this.updateElementBounds();
},
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The element&amp;#39;s &lt;code&gt;offsetTop&lt;/code&gt; property will represent the distance from its top boundary to that of the containing document element &lt;code&gt;div&lt;/code&gt;. Recording its &lt;code&gt;offsetHeight&lt;/code&gt; enables us to determine how far the bottom of the element is from the top of the container.&lt;/p&gt;

&lt;p&gt;Note that the &lt;code&gt;updateElementBounds&lt;/code&gt; and &lt;code&gt;updateScrollBounds&lt;/code&gt; methods are necessary because properties of DOM elements are outside of Vue&amp;#39;s control, i.e., they are not reactive. These methods exist to maintain reactive copies of these properties in Vue and we must trigger them somehow when scrolling or resizing the window so that the changes will propagate.&lt;/p&gt;

&lt;p&gt;Since we can pass the scroll data of the parent component to the child page components as props, we now have what we need to determine if a given page is visible in the scroll area of the document.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFPage.vue

props: {
  scrollTop: {
    type: Number,
    default: 0
  },
  clientHeight: {
    type: Number,
    default: 0
  },
  // ...
},

computed: {
  isElementVisible() {
    const {elementTop, elementBottom, scrollTop, scrollBottom} = this;
    if (!elementBottom) return;

    return elementTop &amp;lt; scrollBottom &amp;amp;&amp;amp; elementBottom &amp;gt; scrollTop;
  },

  elementBottom() {
    return this.elementTop + this.elementHeight;
  },

  scrollBottom() {
    return this.scrollTop + this.clientHeight;
  },
  // ...
},
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;#39;ll use a computed property &lt;code&gt;isElementVisible&lt;/code&gt; which will update whenever either the &lt;code&gt;scrollBounds&lt;/code&gt; or &lt;code&gt;elementBounds&lt;/code&gt; change. It will simply check if the top of the element is above the bottom of the scroll area (&lt;code&gt;top &amp;lt; scrollBottom&lt;/code&gt;) and the bottom of the element is below the top of the scroll area (&lt;code&gt;bottom &amp;gt; scrollTop&lt;/code&gt;). Note that the &lt;code&gt;y&lt;/code&gt; dimension increases moving down the screen.&lt;/p&gt;

&lt;p&gt;For another approach to detecting visibility in Vue, checkout the &lt;a href="https://github.com/Akryum/vue-observe-visibility"&gt;Akryum/vue-observe-visibility&lt;/a&gt; on Github, which is also available as an NPM package.&lt;/p&gt;

      &lt;h3 id="lazy-rendering-pages" class="title"&gt;
        &lt;a name="lazy-rendering-pages" class="anchor" href="#lazy-rendering-pages"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Lazy rendering pages
      &lt;/h3&gt;
    
&lt;p&gt;Previously, we called the &lt;code&gt;drawPage&lt;/code&gt; method (described in the &lt;a href="https://rossta.net/blog/building-a-pdf-viewer-with-vue-part-1.html#rendering-the-page"&gt;previous post&lt;/a&gt;) when the page component mounted. To make the page render lazily, now we call the method only when the element becomes visible, using a watcher.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFPage.vue

watch: {
  isElementVisible(isElementVisible) {
    if (isElementVisible) this.drawPage();
  },
  // ...
},
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;#39;ve defined &lt;code&gt;drawPage&lt;/code&gt; such that it will only render once if called multiple times.&lt;/p&gt;

&lt;p&gt;In the page components, we can simply watch for changes in scroll boundaries and scale—changes to these props may cause a previously &amp;quot;hidden&amp;quot; page to become visible in the browser.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFPage.vue

watch: {
  scale: &amp;#39;updateElementBounds&amp;#39;,
  scrollTop: &amp;#39;updateElementBounds&amp;#39;,
  clientHeight: &amp;#39;updateElementBounds&amp;#39;,
  // ...
},
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the document component, we add listeners to DOM events to trigger the &lt;code&gt;updateScrollBounds&lt;/code&gt; method within the &lt;code&gt;mounted&lt;/code&gt; hook.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue
import throttle from &amp;#39;lodash/throttle&amp;#39;;

export default {
  // ...
  mounted() {
    this.updateScrollBounds();
    const throttledCallback = throttle(this.updateScrollBounds, 300);

    this.$el.addEventListener(&amp;#39;scroll&amp;#39;, throttledCallback, true);
    window.addEventListener(&amp;#39;resize&amp;#39;, throttledCallback, true);

    this.throttledOnResize = throttledCallback;
  },

  beforeDestroy() {
    window.removeEventListener(&amp;#39;resize&amp;#39;, this.throttledOnResize, true);
  },
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A few notes about the implementation above: we use lodash&amp;#39;s &lt;code&gt;throttle&lt;/code&gt; function to ensure our callback is only triggered once every 300ms; otherwise, we&amp;#39;d be making this update potentially dozens of times a second, which for our purposes is unnecessary and could potentially be a performance bottleneck. Since we can attach our &lt;code&gt;throttledCallback&lt;/code&gt; to the &lt;code&gt;&amp;#39;scroll&amp;#39;&lt;/code&gt; event listener of &lt;code&gt;this.$el&lt;/code&gt;, we will also be cleaned up nicely during Vue teardown phase. However, since the &lt;code&gt;&amp;#39;resize&amp;#39;&lt;/code&gt; event will currently only work on the &lt;code&gt;window&lt;/code&gt;, we&amp;#39;ll need to store a reference to the throttled callback as &lt;code&gt;this.throttledOnResize&lt;/code&gt; so we can remove the event listener in Vue&amp;#39;s &lt;code&gt;beforeDestroy&lt;/code&gt; hook.&lt;/p&gt;

&lt;p&gt;For a great explanation of throttling (and its cousin, debouncing) event callbacks, check out &lt;a href="https://css-tricks.com/debouncing-throttling-explained-examples/"&gt;this post on CSS tricks&lt;/a&gt;.&lt;/p&gt;

      &lt;h3 id="adding-quot-infinite-quot-scrolling" class="title"&gt;
        &lt;a name="adding-quot-infinite-quot-scrolling" class="anchor" href="#adding-quot-infinite-quot-scrolling"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Adding &amp;quot;infinite&amp;quot; scrolling
      &lt;/h3&gt;
    
&lt;p&gt;So far we have deferred rendering individual pages to mounted canvas elements until scrolled into view. This allows us to spare CPU cycles at the cost of the brief visual delay as newly visible pages are drawn. However, we are still creating the &lt;code&gt;&amp;lt;PDFPage&amp;gt;&lt;/code&gt; components for every PDF page, regardless of whether they are visible. This results in &lt;code&gt;n - visible&lt;/code&gt; blank &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; elements below the fold.&lt;/p&gt;

&lt;p&gt;We can go one step further. Instead of fetching all the pages up front, we&amp;#39;ll fetch pages in batches as the user scrolls to the bottom of the document. In other words, we&amp;#39;ll implement &amp;quot;infinite scrolling&amp;quot; for PDF pages (though most PDFs of which I&amp;#39;m aware are finite in length). Fetching in batches is a compromise between eagerly loading all pages and fetching one at a time.&lt;/p&gt;

&lt;p&gt;To keep things simple for this tutorial, we&amp;#39;ll add batching directly to the &lt;code&gt;&amp;lt;PDFDocument&amp;gt;&lt;/code&gt; component; in a future post, we&amp;#39;ll extract this information to other parts of our application.&lt;/p&gt;

      &lt;h3 id="batched-fetching" class="title"&gt;
        &lt;a name="batched-fetching" class="anchor" href="#batched-fetching"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Batched fetching
      &lt;/h3&gt;
    
&lt;p&gt;Recall in our document component, we&amp;#39;re tracking a &lt;code&gt;pdf&lt;/code&gt; property and an array of &lt;code&gt;pages&lt;/code&gt;. We now add a &lt;code&gt;cursor&lt;/code&gt; to represent the highest page number in the document we&amp;#39;ve attempted to fetch. We also will track the expected &lt;code&gt;pageCount&lt;/code&gt; using a property provided by the &lt;code&gt;pdf&lt;/code&gt; object.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue

data() {
  return {
    pdf: undefined,
    pages: [],
    cursor: 0,
    // ...
  };
},

computed: {
  pageCount() {
    return this.pdf ? this.pdf.numPages : 0;
  },
  // ...
},
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also previously added a watcher for the &lt;code&gt;pdf&lt;/code&gt; property to fetch all pages:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue

watch: {
  pdf(pdf) {
    this.pages = [];
    const promises = range(1, pdf.numPages).
      map(number =&amp;gt; pdf.getPage(number));

    Promise.all(promises).
      then(pages =&amp;gt; (this.pages = pages));
  },
  // ...
},
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;#39;ll modify this watcher by extracting a method to fetch pages in batches:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue

watch: {
  pdf(pdf) {
    this.pages = [];
    this.fetchPages();
  },
  // ...
},
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is our new &lt;code&gt;fetchPages&lt;/code&gt; implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue

const BATCH_COUNT = 10;

export default {
  // ...

  methods: {
    fetchPages() {
      if (!this.pdf) return;

      const currentCount = this.pages.length;
      if (this.pageCount &amp;gt; 0 &amp;amp;&amp;amp; currentCount === this.pageCount) return;
      if (this.cursor &amp;gt; currentCount) return;

      const startPage = currentCount + 1; // PDF page numbering starts at 1
      const endPage = Math.min(currentCount + BATCH_COUNT, this.pageCount);
      this.cursor = endPage;

      getPages(this.pdf, startPage, endPage)
        .then((pages) =&amp;gt; {
          this.pages.splice(currentCount, 0, ...pages);
          return this.pages;
        })
        .catch((response) =&amp;gt; {
          this.$emit(&amp;#39;document-errored&amp;#39;);
        });
    },
    // ...
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The added complexity in &lt;code&gt;fetchPages&lt;/code&gt; allows us to request small batches of pages with each subsequent call. The &lt;code&gt;currentCount&lt;/code&gt; represents the total number of pages that have already been fetched. The &lt;code&gt;startPage&lt;/code&gt; is simply the next page number of the next would-be page in the array, and the &lt;code&gt;endPage&lt;/code&gt; of the batch is the lesser of an arbitrarily small batch of pages (&lt;code&gt;BATCH_COUNT&lt;/code&gt;) and the remaining pages. We&amp;#39;re able to insert these pages in the correct location in the tracked pages array with &lt;code&gt;this.pages.splice(currentCount, 0, ...pages)&lt;/code&gt;. We also use the &lt;code&gt;this.cursor&lt;/code&gt; property to track the most recently request &lt;code&gt;endPage&lt;/code&gt; to ensure the same batch is only requested once.&lt;/p&gt;

      &lt;h3 id="why-splice-" class="title"&gt;
        &lt;a name="why-splice-" class="anchor" href="#why-splice-"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Why splice?
      &lt;/h3&gt;
    
&lt;p&gt;You may ask, why not simply add the new pages on to the end of the &lt;code&gt;this.pages&lt;/code&gt; array instead? You could imagine using an expression like &lt;code&gt;this.pages.push.apply(this.pages, pages)&lt;/code&gt; to modify the array in place or replacing the array altogether with &lt;code&gt;this.pages = [...this.pages, ...pages]&lt;/code&gt; or &lt;code&gt;concat&lt;/code&gt;. The reason is that &lt;code&gt;getPages&lt;/code&gt; is asynchronous—it returns a promise that fulfills when all pages in the batch have been fetched. It is safer to assume this method can be called in rapid succession where multiple batch requests may be in flight simultaneously. Using &lt;code&gt;splice&lt;/code&gt; to add new pages at the expected position will ensure our batches are inserted into the &lt;code&gt;this.pages&lt;/code&gt; array in the correct order.&lt;/p&gt;

      &lt;h3 id="finding-the-bottom" class="title"&gt;
        &lt;a name="finding-the-bottom" class="anchor" href="#finding-the-bottom"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Finding the bottom
      &lt;/h3&gt;
    
&lt;p&gt;To determine whether the user has scrolled to the bottom of the last of the fetched pages, we will again lean on properties of &lt;code&gt;this.$el&lt;/code&gt;. We can ask if the sum of the &lt;code&gt;scrollTop&lt;/code&gt; of the document and its visible height, &lt;code&gt;clientHeight&lt;/code&gt;, has equalled its total &lt;code&gt;scrollHeight&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue

methods: {
  isBottomVisible() {
    const {scrollTop, clientHeight, scrollHeight} = this.$el;
    return scrollTop + clientHeight &amp;gt;= scrollHeight;
  },
  // ...
},
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;#39;ll call this method during &lt;code&gt;updateScrollBounds&lt;/code&gt; method and record a tracked a true/false property, &lt;code&gt;didReachBottom&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue

data() {
  return {
    didReachBottom: false,
    // ...
  };
},

methods: {
  updateScrollBounds() {
    const {scrollTop, clientHeight} = this.$el;
    this.scrollTop = scrollTop;
    this.clientHeight = clientHeight;
    this.didReachBottom = this.isBottomVisible();
  },
  // ...
},
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then use a watcher to call &lt;code&gt;fetchPages&lt;/code&gt; if this property flips from &lt;code&gt;false&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;. This watcher would fire continuously in a cycle as the user scrolls to the bottom and more pages are fetched.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue

watch: {
  didReachBottom(didReachBottom) {
    if (didReachBottom) this.fetchPages();
  },
  // ...
},
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For another in-depth look at adding infinite scrolling for Vue, check out Chris Nwamba&amp;#39;s &lt;a href="https://scotch.io/tutorials/simple-asynchronous-infinite-scroll-with-vue-watchers"&gt;post on Scotch.io&lt;/a&gt;. There are also a number of packages that abstract infinite scrolling if you&amp;#39;d prefer to lean on open source, including &lt;a href="https://github.com/Akryum/vue-virtual-scroller"&gt;Akryum/vue-virtual-scroller&lt;/a&gt; and &lt;a href="https://github.com/ElemeFE/vue-infinite-scroll"&gt;ElemeFE/vue-infinite-scroll&lt;/a&gt;.&lt;/p&gt;

      &lt;h3 id="wrapping-up" class="title"&gt;
        &lt;a name="wrapping-up" class="anchor" href="#wrapping-up"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Wrapping up
      &lt;/h3&gt;
    
&lt;p&gt;We&amp;#39;ve succeeded in making our documents more lazy; now we can defer both data fetching and page rendering until necessary, potentially improving performance of the initial page load and avoiding waste, especially for large documents.&lt;/p&gt;

&lt;p&gt;We&amp;#39;ve been adding quite a bit of complexity though to our existing &lt;code&gt;&amp;lt;PDFDocument&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;PDFPage&amp;gt;&lt;/code&gt; components; they now both are responsible for making API requests, calculating element boundaries, lazy behavior, etc. Ideally, we&amp;#39;ll want to limit the responsibility of a given component to make our application less resistant to change. In the next post, we&amp;#39;ll refactor our PDF viewer to to separate out data fetching and scrolling behavior into separate &amp;quot;renderless components&amp;quot;. These changes will subsequently allow us to share code and add a new feature: a preview pane.&lt;/p&gt;

&lt;p&gt;And now you&amp;#39;ve reached the bottom of this post!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Rendering PDF pages with PDF.js and Vue</title>
    <link rel="alternate" href="/blog/building-a-pdf-viewer-with-vue-part-1.html"/>
    <id>/blog/building-a-pdf-viewer-with-vue-part-1.html</id>
    <published>2018-06-28T00:00:00+00:00</published>
    <updated>2018-06-28T00:00:00+00:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;I remember a time not too long ago when the possibility of rendering PDFs inline on a web page would have sounded crazy. Then &lt;a href="https://mozilla.github.io/pdf.js/"&gt;PDF.js&lt;/a&gt; came along and changed all that.&lt;/p&gt;

&lt;p&gt;I was recently tasked with just this sort of project and I leveraged PDF.js, &lt;a href="https://vuejs.org/"&gt;Vue&lt;/a&gt;&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;I remember a time not too long ago when the possibility of rendering PDFs inline on a web page would have sounded crazy. Then &lt;a href="https://mozilla.github.io/pdf.js/"&gt;PDF.js&lt;/a&gt; came along and changed all that.&lt;/p&gt;

&lt;p&gt;I was recently tasked with just this sort of project and I leveraged PDF.js, &lt;a href="https://vuejs.org/"&gt;Vue&lt;/a&gt; and &lt;a href="https://webpack.js.org"&gt;Webpack&lt;/a&gt; to put it all together. This post is the first in a series which will demonstrate how I used Vue to render PDF pages to &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; elements. Later we&amp;#39;ll explore conditional rendering and adding paging and zoom controls.&lt;/p&gt;

&lt;p&gt;The latest source code for this project is on Github at &lt;a href="https://github.com/rossta/vue-pdfjs-demo"&gt;rossta/vue-pdfjs-demo&lt;/a&gt;. To see the version of the project described in this post, checkout the &lt;a href="https://github.com/rossta/vue-pdfjs-demo/tree/tutorial/part-1-simple-document"&gt;&lt;code&gt;part-1-simple-document&lt;/code&gt; branch&lt;/a&gt;. Finally, here&amp;#39;s a link to the &lt;a href="https://rossta.net/vue-pdfjs-demo/"&gt;project demo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://rossta.net/vue-pdfjs-demo/"&gt;&lt;img src="/assets/images/screenshots/screenshot-pdf-viewer-61e237fc.png" alt="Demo" /&gt;&lt;/a&gt;&lt;/p&gt;

      &lt;h3 id="similar-projects" class="title"&gt;
        &lt;a name="similar-projects" class="anchor" href="#similar-projects"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Similar projects
      &lt;/h3&gt;
    
&lt;p&gt;Mozilla&amp;#39;s PDF.js package ships with its own web viewer (&lt;a href="https://mozilla.github.io/pdf.js/web/viewer.html"&gt;demo&lt;/a&gt;) For an alternative approach to PDF rendering with Vue, check out the &lt;a href="https://github.com/FranckFreiburger/vue-pdf"&gt;vue-pdf&lt;/a&gt; package.&lt;/p&gt;

      &lt;h3 id="an-incomplete-intro-to-pdf-js" class="title"&gt;
        &lt;a name="an-incomplete-intro-to-pdf-js" class="anchor" href="#an-incomplete-intro-to-pdf-js"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        An incomplete intro to PDF.js
      &lt;/h3&gt;
    
&lt;p&gt;PDF.js is a JavaScript project by Mozilla that makes it easier to parse and render PDFs in HTML. It is comprised of three key pieces: Core, Display, and Viewer.&lt;/p&gt;

&lt;p&gt;The Core layer is the lower level piece that parses and interprets PDFs for use by the other layers. This code is split out into a separate file, &lt;code&gt;pdf.worker.js&lt;/code&gt;, which will run in its own web worker thread in the browser. Since we&amp;#39;re using Webpack, it will handle bundling, fetching, and configuration of the worker script behind the scenes.&lt;/p&gt;

&lt;p&gt;The Viewer layer, as I mentioned earlier, provides a basic user interface for viewing and paging through PDFs in Firefox (or other browsers with included extensions). We won&amp;#39;t be using this piece; in fact, this tutorial could be used as the basis for a Vue.js implementation of alternative viewer.&lt;/p&gt;

&lt;p&gt;Most of our interaction with the PDF.js library will be at the Display layer, which provides the JavaScript API for retrieving and manipulating PDF document and page data. The API relies heavily on Promises, which we&amp;#39;ll be incorporating into our Vue.js components. We&amp;#39;ll also take advantage of dynamic imports to code split our use of PDF.js, since, at least for my purposes, I only want to load the PDF.js library on demand. Keeping it out of the main application Webpack bundle will help keep the initial page load time small.&lt;/p&gt;

      &lt;h3 id="using-pdf-js" class="title"&gt;
        &lt;a name="using-pdf-js" class="anchor" href="#using-pdf-js"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Using PDF.js
      &lt;/h3&gt;
    
&lt;p&gt;Here&amp;#39;s a basic ES6 example of dynamically loading PDF.js to render an entire PDF document (without Vue):&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;import range from &amp;#39;lodash/range&amp;#39;

import(&amp;#39;pdfjs-dist/webpack&amp;#39;).then(pdfjs =&amp;gt; {
  pdfjs
    .getDocument(&amp;#39;wibble.pdf&amp;#39;)
    .then(pdf =&amp;gt; {
      const pagePromises = range(1, pdf.numPages).map(number =&amp;gt; pdf.getPage(number))
      return Promise.all(pagePromises)
    })
    .then(pages =&amp;gt; {
        const scale = 2

        const canvases = pages.forEach(page =&amp;gt; {
          const viewport = page.getViewport(scale)

          // Prepare canvas using PDF page dimensions
          const canvas = document.createElement(&amp;#39;canvas&amp;#39;)
          canvas.height = viewport.height
          canvas.width = viewport.width

          // Render PDF page into canvas context
          const canvasContext = canvas.getContext(&amp;#39;2d&amp;#39;)
          const renderContext = { canvasContext, viewport }
          page.render(renderContext).then(() =&amp;gt; console.log(&amp;#39;Page rendered&amp;#39;))

          document.body.appendChild(canvas)
        })
      },
      error =&amp;gt; console.log(&amp;#39;Error&amp;#39;, error),
    )
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above dynamically imports the PDF.js distribution with &lt;code&gt;import(&amp;#39;pdfjs/dist&amp;#39;)&lt;/code&gt;. Webpack will split the PDF.js code out into its own bundle and load it asynchronously only when that line is executed in the browser. This expression returns a promise that resolves with the PDF.js module when the bundle is successfully loaded and evaluated. With a reference to the modules, &lt;code&gt;pdfjs&lt;/code&gt; we can now exercise the PDF.js document API.&lt;/p&gt;

&lt;p&gt;The expression &lt;code&gt;pdjs.getDocument(&amp;#39;url-to-pdf&amp;#39;)&lt;/code&gt; also returns a promise which resolves when the the document is loaded and parsed by the PDF.js core layer. This promise resolves to an instance of &lt;a href="https://mozilla.github.io/pdf.js/api/draft/PDFDocumentProxy.html"&gt;&lt;code&gt;PDFDocumentProxy&lt;/code&gt;&lt;/a&gt;, which we can use to retrieve additional data from the PDF document. We used the &lt;code&gt;PDFDocumentProxy#numPages&lt;/code&gt; attribute to build a number range of all the pages (using lodash &lt;code&gt;range&lt;/code&gt;) and build an array of promises representing requests for each of the documents pages returned by &lt;code&gt;PDFDocumentProxy#getPage(pageNumber)&lt;/code&gt;. The key here to loading all pages at once is using &lt;code&gt;Promise.all&lt;/code&gt; to resolve when all pages are retrieved as &lt;a href="https://mozilla.github.io/pdf.js/api/draft/PDFPageProxy.html"&gt;PDFPageProxy&lt;/a&gt; objects.&lt;/p&gt;

&lt;p&gt;Finally, for each page object, we create a separate &lt;code&gt;canvas&lt;/code&gt; element and trigger the &lt;code&gt;PDFPageProxy#render&lt;/code&gt; method, which returns another promise and accepts options for a canvas context and viewport. This render method is responsible for drawing the PDF data into the canvas element asynchronously while we append the canvas elements to &lt;code&gt;document.body&lt;/code&gt;.&lt;/p&gt;

      &lt;h3 id="refactoring-to-vue" class="title"&gt;
        &lt;a name="refactoring-to-vue" class="anchor" href="#refactoring-to-vue"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Refactoring to Vue
      &lt;/h3&gt;
    
&lt;p&gt;Our little script works, and for some applications, this may implementaiton may be sufficient. But let&amp;#39;s say we need some interaction, like paging controls, zoom buttons, conditional page fetching and rendering while scrolling, etc. Adding complexity could get unwieldy quickly. For this next stage, we&amp;#39;ll refactor to Vue components, so we can get the benefit of reactivity and make our code more declarative and easier to extend.&lt;/p&gt;

&lt;p&gt;In pseudocode, our component architecture will resemble this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;PDFDocument&amp;gt;
  &amp;lt;PDFPage :number=&amp;quot;1&amp;quot; /&amp;gt;
  &amp;lt;PDFPage :number=&amp;quot;2&amp;quot; /&amp;gt;
  &amp;lt;PDFPage :number=&amp;quot;3&amp;quot; /&amp;gt;
  ...
&amp;lt;/PDFDocument&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

      &lt;h3 id="requirements" class="title"&gt;
        &lt;a name="requirements" class="anchor" href="#requirements"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Requirements
      &lt;/h3&gt;
    
&lt;p&gt;For my project, I used the following npm packages (installed using &lt;code&gt;yarn&lt;/code&gt;).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@vue/cli&lt;/code&gt;: &lt;code&gt;^3.0.0-beta.15&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vue&lt;/code&gt;: &lt;code&gt;^2.5.16&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pdfjs-dist&lt;/code&gt;: &lt;code&gt;^2.0.489&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I would expect it to be straightforward to adapt the code for other relatively recent versions of these packages.&lt;/p&gt;

&lt;aside class="callout panel"&gt;&lt;p&gt;
Since PDF.js will request data via an XMLHTTPRequest in JavaScript, typical crossdomain restrictions apply. For the purposes of this tutorial, we'll assume we have a URL to a PDF that can be retrieved either from our development server or from a server that allows Cross-Origin Resource Sharing (CORS) from our host.
&lt;/p&gt;&lt;/aside&gt;

      &lt;h3 id="fetching-the-pdf" class="title"&gt;
        &lt;a name="fetching-the-pdf" class="anchor" href="#fetching-the-pdf"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Fetching the PDF
      &lt;/h3&gt;
    
&lt;p&gt;Our &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt; component will hard-code default values for a PDF url and a rendering scale which will be passed to a &lt;code&gt;&amp;lt;PDFDocument&amp;gt;&lt;/code&gt; component.&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;!-- src/App.vue --&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;
    &amp;lt;PDFDocument v-bind=&amp;quot;{url, scale}&amp;quot; /&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
  // ...
  data() {
    return {
      url: &amp;#39;https://cdn.filestackcontent.com/5qOCEpKzQldoRsVatUPS&amp;#39;, // a PDF
      scale: 2,
    }
  },
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The document component is responsible for fetching the PDF data through PDF.js and rendering  a &lt;code&gt;&amp;lt;PDFPage&amp;gt;&lt;/code&gt; component for each &lt;code&gt;page&lt;/code&gt; object returned by the API.&lt;/p&gt;

&lt;p&gt;Its &lt;code&gt;data&lt;/code&gt; will track the &lt;code&gt;pdf&lt;/code&gt; object and a list of &lt;code&gt;page&lt;/code&gt; object in &lt;code&gt;pages&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue

export default {
  props: [&amp;#39;url&amp;#39;, &amp;#39;scale&amp;#39;],

  data() {
    return {
      pdf: undefined,
      pages: [],
    };
  },
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the component is mounted, it will fetch the PDF data using the &lt;code&gt;pdfjs.getDocument&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue

export default {
  //...

  created() {
    this.fetchPDF();
  },

  methods: {
    fetchPDF() {
      import(&amp;#39;pdfjs-dist/webpack&amp;#39;).
        then(pdfjs =&amp;gt; pdfjs.getDocument(this.url)).
        then(pdf =&amp;gt; (this.pdf = pdf));
    },
  },
  //...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;#39;ll use a watch callback for the &lt;code&gt;pdf&lt;/code&gt; attribute to fetch all the pages via the &lt;code&gt;pdf.getPage&lt;/code&gt; function provided by PDF.js. Since the return value of &lt;code&gt;getPage&lt;/code&gt; behaves like a promise, we can use &lt;code&gt;Promise.all&lt;/code&gt; to determine when all the &lt;code&gt;page&lt;/code&gt; objects have been fetched and set the resolved collection as the &lt;code&gt;pages&lt;/code&gt; data:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFDocument.vue

import range from &amp;#39;lodash/range&amp;#39;;

export default {
  // ...
  watch: {
    pdf(pdf) {
      this.pages = [];
      const promises = range(1, pdf.numPages).
        map(number =&amp;gt; pdf.getPage(number));

      Promise.all(promises).
        then(pages =&amp;gt; (this.pages = pages));
    },
  },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The template simply renders a &lt;code&gt;&amp;lt;PDFPage&amp;gt;&lt;/code&gt; child component for each &lt;code&gt;page&lt;/code&gt; object. Each page component also needs the &lt;code&gt;scale&lt;/code&gt; prop for rendering the page data to &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;!-- src/components/PDFDocument.vue --&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;pdf-document&amp;quot;&amp;gt;
    &amp;lt;PDFPage
      v-for=&amp;quot;page in pages&amp;quot;
      v-bind=&amp;quot;{page, scale}&amp;quot;
      :key=&amp;quot;page.pageNumber&amp;quot;
    /&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

      &lt;h3 id="setting-up-the-canvas" class="title"&gt;
        &lt;a name="setting-up-the-canvas" class="anchor" href="#setting-up-the-canvas"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Setting up the canvas
      &lt;/h3&gt;
    
&lt;p&gt;Now we can build out the &lt;code&gt;&amp;lt;PDFPage&amp;gt;&lt;/code&gt; element. We&amp;#39;ll simply will use a Vue &lt;code&gt;render&lt;/code&gt; function to create a &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; element with computed attributes, &lt;code&gt;canvasAttrs&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFPage.vue

export default {
  props: [&amp;#39;page&amp;#39;, &amp;#39;scale&amp;#39;],

  render(h) {
    const {canvasAttrs: attrs} = this;
    return h(&amp;#39;canvas&amp;#39;, {attrs});
  },

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To render a PDF to &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; with an acceptable resolution, we can take advantage of a browser property called &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio"&gt;&lt;code&gt;window.devicePixelRatio&lt;/code&gt;&lt;/a&gt;. This value represents the ratio of screen pixels to CSS pixels. Given a hi-resolution display with a &lt;code&gt;devicePixelRatio&lt;/code&gt; of &lt;code&gt;2&lt;/code&gt;, we&amp;#39;d want to give the canvas initial width and height attributes that are two times greater than its corresponding width and height in CSS. Otherwise, rendering our PDF pixels to canvas may appear blurry.&lt;/p&gt;

&lt;p&gt;When the &lt;code&gt;&amp;lt;PDFPage&amp;gt;&lt;/code&gt; component is created, we can access the &lt;code&gt;viewport&lt;/code&gt; property of the &lt;code&gt;page&lt;/code&gt; object, via &lt;code&gt;PDFPageProxy#getViewport&lt;/code&gt;, to obtain the pixel width and height of the PDF. These are the width and height attributes of the &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; element. For the actual size of the &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;, we&amp;#39;ll use CSS attributes.&lt;/p&gt;

&lt;p&gt;Since the &lt;code&gt;scale&lt;/code&gt; prop is reactive and our &lt;code&gt;render&lt;/code&gt; function depends on &lt;code&gt;canvasAttrs&lt;/code&gt;, defining &lt;code&gt;canvasAttrs&lt;/code&gt; as a computed property based off the scale means our PDF pages will automatically re-render when the scale changes. Future iterations will allow to the change &lt;code&gt;scale&lt;/code&gt; prop (using future zoom controls, for example). We&amp;#39;ll simply calculate the width and height via CSS to update the rendered size of the canvas to avoid redrawing the canvas data from the &lt;code&gt;page&lt;/code&gt; object each time. For this, we use a clone of the original viewport, given via the &lt;code&gt;actualSizeViewport&lt;/code&gt; computed property, and the &lt;code&gt;devicePixelRatio&lt;/code&gt; to calculate the target width and height style attributes for the &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here&amp;#39;s the code that puts all that together:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFPage.vue

export default {
  created() {
    // PDFPageProxy#getViewport
    // https://mozilla.github.io/pdf.js/api/draft/PDFPageProxy.html
    this.viewport = this.page.getViewport(this.scale);
  },

  computed: {
    canvasAttrs() {
      let {width, height} = this.viewport;
      [width, height] = [width, height].map(dim =&amp;gt; Math.ceil(dim));

      const style = this.canvasStyle;

      return {
        width,
        height,
        style,
        class: &amp;#39;pdf-page&amp;#39;,
      };
    },

    canvasStyle() {
      const {width: actualSizeWidth, height: actualSizeHeight} = this.actualSizeViewport;
      const pixelRatio = window.devicePixelRatio || 1;
      const [pixelWidth, pixelHeight] = [actualSizeWidth, actualSizeHeight]
        .map(dim =&amp;gt; Math.ceil(dim / pixelRatio));
      return `width: ${pixelWidth}px; height: ${pixelHeight}px;`
    },

    actualSizeViewport() {
      return this.viewport.clone({scale: this.scale});
    },
    //...
  },

  // ...
&lt;/code&gt;&lt;/pre&gt;

      &lt;h3 id="rendering-the-page" class="title"&gt;
        &lt;a name="rendering-the-page" class="anchor" href="#rendering-the-page"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Rendering the page
      &lt;/h3&gt;
    
&lt;p&gt;When the &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; element mounts, we can draw the PDF page data to it using the &lt;code&gt;PDFPageProxy#render&lt;/code&gt; method. It needs context from the &lt;code&gt;viewport&lt;/code&gt; and &lt;code&gt;canvasContext&lt;/code&gt; as arguments. Since that returns a promise, we can be notified when it&amp;#39;s complete.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFPage.vue

export default {
  mounted() {
    this.drawPage();
  },

  methods: {
    drawPage() {
      if (this.renderTask) return;

      const {viewport} = this;
      const canvasContext = this.$el.getContext(&amp;#39;2d&amp;#39;);
      const renderContext = {canvasContext, viewport};

      // PDFPageProxy#render
      // https://mozilla.github.io/pdf.js/api/draft/PDFPageProxy.html
      this.renderTask = this.page.render(renderContext);
      this.renderTask.
        then(() =&amp;gt; this.$emit(&amp;#39;rendered&amp;#39;, this.page));
    },
    // ...
  },
  // ...
&lt;/code&gt;&lt;/pre&gt;

      &lt;h3 id="cleaning-up-after-ourselves" class="title"&gt;
        &lt;a name="cleaning-up-after-ourselves" class="anchor" href="#cleaning-up-after-ourselves"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Cleaning up after ourselves
      &lt;/h3&gt;
    
&lt;p&gt;As we&amp;#39;re working with JavaScript objects that keep state outside of Vue&amp;#39;s control, we should be mindful to call provided teardown methods. The PDF document and page objects provide &lt;code&gt;destroy&lt;/code&gt; methods to be called on teardown, such as, when our render promise fails, the &lt;code&gt;page&lt;/code&gt; object is replaced, or the Vue component itself is destroyed.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/components/PDFPage.vue

export default {
  beforeDestroy() {
    this.destroyPage(this.page);
  },

  methods: {
    drawPage() {
      // ...
      this.renderTask.
        then(/* */).
        catch(this.destroyRenderTask);
    },

    destroyPage(page) {
      if (!page) return;

      // PDFPageProxy#_destroy
      // https://mozilla.github.io/pdf.js/api/draft/PDFPageProxy.html
      page._destroy();

      // RenderTask#cancel
      // https://mozilla.github.io/pdf.js/api/draft/RenderTask.html
      if (this.renderTask) this.renderTask.cancel();
    },

    destroyRenderTask() {
      if (!this.renderTask) return;

      // RenderTask#cancel
      // https://mozilla.github.io/pdf.js/api/draft/RenderTask.html
      this.renderTask.cancel();
      delete this.renderTask;
    },
  },

  watch: {
    page(page, oldPage) {
      this.destroyPage(oldPage);
    },
  },
};
&lt;/code&gt;&lt;/pre&gt;

      &lt;h3 id="wrapping-up" class="title"&gt;
        &lt;a name="wrapping-up" class="anchor" href="#wrapping-up"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Wrapping up
      &lt;/h3&gt;
    
&lt;p&gt;We&amp;#39;ve now converted our original, imperative PDF rendering script with a declarative Vue component hierarchy. We&amp;#39;ve certainly added a lot of code to make this work, but with working knowledge of Vue, we&amp;#39;ve made it easier to reason about, easier to extend, and easier to add features to give our PDF viewer more functionality.&lt;/p&gt;

&lt;p&gt;In the next post, we&amp;#39;ll look at adding some conditional rendering; since all pages aren&amp;#39;t visible when the document is initially loaded, Vue can help us design a system that only fetches and renders PDF pages when scrolled into view.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Deploying Vue with CircleCI 2.0</title>
    <link rel="alternate" href="/blog/deploying-vue-with-circleci-2.html"/>
    <id>/blog/deploying-vue-with-circleci-2.html</id>
    <published>2018-06-07T00:00:00+00:00</published>
    <updated>2018-06-07T00:00:00+00:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;I recently upgraded my &lt;a href="https://github.com/rossta/connect-four-vue"&gt;Connect Four&lt;/a&gt; Vue.js application to build on CircleCI 2.0 . In my &lt;a href="/blog/deploying-vue-to-amazon-s3-with-circleci.html"&gt;previous post&lt;/a&gt;, I showed how I used continuous integration on CircleCI 1.0 to bundle Vue.js assets and upload them to an S3 bucket configured to serve the application...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;I recently upgraded my &lt;a href="https://github.com/rossta/connect-four-vue"&gt;Connect Four&lt;/a&gt; Vue.js application to build on CircleCI 2.0 . In my &lt;a href="/blog/deploying-vue-to-amazon-s3-with-circleci.html"&gt;previous post&lt;/a&gt;, I showed how I used continuous integration on CircleCI 1.0 to bundle Vue.js assets and upload them to an S3 bucket configured to serve the application as a static website. But now that config is only good for another few months: &lt;a href="https://circleci.com/blog/sunsetting-1-0/"&gt;CircleCI is sunsetting 1.0&lt;/a&gt;. Here&amp;#39;s how I upgraded.&lt;/p&gt;

&lt;p&gt;The basic steps of the build are the same: once I push changes to GitHub, CircleCI will detect those changes and trigger a build. It will bundle the app using the &lt;code&gt;vue-cli&lt;/code&gt;. The assets output from that step will then be uploaded to S3 using the &lt;code&gt;s3deploy&lt;/code&gt; golang package only if the build is running against master.&lt;/p&gt;

      &lt;h3 id="the-old-config" class="title"&gt;
        &lt;a name="the-old-config" class="anchor" href="#the-old-config"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        The old config
      &lt;/h3&gt;
    
&lt;p&gt;For reference, here is the old configuration I had been using to deploy the application on CircleCI 1.0.&lt;/p&gt;

&lt;pre&gt;&lt;code class="yaml"&gt;machine:
  environment:
    CIRCLE_BUILD_DIR: $HOME/$CIRCLE_PROJECT_REPONAME
    PATH: $PATH:$CIRCLE_BUILD_DIR/bin:${HOME}/${CIRCLE_PROJECT_REPONAME}/node_modules/.bin&amp;quot;

  post:
    - mkdir -p $CIRCLE_BUILD_DIR/bin
  node:
    version: 8.9.1

dependencies:
  pre:
    - go get -v github.com/bep/s3deploy
  override:
    - yarn
  cache_directories:
    - ~/.cache/yarn
    - bin

test:
  override:
    - yarn build

deployment:
  s3up:
    branch: master
    commands:
      - s3deploy -source=dist/ -region=us-west-2 -bucket=rossta-connect-four
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CircleCI 2.0 offers a number of features to give developers more control and flexibility. This does mean that configuration is more complex than it was in 1.0. A couple of key improvements include &lt;a href="https://circleci.com/blog/introducing-workflows-on-circleci-2-0/"&gt;workflows&lt;/a&gt; and the ability to run builds Docker containers. We&amp;#39;ll take advantage of both to deploy Vue.js to S3.&lt;/p&gt;

&lt;p&gt;Workflows are useful when you need to split a build up into a number of jobs. Those jobs may have different dependencies, or in some cases, may run in parallel. Since I want to bundle assets on all branches, but only deploy from the primary (&lt;code&gt;master&lt;/code&gt;) branch, it makes sense for me to split my CircleCI 2.0 configuration into two jobs, which I&amp;#39;ll call &lt;code&gt;build&lt;/code&gt; and &lt;code&gt;deploy&lt;/code&gt;. It&amp;#39;s worth noting that, even though these jobs must share resources (the bundled assets), I can configure them to run from different Docker containers; this is necessary because the primary language dependency in the build step is node.js and in the deploy phase, it&amp;#39;s golang.&lt;/p&gt;

      &lt;h3 id="the-build-job" class="title"&gt;
        &lt;a name="the-build-job" class="anchor" href="#the-build-job"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        The build job
      &lt;/h3&gt;
    
&lt;p&gt;Here&amp;#39;s what the build step looks like in my new CircleCI 2.0 config:&lt;/p&gt;

&lt;pre&gt;&lt;code class="yaml"&gt;version: 2
jobs:
  build:
    docker:
      - image: circleci/node:8.11.2
    parallelism: 1
    working_directory: ~/rossta/connect-four-vue
    steps:
      - checkout
      - attach_workspace:
          at: ~/rossta/connect-four-vue
      - restore_cache:
          key: v1-yarn-{{ checksum &amp;quot;yarn.lock&amp;quot; }}
      - run: yarn install
      - save_cache:
          key: v1-yarn-{{ checksum &amp;quot;yarn.lock&amp;quot; }}
          paths:
            - ./node_modules
      - run: yarn build
      - persist_to_workspace:
          root: .
          paths: dist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This job will build from the &lt;code&gt;circleci/node:8.11.2&lt;/code&gt; base Docker image. Though any Docker image can be used, CircleCI-supported images are prepared with tools that are typically needed for most builds. (&lt;a href="https://circleci.com/docs/2.0/circleci-images/"&gt;Here&amp;#39;s a list of pre-built CircleCI Docker images&lt;/a&gt;). Useful entries here include &lt;code&gt;restore_cache&lt;/code&gt; and &lt;code&gt;save_cache&lt;/code&gt;, which together ensure the build preserve previously installed node modules when the &lt;code&gt;yarn.lock&lt;/code&gt; file hasn&amp;#39;t changed. Most importantly, the &lt;code&gt;attach_workspace&lt;/code&gt; and &lt;code&gt;persist_to_workspace&lt;/code&gt; entries allow us to share the build output to the &lt;code&gt;dist/&lt;/code&gt; directory across jobs.&lt;/p&gt;

      &lt;h3 id="the-deploy-job" class="title"&gt;
        &lt;a name="the-deploy-job" class="anchor" href="#the-deploy-job"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        The deploy job
      &lt;/h3&gt;
    
&lt;p&gt;Here&amp;#39;s the configuration for the deploy job used to upload assets to S3.&lt;/p&gt;

&lt;pre&gt;&lt;code class="yaml"&gt;version: 2
jobs:
  # ...
  deploy:
    docker:
      - image: circleci/golang:1.9.6
    parallelism: 1
    working_directory: ~/rossta/connect-four-vue
    steps:
      - checkout
      - attach_workspace:
          at: ~/rossta/connect-four-vue
      - restore_cache:
          key: v1-pkg-cache
      - run: go get -v github.com/bep/s3deploy
      - save_cache:
          key: v1-pkg-cache
          paths:
            - /go/pkg
      - run:
          name: Deploy to S3
          command: |
            s3deploy -source=dist/ -region=us-west-2 -bucket=rossta-connect-four
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the deploy, we need a golang base image to run the &lt;code&gt;s3deploy&lt;/code&gt; command. A key step in this job is the &lt;code&gt;attach_workspace&lt;/code&gt; entry, which will contain the &lt;code&gt;dist/&lt;/code&gt; build output we persisted in the build job. That &lt;code&gt;dist/&lt;/code&gt; directory is the source given to the &lt;code&gt;s3deploy&lt;/code&gt; command. The deploy job also specifies &lt;code&gt;restore_cache&lt;/code&gt; and &lt;code&gt;save_cache&lt;/code&gt; for the &lt;code&gt;s3deploy&lt;/code&gt; go package.&lt;/p&gt;

&lt;p&gt;One piece not shown in the config file are the AWS credentials needed to upload the assets to S3. The &lt;code&gt;s3deploy&lt;/code&gt; command will implicitly look for the environment variables &lt;code&gt;AWS_ACCESS_KEY_ID&lt;/code&gt; and &lt;code&gt;AWS_SECRET_ACCESS_KEY&lt;/code&gt;. Since I do not want to publish these credentials to Github, I added them through the CircleCI web interface using &lt;a href="https://circleci.com/docs/2.0/env-vars/#setting-an-environment-variable-in-a-project"&gt;these instructions&lt;/a&gt;.&lt;/p&gt;

      &lt;h3 id="the-workflow" class="title"&gt;
        &lt;a name="the-workflow" class="anchor" href="#the-workflow"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        The workflow
      &lt;/h3&gt;
    
&lt;p&gt;Finally, to tie these jobs together to run the build on all branches and only deploy on &lt;code&gt;master&lt;/code&gt;, I&amp;#39;m using a workflow as shown below:&lt;/p&gt;

&lt;pre&gt;&lt;code class="yaml"&gt;version: 2
# ...
workflows:
  version: 2
  build-and-deploy:
    jobs:
      - build
      - deploy:
          requires:
            - build
          filters:
            branches:
              only: master
&lt;/code&gt;&lt;/pre&gt;

      &lt;h3 id="putting-it-all-together" class="title"&gt;
        &lt;a name="putting-it-all-together" class="anchor" href="#putting-it-all-together"&gt;       &lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;
       &lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;&lt;/path&gt;
       &lt;/svg&gt;
&lt;/a&gt;
        Putting it all together
      &lt;/h3&gt;
    
&lt;p&gt;Here&amp;#39;s the complete configuration for CircleCI 2.0 at the time of this writing, located at &lt;a href="https://github.com/rossta/connect-four-vue/blob/master/.circleci/config.yml"&gt;&lt;code&gt;.circleci/config.yml&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="yaml"&gt;version: 2
jobs:
  build:
    docker:
      - image: circleci/node:8.11.2
    parallelism: 1
    working_directory: ~/rossta/connect-four-vue
    steps:
      - checkout
      - attach_workspace:
          at: ~/rossta/connect-four-vue
      - restore_cache:
          key: v1-yarn-{{ checksum &amp;quot;yarn.lock&amp;quot; }}
      - run: yarn install
      - save_cache:
          key: v1-yarn-{{ checksum &amp;quot;yarn.lock&amp;quot; }}
          paths:
            - ./node_modules
      - run: yarn build
      - persist_to_workspace:
          root: .
          paths: dist

  deploy:
    docker:
      - image: circleci/golang:1.9.6
    parallelism: 1
    working_directory: ~/rossta/connect-four-vue
    steps:
      - checkout
      - attach_workspace:
          at: ~/rossta/connect-four-vue
      - restore_cache:
          key: v1-pkg-cache
      - run: go get -v github.com/bep/s3deploy
      - save_cache:
          key: v1-pkg-cache
          paths:
            - /go/pkg
      - run:
          name: Deploy to S3
          command: |
            s3deploy -source=dist/ -region=us-west-2 -bucket=rossta-connect-four

workflows:
  version: 2
  build-and-deploy:
    jobs:
      - build
      - deploy:
          requires:
            - build
          filters:
            branches:
              only: master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By the way, this blog is also a static website built and published to Github pages via CircleCI. I recently upgraded to its config to 2.0, which you can &lt;a href="https://github.com/rossta/rossta.github.com/blob/develop/.circleci/config.yml"&gt;check out here&lt;/a&gt; if you&amp;#39;re interested. CircleCI 1.0 goes dark at the end of August, 2018, so upgrade your configurations soon!&lt;/p&gt;
</content>
  </entry>
</feed>
